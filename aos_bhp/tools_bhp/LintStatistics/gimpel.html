<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <title>Gimpel On-Line Message Reference Manual</title>




  <meta content="Gimpel Software's PC-lint and FlexeLint On-Line Demos" name="description">


  <meta content="FlexeLint, C/C++, static analysis, PC-lint static debugging, static, UNIX lint, lint" name="keywords">



</head>


<body>
<table style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); width: 650px; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="6" cellspacing="2">


<tbody>
<tr>
<td style="text-align: center;">
<table style="border: 0pt solid ; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 255); height: 65px;" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td style="width: 300px; background-color: rgb(255, 255, 255);"><a href="http://www.gimpel.com/"><img style="border: 0pt solid ; width: 300px; height: 61px;" title="Gimpel Home Page" alt="Gimpel Home Page" src="../index_files/gslogo2.jpg" height="75"></a></td>
<td style="font-family: Helvetica,Arial,sans-serif; text-align: center; background-color: rgb(255, 255, 255); width: 346px;">
<big style="font-style: italic; font-weight: bold; color: rgb(0, 0, 0);">
<b><i>On-Line Message Reference for FlexeLint and PC-lint (aka FlexeLint for Windows)</i></b>
</big><br>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>
<a name="top" id="top">

</a><table style="text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); height: 65px;" border="1" cellpadding="2" cellspacing="1" width="100%">
<tbody>
<tr style="border: 1">
<td colspan="2" style="width: 100%;"><pre>
This file contains the text of the FlexeLint/PC-lint error messages.  It
is to be used in conjunction with licensed FlexeLint/PC-lint software.
Copyright (C) 1985-2009  Gimpel Software, All rights reserved

Gimpel Software  *  3207 Hogarth Lane  *  Collegeville, PA 19426
Phone (610) 584-4261  *  FAX (610) 584-4266  *  www.gimpel.com


    19.   MESSAGES

    19.1  Syntax Errors
    19.2  Internal Errors
    19.3  Fatal Errors
    19.4  Warning Messages
    19.5  Informational Messages
    19.6  Elective Notes
    19.7  C++ Syntax Errors
    19.8  Additional Internal Errors
    19.9  C++ Warning Messages
    19.10  C++ Informational Messages
    19.11  C++ Elective Notes

Most error messages have an associated error number.  By looking up the
number in the list below you can obtain additional information about the
cause of the error.  This information is also available from a
self-extracting executable msg.exe, found on the PC-lint distribution
diskette, which produces the machine-readable ASCII file msg.txt.  For
FlexeLint users, the file msg.txt can be found on the FlexeLint
Supplementary diskette.

Messages numbered 1000 and higher pertain generally to C++.  This is
summarized in the table below.

After a possible 1000 is subtracted off, the remainder lies in the range
0-999.  Remainders in the range 1-199 are syntax errors, 200-299 are
PC-lint/FlexeLint internal errors and should never occur, 300-399 are
fatal errors usually brought about by exceeding some limit, 400-699 are
warning messages that indicate that something is likely to be wrong with
the program being examined.  Remainders in the range 700-899 designate
informational messages.  These may be errors but they also may represent
legitimate programming practices depending upon personal programming
style.  Remainders in the range 900-999 are called "Elective Notes".
They are not automatically output.  You may examine the list to see if
you wish to be alerted to any of them.  Lint also provides an additional
set of elective notes in the 9000 range to help support various coding
guidelines.  Like the traditional Elective Notes, these messages are not
automatically outputted.

                          C             C++           Warning Level

Syntax Errors             1 - 199    1001 - 1199           1
Internal Errors         200 - 299    1200 - 1299           0
Fatal Errors            300 - 399                          0
Warnings                400 - 699    1400 - 1699           2
Informational           700 - 899    1700 - 1899           3
Elective Notes          900 - 999    1900 - 1999           4
Elective Notes         9000 - 9099   Same                  4


                                Glossary

A few of the terms used in the commentary below are:

argument  The actual argument of a function as opposed to a dummy (or
          formal) parameter of a function (see parameter).

arithmetic Any of the integral types (see below) plus float, double, and
           long double.

Boolean   In general, the word Boolean refers to quantities that can be
          either true or false.  An expression is said to be Boolean
          (perhaps it would be better to say 'definitely Boolean') if it
          is of the form: operand op operand where op is a relational (&gt;
          &gt;= &lt; &lt;=), an equality operator (== !=), logical And (&amp;&amp;) or
          logical Or (||).  A context is said to require a Boolean if it
          is used in an if or while clause or if it is the 2nd
          expression of a for clause or if it is an argument to one of
          the operators:  &amp;&amp; or ||.  An expression needn't be definitely
          Boolean to be acceptable in a context that requires a Boolean.
          Any integer or pointer is acceptable.

declaration Gives properties about an object or function (as opposed to
            a definition).

definition That which allocates space for an object or function (as
           opposed to a declaration) and which may also indicate
           properties about the object.  There should be only one
           definition for an object but there may be many declarations.

integral  A type that has properties similar to integers.  These include
          char, short, int, and long and the unsigned variations of any
          of these.

scalar    Any of the arithmetic types plus pointers.

lvalue    Is an expression that can be used on the Left hand side of an
          assignment operator (=).  Some contexts require lvalues such
          as autoincrement (++) and autodecrement (--).

macro     An abbreviation defined by a #define statement.  It may or may
          not have arguments.

member    Elements of a struct and of a union are called members.

module    That which is compiled by a compiler in a single independent
          compilation.  It typically includes all the text of a .c (or a
          .cpp or .cxx, etc.) file plus any text within any #include
          file(s).

parameter A formal parameter of a function as opposed to an actual
          argument (see argument).


                           Message Parameters

Some of the messages are parameterized with one or more of the following
italicized names:

Char      Some character

Context   Specifies one of several contexts in which an assignment can
          be made.  Can be one of:

     o    assignment -- refers to an explicit assignment operator.
     o    return -- refers to the implied assignment of a return
          statement. The type of the expression is converted implicitly
          to the type of the function.
     o    initialization -- refers to the assignment implied by an
          initialization statement.
     o    arg. no.... -- refers to the implied assignment of an argument
          in the presence of a prototype.  The type of the expression is
          implicitly converted to the type within a prototype.
     o    arg. 'this' -- refers to the implied argument of a member
          function call.


FileName  A filename.  Messages containing this parameter can be
          suppressed with the -efile( ... ) option.

Integer   Some integer

Invocation A function call with argument types.  To suppress a message
           containing an Invocation you need the complete call, not just
           the function name.  For example, the call f(1) could result
           in Error 1024 parameterized by 'f(int)'.  To suppress this
           message you could use -esym(1024,f(int)).  You could also use
           wild cards as in -esym(1024,f*).

Kind      A list of control structures.

Location  A line number followed optionally by a filename (if different
          from the current) and/or a module name if different from the
          current.

Name      A string, usually an identifier, that can be suppressed with a
          -esym but not with -elibsym.

String    A sequence of characters identified further in the message
          description.

Symbol    The name of a user identifier referring to a C or C++ object
          such as variable, function, structure, etc.  Messages
          containing this parameter can be suppressed with the -esym(
          ... ) option.  For C++, if Symbol is the name of a function
          the full function signature (including parameters) is given.
          Error suppression with -esym does not require (nor want) the
          parameters.

Type      A type or a top type base is provided.  A top type base is one
          of pointer, function, array, struct, union, or enum.

TypeDiff  Specifies the way in which one type differs from another.
          Because of type qualification, function prototypes, and type
          compounding, it may not be obvious how two types differ.
          Also, see the -etd option to inhibit errors based on type
          differences.  TypeDiff can be one or more of:

     o    basic -- The two types differ in some fundamental way such as
          double versus int.

     o    count -- Two function types differ in the number of arguments.

     o    ellipsis -- Two function types differ in that one is
          prototyped using an ellipsis and the other is not prototyped.
          See <section,15.8,plain vanilla="" functions="">.

     o    incomplete -- At least one of the types is only partially
          specified such as an array without a dimension or a function
          without a prototype.

     o    nominal -- The types are nominally different but are otherwise
          the same.  For example, int versus long where these are the
          same size or double versus long double where these are the
          same size.  The two types are either both integral or both
          float or are functions that return types or have arguments
          that differ nominally.  If long is the same size as int then
          unsigned long will differ from int both as nominal and as
          signed/unsigned.  If not the same size, then the difference is
          precision.

     o    origin -- The types are not actually different but have
          different origins.  For example a struct is defined in two
          separate modules rather than in one header file.  If for some
          reason you want to do this then use the option -etd(origin).

     o    precision -- Two arithmetic types differ in their precision
          such as int vs. long where these are different sizes.

     o    promotion -- Two function types differ in that one is
          prototyped with a char, short or float type and the other is
          not prototyped.

     o    ptrs to... -- Pointers point to different types, some TypeDiff
          code follows.

     o    ptrs to incompatible types -- Pointers point to types which in
          turn differ in precision, count, size, ellipsis or promotion.

     o    qualification -- Qualifiers such as const, volatile, etc. are
          inconsistent.

     o    signed/unsigned -- The types differ in that one is a signed
          integral type and the other is unsigned of the same size, or
          they are both functions that return types that differ in this
          way, or they are both pointers to types that differ in this
          way.

     o    size -- Two arrays differ in array dimension.

     o    strong -- two types differ in that one is strong and the other
          is not the same strong type.

     o    void/nonvoid -- The two types differ in that one is void and
          the other is not or, more frequently, they are both functions
          returning types that differ in this respect or pointers to
          types that differ in this respect.

     o    int/enum-- One type is an enum and the other is an int.

     o    Type = Type -- The two types in an assignment of some kind
          differ in some basic way and no more information is available.

     o    Type vs. Type -- The two types differ in some basic way and no
          more information is available.


                   ------ 19.1 C Syntax Errors ------

</section,15.8,plain></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1" id="1">1</a></td>
<td><pre>     Unclosed Comment (Location) -- End of file was reached with an
      open comment still unclosed.  The Location of the open comment is
      shown.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="2" id="2">2</a></td>
<td><pre>     Unclosed Quote -- An end of line was reached and a matching quote
      character (single or double) to an earlier quote character on the
      same line was not found.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="3" id="3">3</a></td>
<td><pre>     #else without a #if -- A #else was encountered not in the scope
      of a #if, #ifdef or #ifndef.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="4" id="4">4</a></td>
<td><pre>     Too many #if levels -- An internal limit was reached on the level
      of nesting of #if statements (including #ifdef and #ifndef).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="5" id="5">5</a></td>
<td><pre>     Too many #endif's -- A #endif was encountered not in the scope of
      a #if or #ifdef or #ifndef.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="6" id="6">6</a></td>
<td><pre>     Stack Overflow -- One of the built-in non-extendable stacks has
      been overextended.  The possibilities are too many nested #if
      statements, #includes statements (including all recursive
      #include statements), static blocks (bounded by braces) or
      #define replacements.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="7" id="7">7</a></td>
<td><pre>     Unable to open include file: FileName -- FileName is the name of
      the include file which could not be opened.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="8" id="8">8</a></td>
<td><pre>     Unclosed #if (Location) -- A #if (or #ifdef or #ifndef) was
      encountered without a corresponding #endif.  Location is the
      location of the #if.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9" id="9">9</a></td>
<td><pre>     Too many #else's in #if (Location) -- A given #if contained a
      #else which in turn was followed by either another #else or a
      #elif.  The error message gives the line of the #if statement
      that started the conditional that contained the aberration.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="10" id="10">10</a></td>
<td><pre>    Expecting 'String' -- String is the expected token.  The expected
      token could not be found.  This is commonly given when certain
      reserved words are not recognized.
     
                int __interrupt f( );
     
      will receive an Expecting ';' message at the f because it thinks
      you just declared __interrupt.  The cure is to establish a new
      reserved word with +rw(__interrupt).  Also, make sure you are
      using the correct compiler options file.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="11" id="11">11</a></td>
<td><pre>    Excessive Size -- The filename specified on a #include line had a
      length that exceeded FILENAME_MAX characters.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="12" id="12">12</a></td>
<td><pre>    Need &lt; or " -- After a #include is detected and after macro
      substitution is performed, a file specification of the form
      <filename> or "filename" is expected.

</filename></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="13" id="13">13</a></td>
<td><pre>    Bad type -- A type adjective such as long, unsigned, etc. cannot
      be applied to the type which follows.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="14" id="14">14</a></td>
<td><pre>    Symbol 'Symbol' previously defined (Location) -- The named object
      has been defined a second time.  The location of the previous
      definition is provided.  If this is a tentative definition (no
      initializer) then the message can be suppressed with the +fmd
      flag.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="15" id="15">15</a></td>
<td><pre>    Symbol 'Symbol' redeclared (TypeDiff) (Location) -- The named
      symbol has been previously declared or defined in some other
      module (location given) with a type different from the type given
      by the declaration at the current location.  The parameter
      TypeDiff provides further information on how the types differ.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="16" id="16">16</a></td>
<td><pre>    Unrecognized name -- A # directive is not followed by a
      recognizable word.  If this is not an error, use the +ppw option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="17" id="17">17</a></td>
<td><pre>    Unrecognized name -- A non-parameter is being declared where only
      parameters should be.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="18" id="18">18</a></td>
<td><pre>    Symbol 'Symbol' redeclared (TypeDiff) conflicts with Location --
      A symbol is being redeclared.  The parameter TypeDiff provides
      further information on how the types differ.  Location is the
      location of the previous definition.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="19" id="19">19</a></td>
<td><pre>    Useless Declaration -- A type appeared by itself without an
      associated variable, and the type was not a struct and not a
      union and not an enum.  A double semi-colon can cause this as in:

          int x;;

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="20" id="20">20</a></td>
<td><pre>    Illegal use of = -- A function declaration was followed by an =
      sign.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="21" id="21">21</a></td>
<td><pre>    Expected { -- An initializer for an indefinite size array must
      begin with a left brace.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="22" id="22">22</a></td>
<td><pre>    Illegal operator -- A unary operator was found following an
      operand and the operator is not a post operator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="23" id="23">23</a></td>
<td><pre>    Expected colon -- A ? operator was encountered but this was not
      followed by a : as was expected.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="24" id="24">24</a></td>
<td><pre>    Expected an expression, found 'String' -- An operator was found
      at the start of an expression but it was not a unary operator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="25" id="25">25</a></td>
<td><pre>    Illegal constant -- Too many characters were encountered in a
      character constant (a constant bounded by ' marks).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="26" id="26">26</a></td>
<td><pre>    Expected an expression, found 'String' -- An expression was not
      found where one was expected.  The unexpected token is placed in
      the message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="27" id="27">27</a></td>
<td><pre>    Illegal character (0xhh) -- An illegal character was found in the
      source code. The hex code is provided in the message.  A blank is
      assumed.  If you are using strange characters in identifier names
      you will get this message for which you may use the -ident
      option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="28" id="28">28</a></td>
<td><pre>    Redefinition of symbol 'Symbol' Location -- The identifier
      preceding a colon was previously declared at the Location given
      as not being a label.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="30" id="30">30</a></td>
<td><pre>    Expected a constant -- A constant was expected but not obtained.
      This could be following a case keyword, an array dimension, bit
      field length, enumeration value, #if expression, etc.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="31" id="31">31</a></td>
<td><pre>    Redefinition of symbol 'Symbol' conflicts with Location -- A data
      object or function previously defined in this module is being
      redefined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="32" id="32">32</a></td>
<td><pre>    Field size (member 'Symbol') should not be zero -- The length of
      a field was given as non-positive, (0 or negative).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="33" id="33">33</a></td>
<td><pre>    Illegal constant -- A constant was badly formed as when an octal
      constant contains one of the digits 8 or 9.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="34" id="34">34</a></td>
<td><pre>    Non-constant initializer -- A non-constant initializer was found
      for a static data item.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="35" id="35">35</a></td>
<td><pre>    Initializer has side-effects -- An initializer with side effects
      was found for a static data item.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="36" id="36">36</a></td>
<td><pre>    Redefining the storage class of symbol 'Symbol' conflicts with
      Location -- An object's storage class is being changed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="37" id="37">37</a></td>
<td><pre>    Value of enumerator 'Symbol' inconsistent (conflicts with
      Location) -- An enumerator was inconsistently valued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="38" id="38">38</a></td>
<td><pre>    Offset of symbol 'Symbol' inconsistent (Location) -- A member of
      a class or struct appears in a different position (offset from
      the start of the structure) than an earlier declaration.  This
      could be caused by array dimensions changing from one module to
      another.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="39" id="39">39</a></td>
<td><pre>    Redefinition of symbol 'Symbol' conflicts with Location -- A
      struct or union is being redefined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="40" id="40">40</a></td>
<td><pre>    Undeclared identifier 'Name' -- Within an expression, an
      identifier was encountered that had not previously been declared
      and was not followed by a left parenthesis.  Name is the name of
      the identifier.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="41" id="41">41</a></td>
<td><pre>    Redefinition of symbol 'Symbol' -- A parameter of either a
      function or a macro is being repeated.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="42" id="42">42</a></td>
<td><pre>    Expected a statement -- A statement was expected but a token was
      encountered that could not possibly begin a statement.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="43" id="43">43</a></td>
<td><pre>    Vacuous type for variable 'Symbol' -- A vacuous type was found
      such as the void type in a context that expected substance.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="44" id="44">44</a></td>
<td><pre>    Need a switch -- A case or default statement occurred outside a
      switch.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="45" id="45">45</a></td>
<td><pre>    Bad use of register -- A variable is declared as a register but
      its type is inconsistent with it being a register (such as a
      function).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="46" id="46">46</a></td>
<td><pre>    Field type should be int -- Bit fields in a structure should be
      typed unsigned or int.  If your compiler allows other kinds of
      objects, such as char, then simply suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="47" id="47">47</a></td>
<td><pre>    Bad type -- Unary minus requires an arithmetic operand.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="48" id="48">48</a></td>
<td><pre>    Bad type -- Unary * or the left hand side of the ptr (-&gt;)
      operator requires a pointer operand.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="49" id="49">49</a></td>
<td><pre>    Expected a type -- Only types are allowed within prototypes.  A
      prototype is a function declaration with a sequence of types
      within parentheses.  The processor is at a state where it has
      detected at least one type within parentheses and so is expecting
      more types or a closing right parenthesis.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="50" id="50">50</a></td>
<td><pre>    Attempted to take the address of a non-lvalue -- Unary &amp; operator
      requires an lvalue (a value suitable for placement on the left
      hand side of an assignment operator).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="51" id="51">51</a></td>
<td><pre>    Expected integral type -- Unary ~ expects an integral type
      (signed or unsigned char, short, int, or long).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="52" id="52">52</a></td>
<td><pre>    Expected an lvalue -- autodecrement (--) and autoincrement (++)
      operators require an lvalue (a value suitable for placement on
      the left hand side of an assignment operator).  Remember that
      casts do not normally produce lvalues.  Thus

              ++(char *)p;

      is illegal according to the ANSI standard.  This construct is
      allowed by some compilers and is allowed if you use the +fpc
      option (Pointer Casts are lvalues).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="53" id="53">53</a></td>
<td><pre>    Expected a scalar -- Autodecrement (--) and autoincrement (++)
      operators may only be applied to scalars (arithmetics and
      pointers) or to objects for which these operators have been
      defined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="54" id="54">54</a></td>
<td><pre>    Division by 0 -- The constant 0 was used on the right hand side
      of the division operator (/) or the remainder operator (%).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="55" id="55">55</a></td>
<td><pre>    Bad type -- The context requires a scalar, function, array, or
      struct (unless -fsa).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="56" id="56">56</a></td>
<td><pre>    Bad type -- Add/subtract operator requires scalar types and
      pointers may not be added to pointers.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="57" id="57">57</a></td>
<td><pre>    Bad type -- Bit operators ( &amp;, | and ^ ) require integral
      arguments.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="58" id="58">58</a></td>
<td><pre>    Bad type -- Bad arguments were given to a relational operator;
      these always require two scalars and pointers can't be compared
      with integers (unless constant 0).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="59" id="59">59</a></td>
<td><pre>    Bad type -- The amount by which an item can be shifted must be
      integral.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="60" id="60">60</a></td>
<td><pre>    Bad type -- The value to be shifted must be integral.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="61" id="61">61</a></td>
<td><pre>    Bad type -- The context requires a Boolean.  Booleans must be
      some form of arithmetic or pointer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="62" id="62">62</a></td>
<td><pre>    Incompatible types (TypeDiff) for operator ':' -- The 2nd and 3rd
      arguments to ? : must be compatible types.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="63" id="63">63</a></td>
<td><pre>    Expected an lvalue -- Assignment expects its first operand to be
      an lvalue.  Please note that a cast removes the lvaluedness of an
      expression.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="64" id="64">64</a></td>
<td><pre>    Type mismatch (Context) (TypeDiff) -- There was a mismatch in
      types across an assignment (or implied assignment, see Context).
      TypeDiff specifies the type difference.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="65" id="65">65</a></td>
<td><pre>    Expected a member name -- After a dot (.) or pointer (-&gt;)
      operator a member name should appear.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="66" id="66">66</a></td>
<td><pre>    Bad type -- A void type was employed where it is not permitted.
      If a void type is placed in a prototype then it must be the only
      type within a prototype.  (See error number 49.)

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="67" id="67">67</a></td>
<td><pre>    Can't cast from Type to Type -- Attempt to cast a non-scalar to
      an integral.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="68" id="68">68</a></td>
<td><pre>    Can't cast from Type to Type -- Attempt to cast a non-arithmetic
      to a float.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="69" id="69">69</a></td>
<td><pre>    Can't cast from Type to Type -- Bad conversion involving
      incompatible structures or a structure and some other object.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="70" id="70">70</a></td>
<td><pre>    Can't cast from Type to Type -- Attempt to cast to a pointer from
      an unusual type (non-integral).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="71" id="71">71</a></td>
<td><pre>    Can't cast from Type to Type -- Attempt to cast to a type that
      does not allow conversions.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="72" id="72">72</a></td>
<td><pre>    Bad option 'String' -- Was not able to interpret an option.  The
      option is given in String.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="73" id="73">73</a></td>
<td><pre>    Bad left operand -- The cursor is positioned at or just beyond
      either an -&gt; or a . operator.  These operators expect an
      expression primary on their left.  Please enclose any complex
      expression in this position within parentheses.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="74" id="74">74</a></td>
<td><pre>    Address of Register -- An attempt was made to apply the address
      (&amp;) operator to a variable whose storage class was given as
      register.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="75" id="75">75</a></td>
<td><pre>    Too late to change sizes (option 'String') -- The size option was
      given after all or part of a module was processed.  Make sure
      that any option to reset sizes of objects be done at the
      beginning of the first module processed or on the command line
      before any module is processed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="76" id="76">76</a></td>
<td><pre>    can't open file  String -- String is the name of the file.  The
      named file could not be opened for output.  The file was destined
      to become a PC-lint/FlexeLint object module.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="77" id="77">77</a></td>
<td><pre>    Address of bit-field cannot be taken -- The address of a
      bit-field cannot be taken.  The rules of C only allow for taking
      the address of a whole byte (a whole char).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="78" id="78">78</a></td>
<td><pre>    Symbol 'Symbol' typedef'ed at Location used in expression -- The
      named symbol was defined in a typedef statement and is therefore
      considered a type.  It was subsequently found in a context where
      an expression was expected.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="79" id="79">79</a></td>
<td><pre>    Bad type for % operator -- The % operator should be used with
      some form of integer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="80" id="80">80</a></td>
<td><pre>    this use of ellipsis is not strictly ANSI -- The ellipsis should
      be used in a prototype only after a sequence of types not after a
      sequence of identifiers.  Some compilers support this extension.
      If you want to use this feature suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="81" id="81">81</a></td>
<td><pre>    struct/union not permitted in equality comparison -- Two struct's
      or union's are being compared with one of == or !=.  This is not
      permitted by the ANSI standard.  If your compiler supports this,
      suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="82" id="82">82</a></td>
<td><pre>    return <exp>; illegal with void function -- The ANSI standard
      does not allow an expression form of the return statement with a
      void function.  If you are trying to cast to void as in return
      (void)f( ); and your compiler allows it, suppress this message.

</exp></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="83" id="83">83</a></td>
<td><pre>    Incompatible pointer types with subtraction -- Two pointers being
      subtracted have indirect types which differ.  You can get
      PC-lint/FlexeLint to ignore slight differences in the pointers by
      employing one or more of the -ep... options.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="84" id="84">84</a></td>
<td><pre>    sizeof object is zero or object is undefined -- A sizeof returned
      a 0 value.  This could happen if the object were undefined or
      incompletely defined.  Make sure a complete definition of the
      object is in scope when you use sizeof.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="85" id="85">85</a></td>
<td><pre>    Array 'Symbol' has dimension 0 -- An array (named Symbol) was
      declared without a dimension in a context that required a
      non-zero dimension.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="86" id="86">86</a></td>
<td><pre>    Structure 'Symbol' has no data elements -- A structure was
      declared (in a C module) that had no data members.  Though legal
      in C++ this is not legal C.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="87" id="87">87</a></td>
<td><pre>    Expression too complicated for #ifdef or #ifndef -- By the rules
      of C there should be only a single identifier following a #ifdef
      or a #ifndef.  You may also supply a validly constructed C (or
      C++) comment.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="88" id="88">88</a></td>
<td><pre>    Symbol 'Symbol' is an array of empty elements -- An array was
      declared (in a C module) whose elements were each of 0 length.
      Though legal in C++ this is not permitted C.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="89" id="89">89</a></td>
<td><pre>    Argument or option too long ('String') -- The length of an option
      (shown in String) exceeds an internal limit.  Please try to
      decompose the option into something smaller.  At this writing the
      limit is 610 characters.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="90" id="90">90</a></td>
<td><pre>    Option 'String' is only appropriate within a lint comment -- The
      indicated option is not appropriate at the command or the .lnt
      level.  For example if -unreachable is given on the command line
      you will get this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="91" id="91">91</a></td>
<td><pre>    Line exceeds Integer characters (use +linebuf) -- A line read
      from one of the input files is longer than anticipated.  By
      default the line buffer size is 600 characters.  Each time you
      use the +linebuf option you can double this size.  The size can
      be doubled ad infinitum.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="92" id="92">92</a></td>
<td><pre>    Negative array dimension or bit field length (Integer) -- A
      negative array dimension or bit field length is not permitted.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="93" id="93">93</a></td>
<td><pre>    New-line is not permitted within string arguments to macros -- A
      macro invocation contains a string that is split across more than
      one line.  For example:
     
              A( "Hello
                  World" );

      will trigger this message.  Some compilers accept this construct
      and you can suppress this message with -e93 if this is your
      current practice.  But it is more portable to place the string
      constant on one line.  Thus

             A( "Hello World" );

      would be better.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="95" id="95">95</a></td>
<td><pre>    Expected a macro parameter but instead found 'Name' -- The #
      operator (or the non-standard extension to the # operator spelled
      #@) was found within a macro definition but was not immediately
      followed by a parameter of the macro as is required by the
      standards.  Name identifies the token immediately to the right of
      the operator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="96" id="96">96</a></td>
<td><pre>    Unmatched left brace for String on Location -- The purpose of
      this message is to report the location of a left curly brace that
      is unmatched by a right curly brace.  Such an unmatched left
      curly can be far removed from the point at which the unbalance
      was detected (often the end of the compilation unit).  Providing
      the location of the left curly can be extremely helpful in
      determining the source of the imbalance.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="98" id="98">98</a></td>
<td><pre>    Recovery Error (String) -- A recovery error is issued when an
      inconsistent state was found while attempting to recover from a
      syntactic error.  The String provided in the message serves as a
      clue to this inconsistent state.  Since the presumptive cause of
      the error is an earlier error, priority should be placed on
      resolving the original error.  This "Recovery Error" is meant
      only to provide additional information on the state of the
      parser.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="101" id="101">101</a></td>
<td><pre>   Expected an identifier -- While processing a function declarator,
      a parameter specifier was encountered that was not an identifier,
      whereas a prior parameter was specified as an identifier.  This
      is mixing old-style function declarations with the new-style and
      is not permitted.  For example

              void f(n,int m)

      will elicit this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="102" id="102">102</a></td>
<td><pre>   Illegal parameter specification -- Within a function declarator,
      a parameter must be specified as either an identifier or as a
      type followed by a declarator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="103" id="103">103</a></td>
<td><pre>   Unexpected declaration -- After a prototype, only a comma,
      semi-colon, right parenthesis or a left brace may occur.  This
      error could occur if you have omitted a terminating character
      after a declaration or if you are mixing old-style parameter
      declarations with new-style prototypes.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="104" id="104">104</a></td>
<td><pre>   Conflicting types -- Two consecutive conflicting types were found
      such as int followed by double.  Remove one of the types!

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="105" id="105">105</a></td>
<td><pre>   Conflicting modifiers -- Two consecutive conflicting modifiers
      were found such as far followed by near.  Remove one of the
      modifiers!

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="106" id="106">106</a></td>
<td><pre>   Illegal constant -- A string constant was found within a
      preprocessor expression as in

              #if ABC == "abc"

      Such expressions should be integral expressions.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="107" id="107">107</a></td>
<td><pre>   Label 'Symbol' (Location) not defined -- The Symbol at the given
      Location appeared in a goto but there was no corresponding label.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="108" id="108">108</a></td>
<td><pre>   Invalid context -- A continue or break statement was encountered
      without an appropriate surrounding context such as a for, while,
      or do loop or, for the break statement only, a surrounding switch
      statement.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="109" id="109">109</a></td>
<td><pre>   The combination 'short long' is not standard, 'long' is assumed
      -- Some compilers support the non-standard sequence short long.
      This message reports, as an error, that this sequence is being
      used.  If you are required to use the construct then simply
      suppress this message.  As the message indicates, that type will
      be presumed to be long.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="110" id="110">110</a></td>
<td><pre>   Attempt to assign to void -- An attempt was made to assign a
      value to an object designated (possibly through a pointer) as
      void.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="111" id="111">111</a></td>
<td><pre>   Assignment to const object -- An object declared as const was
      assigned a value.  This could arise via indirection.  For
      example, if p is a pointer to a const int then assigning to *p
      will raise this error.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="113" id="113">113</a></td>
<td><pre>   Inconsistent enum declaration -- The sequence of members within
      an enum (or their values) is inconsistent with that of another
      enum (usually in some other module) having the same name.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="114" id="114">114</a></td>
<td><pre>   Inconsistent structure declaration for tag 'Symbol' -- The
      sequence of members within a structure (or union) is inconsistent
      with another structure (usually in some other module) having the
      same name.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="115" id="115">115</a></td>
<td><pre>   Struct/union not defined -- A reference to a structure or a union
      was made that required a definition and there is no definition in
      scope. For example, a reference to p-&gt;a where p is a pointer to a
      struct that had not yet been defined in the current module.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="116" id="116">116</a></td>
<td><pre>   Inappropriate storage class -- A storage class other than
      register was given in a section of code that is dedicated to
      declaring parameters.  The section is that part of a function
      preceding the first left brace.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="117" id="117">117</a></td>
<td><pre>   Inappropriate storage class -- A storage class was provided
      outside any function that indicated either auto or register.
      Such storage classes are appropriate only within functions.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="118" id="118">118</a></td>
<td><pre>   Too few arguments for prototype -- The number of arguments
      provided for a function was less than the number indicated by a
      prototype in scope.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="119" id="119">119</a></td>
<td><pre>   Too many arguments for prototype -- The number of arguments
      provided for a function was greater than the number indicated by
      a prototype in scope.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="120" id="120">120</a></td>
<td><pre>   Initialization without braces of dataless type 'Symbol' -- There
      was an attempt to initialize a nested object (e.g., an array
      element) without braces.  Additionally, that object type
      possesses no data members.
     
            class A { public: void f(); };
            class B { public: A a; int k; } ;
            A a[4] = { {}, {}, {}, {} };            // OK
            B b = { , 34 };                         // Error 120
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="121" id="121">121</a></td>
<td><pre>   Attempting to initialize an object of undefined type 'Symbol' --
      The initialization of an object was attempted where that object
      type has no visible definition.  For example:
     
            class Undefined u = { 5 };
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="122" id="122">122</a></td>
<td><pre>   Digit (Char) too large for radix -- The indicated character was
      found in a constant beginning with zero.  For example, 08 is
      accepted by some compilers to represent 8 but it should be 010 or
      plain 8.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="123" id="123">123</a></td>
<td><pre>   Macro 'Symbol' defined with arguments at Location this is just a
      warning -- The name of a macro defined with arguments was
      subsequently used without a following '('.  This is legal but may
      be an oversight.  It is not uncommon to suppress this message
      (with -e123), because some compilers allow, for example, the
      macro max( ) to coexist with a variable max.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="124" id="124">124</a></td>
<td><pre>   Pointer to void not allowed -- A pointer to void was used in a
      context that does not permit void.  This includes subtraction,
      addition and the relationals (&gt; &gt;= &lt; &lt;=).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="125" id="125">125</a></td>
<td><pre>   Too many storage class specifiers -- More than one storage class
      specifier (static, extern, typedef, register or auto) was found.
      Only one is permitted.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="126" id="126">126</a></td>
<td><pre>   Inconsistent structure definition 'Symbol' -- The named structure
      (or union or enum) was inconsistently defined across modules.
      The inconsistency was recognized while processing a lint object
      module.  Line number information was not available with this
      message.  Alter the structures so that the member information is
      consistent.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="127" id="127">127</a></td>
<td><pre>   Illegal constant -- An empty character constant ('') was found.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="128" id="128">128</a></td>
<td><pre>   Pointer to function not allowed -- A pointer to a function was
      found in an arithmetic context such as subtraction, addition, or
      one of the relationals (&gt; &gt;= &lt; &lt;=).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="129" id="129">129</a></td>
<td><pre>   declaration expected, identifier 'Symbol' ignored -- In a context
      in which a declaration was expected an identifier was found.
      Moreover, the identifier was not followed by '(' or a '['

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="130" id="130">130</a></td>
<td><pre>   Expected integral type -- The expression in a switch statement
      must be some variation of an int (possibly long or unsigned) or
      an enum.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="131" id="131">131</a></td>
<td><pre>   syntax error in call of macro 'Symbol' at location Location --
      This message is issued when a macro with arguments (function-like
      macro) is invoked and an incorrect number of arguments is
      provided.  Location is the location of the start of the macro
      call.  This can be useful because an errant macro call can extend
      over many lines.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="132" id="132">132</a></td>
<td><pre>   Expected function definition -- A function declaration with
      identifiers between parentheses is the start of an old-style
      function definition (K&amp;R style).  This is normally followed by
      optional declarations and a left brace to signal the start of the
      function body.  Either replace the identifier(s) with type(s) or
      complete the function with a function body.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="133" id="133">133</a></td>
<td><pre>   Too many initializers for aggregate 'Symbol' -- In a
      brace-enclosed initializer, there are more items than there are
      elements of the aggregate.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="134" id="134">134</a></td>
<td><pre>   Missing initializer -- An initializer was expected but only a
      comma was present.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="135" id="135">135</a></td>
<td><pre>   comma assumed in initializer -- A comma was missing between two
      initializers.  For example:
     
              int a[2][2] = { { 1, 2 }  { 3, 4 } };
     
      is missing a comma after the first right brace (}).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="136" id="136">136</a></td>
<td><pre>   Illegal macro name -- The ANSI standard restricts the use of
      certain names as macros.  defined is on the restricted list.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="137" id="137">137</a></td>
<td><pre>   constant 'Symbol' used twice within switch -- The indicated
      constant was used twice as a case within a switch statement.
      Currently only enumerated types are checked for repeated
      occurrence.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="138" id="138">138</a></td>
<td><pre>   Can't add parent 'Symbol' to strong type String; creates loop --
      An attempt was made to add a strong type parent to a typedef
      type.  The attempt is either explicit (with the -strong option)
      or implicit with the use of a typedef to a known strong type.
      This attempt would have caused a loop in the strong parent
      relationship.  Such loops are simply not tolerated.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="139" id="139">139</a></td>
<td><pre>   Can't take sizeof function -- There is an attempt to take the
      sizeof a function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="140" id="140">140</a></td>
<td><pre>   Type appears after modifier -- Microsoft modifiers such as far,
      _near, __huge, _pascal, etc. etc. modify the declarator to its
      immediate right.  It therefore should not appear before the type.
      For example, you should write int pascal f(void); rather than
      pascal int f(void);.  Note that const and volatile differ from
      the Microsoft modifiers.  They may appear before or after the
      type.  After reporting the error an attempt is made to process
      the modifiers as the programmer probably intended.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="141" id="141">141</a></td>
<td><pre>   The following option has too many elements: 'String' -- The
      indicated option (given by 'String') is too big.  It most likely
      consists of an itemized list that has too many items.  You should
      decompose the large option into two or more smaller options that
      in sum are equivalent to the one large option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="142" id="142">142</a></td>
<td><pre>   case constant 'String' used previously in this switch -- A
      duplicate case constant was detected.  For example, the following
      code will be diagnosed as a repetition of case constant '1'.
     
          switch( n )
              {
              case 1:  m = 25;    break;
              case 2-1: m = 27;   break;
              }
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="143" id="143">143</a></td>
<td><pre>   Erroneous option: String -- An option contained information that
      was inconsistent with itself or with an earlier option.  The
      String provided in the message explains more fully what the
      problem is.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="144" id="144">144</a></td>
<td><pre>   Non-existent return value for symbol 'Symbol', compare with
      Location -- An attempt was made to use a non-existent return
      value of the named function (identified by Symbol).  It was
      previously decided that the function did not return a value or
      was declared with void.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="145" id="145">145</a></td>
<td><pre>   Type expected before operator, void assumed -- In a context in
      which a type is expected no type is found.  Rather, an operator
      '*' or '&amp;' was encountered.  The keyword void was assumed to have
      preceded this operator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="146" id="146">146</a></td>
<td><pre>   Assuming a binary constant -- A constant of the form 0b... was
      encountered.  This was taken to be a binary constant.  For
      example, 0b100 represents the value 4.  If your compiler supports
      binary constants you may suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="147" id="147">147</a></td>
<td><pre>   sizeof takes just one argument -- An expression of the form
      sizeof(a,b) was detected.  A second argument is non standard and
      has been used by some compilers to denote an option to the sizeof
      operator.  If your compiler has a use for the second argument
      then suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="148" id="148">148</a></td>
<td><pre>   member 'Symbol' previously declared at Location -- The indicated
      member was previously declared within the same structure or
      union.  Although a redeclaration of a function may appear benign
      it is just not permitted by the rules of the language. One of the
      declarations should be removed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="149" id="149">149</a></td>
<td><pre>   C++ construct 'String' found in C code -- An illegal construct
      was found in C code.  It looked as though it might be suitable
      for C++.  The quoted string identifies the construct further.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="150" id="150">150</a></td>
<td><pre>   Token 'String' unexpected String -- An unexpected token was
      encountered.  The action taken, if any, is identified by the
      second message parameter.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="151" id="151">151</a></td>
<td><pre>   Token 'Name' inconsistent with abstract type -- In a context in
      which an abstract type is allowed such as within a cast or after
      a sizeof, and after starting to parse the abstract type, an
      identifier was found.  For example:

              x = (int y) z;

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="152" id="152">152</a></td>
<td><pre>   Lob base file 'file name' missing -- The indicated file has been
      specified as the base of lob production via the option -lobbase(
      ).  On output, this message is given if the lob base is missing.
      The situation is correctable by simply producing the missing lob
      output.  This will not be a problem given the appropriate
      dependencies in the make file.  On input, the most likely cause
      of this message is an out-of-date base file.  A hash code within
      the lob file being read, did not match a similar code already
      embedded within the base.  The input lob file should be
      considered in error and should be regenerated.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="153" id="153">153</a></td>
<td><pre>   Could not create temporary file -- This message is produced when
      generating a lob output file based upon some lob base file.  When
      the lob file is produced, it is first written to a temporary.
      The temporary is generated by the C library function tmpnam( ).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="154" id="154">154</a></td>
<td><pre>   Could not evaluate type 'String', int assumed -- String in the
      message is the second argument to either a printf_code option or
      a scanf_code option.  When used, it was to be evaluated as a
      type.  Unfortunately the type could not be identified.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="155" id="155">155</a></td>
<td><pre>   Ignoring { }'ed sequence within an expression, 0 assumed -- Some
      compilers support what looks like a compound statement as a C/C++
      expression.  For example to define the absolute value of an
      integer which guarantees that it will be read only once you may
      use:
     
            #define abs(a) { int b = a; b &gt;= 0 ? b : -b; }
     
      The last expression in the list is the result.  To syntactically
      support the construct without running amuck we recognize the
      sequence and issue this message.  If you want to use the facility
      just suppress the message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="156" id="156">156</a></td>
<td><pre>   Braced initializer for scalar type 'Name' -- An example of an
      initializer that will draw this complaint is as follows.
     
            int s[] = { { 1 } };
     
      After the compiler has seen the first curly it is expecting to
      see a number (or other numeric expression).  Compilers that
      strictly adhere to the ISO C and C++ Standards will flag this as
      ill-formed code.

      Note that it is legal (but somewhat arcane) to employ a left
      curly at the top-level when initializing an object of scalar
      type. For example, the following is well-formed:
     
            int i = { 0 };       // OK; initialize scalar i with 0.
            char *t = { "bar" }; // OK; initialize scalar t with a pointer to
                                 // a statically allocated array.
     
      Also note: as the example above implies, this message can apply
      to pointers to arrays of char; it does not apply to arrays.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="157" id="157">157</a></td>
<td><pre>   No data may follow an incomplete array -- An incomplete array is
      allowed within a struct of a C99 or C++ program but no data is
      allowed to appear after this array.  For example:
     
            struct A { int x; int a[]; int b; };
     
      This diagnostic is issued when the 'b' is seen.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="158" id="158">158</a></td>
<td><pre>   Assignment to variable 'Symbol' (Location) increases capability
      -- An assignment has been made to a variable that increases
      capability.  A typical capability increase is to remove const
      protection as in the following example:
     
                int *p;
                const int *q;
                p = q;          // Error 158
     
      If a capability increase is seen in situations other than an
      assignment or if the variable is not available, Warning 605 is
      issued.  Please see the description of that message for further
      information concerning capability increase.  See also
      Informational messages 1776 and 1778 in Section 13.8 C++
      Informational Messages.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="159" id="159">159</a></td>
<td><pre>   enum following a type is non-standard -- Normally two different
      types are not permitted within the same type specification; this
      will ordinarily result in Error 104.  However, some compilers
      support 'sized' enumerations wherein a scalar type can precede
      the enum keyword.  E.g.
     
                char enum color { red, green, blue };
     
      When the second type is an enum we do not issue a 104 but emit
      Error 159 instead.  By suppressing this message (with -e159) such
      constructs will be supported.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="160" id="160">160</a></td>
<td><pre>   The sequence '( {' is non standard and is taken to introduce a
      GNU statement expression -- Lint encountered the sequence '( {'
      in a context where an expression (possibly a sub-expression) is
      expected.
     
                int n = ({  // Error 160 here
                         int y = foo ();
                         int z;
                         if (y &gt; 0)
                             z = y;
                         else z = - y;
                         z; })
                // Now n has the last value of z.
     
      The primary intention of this message is to alert the user to the
      non-standard nature of this construct.  The typical response is
      to suppress the message and go on.  But a few caveats are in
      order.

      Programmers who intend to work only with C code with the GNU
      extensions may safely disable this diagnostic but C++ users
      should think twice.  This is partly for the reasons given in
      GCC's documentation (see the section entitled "Statements and
      Declarations in Expressions") and partly because the meaning of
      '( {' will change in G++ when its maintainers implement
      Initializer Lists (a new core language feature that is expected
      to appear in the 2010 version of the ISO C++ Standard).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="161" id="161">161</a></td>
<td><pre>   Repeated use of parameter 'Symbol' in parameter list -- The name
      of a function parameter was repeated.  For example:
     
                void f( int n, int m, int n ) {}
     
      will cause this message to be issued.  Names of parameters for a
      given function must all be different.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="165" id="165">165</a></td>
<td><pre>   An [unscoped] enumeration cannot be forward-declared [without an
      enum-base] (int is assumed) -- This message is issued at the
      point of a forward-declaration of an enumeration like so:
     
              enum E; // Error
     
      This is prohibited by ISO C and ISO C++98.  In C++0x, we can
      modify this example to be well-formed by explicitly indicating
      the underlying integral type; example:
     
              enum E : unsigned short; // Ok
     
      If you are not using C++0x and/or your compiler supports the
      construct you may simply suppress this message with a -e165.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="166" id="166">166</a></td>
<td><pre>   Function defined within a function -- A function definition was
      found within the body of another function's definition.  Such a
      construct is almost certainly an error.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="170" id="170">170</a></td>
<td><pre>   Explicit type-specifier required for symbol 'Symbol', int assumed
      -- A declaration did not have an explicit type as required by C99
      or C++.  int was assumed.  This could easily happen if an
      intended comma was replaced by a semicolon.  For example, if
      instead of typing:
     
          double       radius,
                       diameter;
     
      the programmer had typed:
     
          double       radius;
                       diameter;
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="171" id="171">171</a></td>
<td><pre>   Ellipsis requires at least one parameter-declaration -- A
      function declaration was seen with '...' but no
      parameter-declaration before it, as required by the ISO C syntax.
      This diagnostic is not given for C++ code.


</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="2" id="2">2</a></td>
<td><pre>   Internal Error -- Some inconsistency or contradiction was
      discovered in the PC-lint/FlexeLint system.  This may or may not
      be the result of a user error.  This inconsistency should be
      brought to the attention of Gimpel Software.


                    ------ 19.3 Fatal Errors ------

in this category are normally fatal and suppressing the error is
impossible.  However, those errors marked with an asterisk(*)
be suppressed and processing will be continued.  For example -e306
allow reprocessing of modules.


</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="301" id="301">301</a></td>
<td><pre>   Stack overflow -- There was a stack overflow while processing
      declarations.  Approximately 50 nested declarators were found.
      For example, if a '/' followed by 50 consecutive '*'s were to
      introduce a box-like comment and if the '/' were omitted, then
      this message would be produced.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="302" id="302">302</a></td>
<td><pre>   Exceeded Available Memory -- Main memory has been exhausted.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="303" id="303">303</a></td>
<td><pre>   String too long (try +macros) -- A single #define definition or
      macro invocation exceeded an internal limit (of 4096 characters).
      As the diagnostic indicates the problem can be corrected with an
      option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="304" id="304">304</a></td>
<td><pre>   Corrupt object file, code Integer, symbol=String -- A
      PC-lint/FlexeLint object file is apparently corrupted.  Please
      delete the object module and recreate it using the -oo option.
      The special code identifier number as well as a list of symbol
      names are optionally suffixed to the message as an aid in
      diagnosing the problem by technical support.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="305" id="305">305</a></td>
<td><pre>   Unable to open module 'file name' -- file name is the name of the
      file.  The named module could not be opened for reading.  Perhaps
      you misspelled the name.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="306" id="306">306</a></td>
<td><pre>   Previously encountered module 'FileName' -- FileName is the name
      of the module.  The named module was previously encountered.
      This is probably a user blunder.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="307" id="307">307</a></td>
<td><pre>   Can't open indirect file 'FileName' -- FileName is the name of
      the indirect file.  The named indirect file (ending in .lnt)
      could not be opened for reading.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="308" id="308">308</a></td>
<td><pre>   Can't write to standard out -- stdout was found to equal NULL.
      This is most unusual.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="309" id="309">309</a></td>
<td><pre>   #error ... -- The #error directive was encountered.  The ellipsis
      reflects the original line.  Normally processing is terminated at
      this point.  If you set the fce (continue on #error) flag,
      processing will continue.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="310" id="310">310</a></td>
<td><pre>   Declaration too long: 'String...' -- A single declaration was
      found to be too long for an internal buffer (about 2000
      characters).  This occurred when attempting to write out the
      declaration using the -o... option.  The first 30 characters of
      the declaration is given in String.  Typically this is caused by
      a very long struct whose substructures, if any, are untagged.
      First identify the declaration that is causing the difficulty.
      If a struct or union, assign a tag to any unnamed substructures
      or subunion.  A typedef can also be used to reduce the size of
      such a declaration.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="312" id="312">312</a></td>
<td><pre>   Lint Object Module has obsolete or foreign version id: Integer --
      A lint object module was produced with a prior or different
      version of PC-lint/FlexeLint.  Delete the.lob file and recreate
      it using your new version of PC-lint/FlexeLint.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="313" id="313">313</a></td>
<td><pre>   Too many files -- The number of files that PC-lint/FlexeLint can
      process has exceeded an internal limit.  The FlexeLint user may
      recompile his system to increase this limit.  Look for symbol
      FSETLEN in custom.h.  Currently, the number of files is limited
      to 4096.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="314" id="314">314</a></td>
<td><pre>   Previously used .lnt file: FileName -- The indirect file named
      was previously encountered.  If this was not an accident, you may
      suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="315" id="315">315</a></td>
<td><pre>   Exceeded message limit (see -limit) -- The maximum number of
      messages was exceeded.  Normally there is no limit unless one is
      imposed by the -limit(n) option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="316" id="316">316</a></td>
<td><pre>   Error while writing to file "file name" -- The given file could
      not be opened for output.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="317" id="317">317</a></td>
<td><pre>   File encoding, String, not currently supported -- Lint detected a
      byte order mark at the beginning of a file which indicated the
      file is encoded in the given format.  As of this writing, the
      only formats supported to any extent are ASCII and UTF-8 (for
      which Lint presumes ASCII encoding).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="318" id="318">318</a></td>
<td><pre>   EOF for a module found within a macro argument list -- We found
      the end of a module within the argument list of a macro.  Since
      such situations are almost certain to be erroneous, we gracefully
      shut down, alerting the User to the reason.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="321" id="321">321</a></td>
<td><pre>   Declaration stack overflow -- An overflow occurred in the stack
      used to contain array, pointer, function or reference modifiers
      when processing a declarator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="322" id="322">322</a></td>
<td><pre>   Unable to open include file FileName -- FileName is the name of
      the include file which could not be opened.  Directory search is
      controlled by options:  -i +fdi and the INCLUDE environment
      variable.  This is a suppressible fatal message.  If option -e322
      is used, Error message 7 will kick in.  A diagnostic will be
      issued but processing will continue.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="323" id="323">323</a></td>
<td><pre>   Token String too long -- In attempting to save a token for later
      reuse, a fixed size buffer was exceeded (governed by the size
      M_TOKEN).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="324" id="324">324</a></td>
<td><pre>   Too many symbols Integer -- Too many symbols were encountered.
      An internal limit was reached.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="325" id="325">325</a></td>
<td><pre>   Cannot re-open file 'file name' -- In the case of a large number
      of nested includes, files in the outer fringe need to be closed
      before new ones are opened.  These outer files then need to be
      re-opened.  An error occurred when attempting to re-open such a
      file.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="326" id="326">326</a></td>
<td><pre>   String 'String ...' too long, exceeds Integer characters -- A
      string (first 40 characters provided in the message) exceeds some
      internal limit (provided in the message).  There is no antidote
      to this condition in the form of an option.  FlexeLint customers
      may recompile with a redefinition of either M_STRING (maximum
      string) or M_NAME (maximum name).  To override the definition in
      custom.h we suggest recompiling with an appropriate -dvar=value
      option assuming your compiler supports the option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="328" id="328">328</a></td>
<td><pre>   Bypass header 'Name' follows a different header sequence than in
      module 'String' which includes File1 where the current module
      includes File2 -- This message is issued when a header is
      #include'd that had previously been designated as bypass and it
      has been determined that this header follows a different header
      include sequence than in some other module.  The name of the
      other module is given by the second parameter of this message.
      In order not to bury the programmer under a ton of header names,
      we have made an effort to determine the precise point where the
      two modules went their separate ways.  The first include file
      difference occurred when that other module included the header
      identified by File1, whereas the current module was attempting to
      include the header identified by File2.  Each Filei is a pair of
      parameters of the form 'String' (Location) where the location is
      the point of the #include.

      For example:
     
                Module x.cpp:
                    #include "alpha.h"
                    #include "delta.h"
                    #include "beta.h"
                    #include "gamma.h"

                Module y.cpp:
                    #include "alpha.h"
                    #include "beta.h"
                    #include "gamma.h"
     
      When the include of "beta.h" occurs in module y.cpp (and if
      beta.h has been designated as bypass), there will be a Fatal
      Error 328 that the header sequence of module 'x.cpp' differs from
      the current module in that the former module included 'delta.h'
      at a point where the current module included 'beta.h'.

      It was necessary to make this message a fatal error since
      attempting to bypass headers that do not follow a consistent
      header sequence is an act of folly.  It is possible to continue
      on after the 328 in hopes of picking up more inconsistencies in
      other modules.  This can be done using the +fce
      (Continue-on-Error) flag.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="333" id="333">333</a></td>
<td><pre>   Not allowed to open file 'String' -- A 'forbidden' file was
      opened.  Opening such a file is considered a security violation
      by a hosted implementation.

                 ------ 19.4 C Warning Messages ------

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="401" id="401">401</a></td>
<td><pre>   symbol 'Symbol' not previously declared static at Location -- The
      indicated Symbol declared static was previously declared without
      the static storage class.  This is technically a violation of the
      ANSI standard. Some compilers will accept this situation without
      complaint and regard the Symbol as static.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="402" id="402">402</a></td>
<td><pre>   static function 'Symbol' (Location) not defined -- The named
      Symbol was declared as a static function in the current module
      and was referenced but was not defined (in the module).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="403" id="403">403</a></td>
<td><pre>   static symbol 'Symbol' has unusual type modifier -- Some type
      modifiers such as _export are inconsistent with the static
      storage class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="404" id="404">404</a></td>
<td><pre>   struct not completed within file 'FileName' -- A struct (or union
      or enum) definition was started within a header file but was not
      completed within the same header file.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="405" id="405">405</a></td>
<td><pre>   #if not closed off within file 'FileName' -- An #if construct was
      begun within a header file (name given) but was not completed
      within that header file.  Was this intentional?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="406" id="406">406</a></td>
<td><pre>   Comment not closed off within file 'FileName' -- A comment was
      begun within a header file (name given) but was not completed
      within that header file.  Was this intentional?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="407" id="407">407</a></td>
<td><pre>   Inconsistent use of tag 'Symbol' conflicts with Location -- A tag
      specified as a union, struct or enum was respecified as being one
      of the other two in the same module. For example:
     
              struct tag *p;
              union tag *q;
     
      will elicit this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="408" id="408">408</a></td>
<td><pre>   Type mismatch with switch expression -- The expression within a
      case does not agree exactly with the type within the switch
      expression.  For example, an enumerated type is matched against
      an int.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="409" id="409">409</a></td>
<td><pre>   Expecting a pointer or array -- An expression of the form i[...]
      was encountered where i is an integral expression.  This could be
      legitimate depending on the subscript operand.  For example, if i
      is an int and a is an array then i[a] is legitimate but unusual.
      If this is your coding style, suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="410" id="410">410</a></td>
<td><pre>   size_t not what was expected from fzl and/or fzu, using 'Type' --
      This warning is issued if you had previously attempted to set the
      type of sizeof by use of the options +fzl, -fzl, or -fzu, and a
      later size_t declaration contradicts the setting.  This usually
      means you are attempting to lint programs for another system
      using header files for your own system.  If this is the case we
      suggest you create a directory housing header files for that
      foreign system, alter size_t within that directory, and lint
      using that directory.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="411" id="411">411</a></td>
<td><pre>   ptrdiff_t not what was expected from fdl option, using 'Type' --
      This warning is issued if you had previously attempted to set the
      type of pointer differences by use of the fdl option and a later
      ptrdiff_t declaration contradicts the setting.  See suggestion in
      Error Message 410.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="412" id="412">412</a></td>
<td><pre>   Ambiguous format specifier '%X' -- The format specifier %X when
      used with one of the scanf family, is ambiguous.  With Microsoft
      C it means %lx whereas in ANSI C it has the meaning of %x.  This
      ambiguous format specification has no place in any serious C
      program and should be replaced by one of the above.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="413" id="413">413</a></td>
<td><pre>   Likely use of null pointer 'Symbol' in [left/right] argument to
      operator 'String' Reference -- From information gleaned from
      earlier statements, it appears certain that a null pointer (a
      pointer whose value is 0) has been used in a context where null
      pointers are inappropriate.  These include:  Unary *, pointer
      increment (++) or decrement(--), addition of pointer to numeric,
      and subtraction of two pointers.  In the case of binary
      operators, one of the words 'left' or 'right' is used to
      designate which operand is null.  Symbol identifies the pointer
      variable that may be null.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="414" id="414">414</a></td>
<td><pre>   Possible division by 0 -- The second argument to either the
      division operator (/) or the modulus operator (%) may be zero.
      Information is taken from earlier statements including
      assignments, initialization and tests.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="415" id="415">415</a></td>
<td><pre>   access of out-of-bounds pointer ('Integer' beyond end of data) by
      operator 'String' -- An out-of-bounds pointer was accessed.
      String designates the operator.  The parameter 'Integer' gives
      some idea how far out of bounds the pointer may be.  It is
      measured in units given by the size of the pointed to object.
      The value is relative to the last item of good data and therefore
      should always be greater than zero.  For example:
     
              int a[10];
              a[10] = 0;
     
      results in an overflow message containing the phrase '1 beyond
      end of data'.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="416" id="416">416</a></td>
<td><pre>   creation of out-of-bounds pointer ('Integer' beyond end of data)
      by operator 'String' -- An out-of-bounds pointer was created.
      See message 415 for a description of the parameters Integer and
      String.  For example:
     
              int a[10];

                ... 
              f( a + 11 );
     
      Here, an illicit pointer value is created and is flagged as such
      by PC-lint/FlexeLint.  Note that the pointer a+10 is not
      considered by PC-lint/FlexeLint to be the creation of an
      out-of-bounds pointer.  This is because ANSI C explicitly allows
      pointing just beyond an array.  Access through a+10, however, as
      in *(a+10) or the more familiar a[10], would be considered
      erroneous but in that case message 415 would be issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="417" id="417">417</a></td>
<td><pre>   integral constant 'String' has precision Number which is longer
      than long long int -- The longest possible integer is by default
      8 bytes (see the +fll flag and then the -sll# option).  An
      integral constant was found to be even larger than such a
      quantity.  For example: 0xFFFF0000FFFF0000F.  String is the token
      in error.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="418" id="418">418</a></td>
<td><pre>   Passing null pointer to function 'Symbol', Context Reference -- A
      NULL pointer is being passed to a function identified by Symbol.
      The argument in question is given by Context.  The function is
      either a library function designed not to receive a NULL pointer
      or a user function dubbed so via the option -function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="419" id="419">419</a></td>
<td><pre>   Apparent data overrun for function 'Symbol', argument Integer
      exceeds argument Integer -- This message is for data transfer
      functions such as memcpy, strcpy, fgets, etc. when the size
      indicated by the first cited argument (or arguments) exceeds the
      size of the buffer area cited by the second.  The message may
      also be issued for user functions via the -function option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="420" id="420">420</a></td>
<td><pre>   Apparent access beyond array for function 'Symbol', argument
      Integer exceeds Integer Reference -- This message is issued for
      several library functions (such as fwrite, memcmp, etc.) wherein
      there is an apparent attempt to access more data than exist.  For
      example, if the length of data specified in the fwrite call
      exceeds the size of the data specified.  The function is
      specified by Symbol and the arguments are identified by argument
      number.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="421" id="421">421</a></td>
<td><pre>   Caution -- function 'Symbol' is considered dangerous -- This
      message is issued (by default) for the built-in function gets.
      This function is considered dangerous because there is no
      mechanism to ensure that the buffer provided as first argument
      will not overflow.  A well known computer virus (technically a
      worm) was created based on this defect.  Through the -function
      option, the user may designate other functions as dangerous.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="422" id="422">422</a></td>
<td><pre>   Passing to function 'Symbol' a negative value (Integer), Context
      Reference -- An integral value that appears to be negative is
      being passed to a function that is expecting only positive values
      for a particular argument.  The message contains the name of the
      function (Symbol), the questionable value (Integer) and the
      argument number (Context).  The function may be a standard
      library function designed to accept only positive values such as
      malloc or memcpy (third argument), or may have been identified by
      the user as such through the -function or -sem options.

      The negative integral value may in fact be unsigned.  Thus:
     
                void *malloc( unsigned );
                void f( )
                    {
                    int n = -1;
                    int *p;
                    p = malloc(n);                  // Warning 422
                    p = malloc( (unsigned) n );     // Warning 422
                    }
     
      will result in the warnings indicated.  Note that casting the
      expression does not inhibit the warning.

      There is a slight difference in behavior on 32-bit systems versus
      16-bit systems.  If long is the same size as int (as in 32-bit
      systems) the warning is issued based upon the sign bit.  If long
      is larger than an int (as is true on typical 16-bit systems) the
      warning is issued if the value was a converted negative as in the
      examples above.  It is not issued if an unsigned int has the
      high-order bit set.  This is because it is not unreasonable to
      malloc more that 32,176 bytes in a 16-bit system.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="423" id="423">423</a></td>
<td><pre>   Creation of memory leak in assignment to variable 'Symbol' -- An
      assignment was made to a pointer variable (designated by Symbol)
      which appeared to already be holding the address of an allocated
      object which had not been freed.  The allocation of memory which
      is not freed is considered a memory leak.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="424" id="424">424</a></td>
<td><pre>   Inappropriate deallocation (Name1) for 'Name2' data. -- This
      message indicates that a deallocation (free( ), delete, or
      delete[]) as specified by String1 is inappropriate for the data
      being freed.  [12, Item 5]

      The kind of data (specified by String2) is one or more of:
      malloc, new, new[], static, auto, member, modified or constant.
      These have the meanings as described below:

      malloc    data is data obtained from a call to malloc, calloc or
                realloc.
      new and new[]  data is data derived from calls to new.
      static    data is either static data within a function or
                external data.
      auto      data is non-static data in a function.
      member    data is a component of a structure (and hence can't be
                independently freed).
      modified  data is the result of applying pointer arithmetic to
                some other pointer.  E.g.
       
                    p = malloc(100);
                    free( p+1 );    // warning

                p+1 is considered modified.
      constant  data is the result of casting a constant to a pointer.
                E.g.
       
                    int *p = (int *) Ox80002;
                    free(p);    // warning

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="425" id="425">425</a></td>
<td><pre>   'Message' in processing semantic 'String' at token 'String' --
      This warning is issued when a syntax error is encountered while
      processing a Semantic option (-sem).  The 'Message' depends upon
      the error.  The first 'String' represents the portion of the
      semantic being processed.  The second 'String' denotes the token
      being scanned when the error is first noticed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="426" id="426">426</a></td>
<td><pre>   Call to function 'Symbol' violates semantic 'String' -- This
      Warning message is issued when a user semantic (as defined by
      -sem) is violated.  'String' is the subportion of the semantic
      that was violated.  For example:
     
                //lint -sem( f, 1n &gt; 10 &amp;&amp; 2n &gt; 10 )
                void f( int, int );
                ...
                    f( 2, 20 );

      results in the message:

           Call to function 'f(int, int)' violates semantic '(1n&gt;10)'

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="427" id="427">427</a></td>
<td><pre>   // comment terminates in \ -- A one-line comment terminates in
      the back-slash escape sequence.  This means that the next line
      will be absorbed in the comment (by a standards-conforming
      compiler -- not all compilers do the absorption, so beware).  It
      is much safer to end the line with something other than a
      back-slash.  Simply tacking on a period will do.  If you really
      intend the next line to be a comment, the line should be started
      with its own double slash (//).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="428" id="428">428</a></td>
<td><pre>   negative subscript (Integer) in operator 'String' -- A negative
      integer was added to an array or to a pointer to an allocated
      area (allocated by malloc, operator new, etc.) This message is
      not given for pointers whose origin is unknown since a negative
      subscript is, in general, legal.

      The addition could have occurred as part of a subscript operation
      or as part of a pointer arithmetic operation.  The operator is
      denoted by String.  The value of the integer is given by Integer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="429" id="429">429</a></td>
<td><pre>   Custodial pointer 'Symbol' (Location) has not been freed or
      returned -- A pointer of auto storage class was allocated storage
      which was neither freed nor returned to the caller.  This
      represents a "memory leak".  A pointer is considered custodial if
      it uniquely points to the storage area.  It is not considered
      custodial if it has been copied.  Thus:
     
            int *p = new int[20];  // p is a custodial pointer
            int *q = p;            // p is no longer custodial
            p = new int[20];       // p again becomes custodial
            q = p + 0;             // p remains custodial

      Here p does not lose its custodial property by merely
      participating in an arithmetic operation.

      A pointer can lose its custodial property by passing the pointer
      to a function.  If the parameter of the function is typed pointer
      to const or if the function is a library function, that
      assumption is not made.  For example
     
            p = malloc(10);
            strcpy (p, "hello");

      Then p still has custody of storage allocated.

      It is possible to indicate via semantic options that a function
      will take custody of a pointer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="430" id="430">430</a></td>
<td><pre>   Character '@', taken to specify variable location, is not
      standard C/C++ -- Many compilers for embedded systems have a
      declaration syntax that specifies a location in place of an
      initial value for a variable.  For example:
     
                int x @0x2000;

      specifies that variable x is actually location 0x2000.  This
      message is a reminder that this syntax is non-standard (although
      quite common).  If you are using this syntax on purpose, suppress
      this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="431" id="431">431</a></td>
<td><pre>   Missing identifier for template parameter number Integer -- A
      template object parameter (as opposed to a type parameter) was
      not provided with an identifier.  Was this an oversight?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="432" id="432">432</a></td>
<td><pre>   Suspicious argument to malloc -- The following pattern was
      detected:

            malloc( strlen(e+1) )

      where e is some expression.  This is suspicious because it
      closely resembles the commonly used pattern:

            malloc( strlen(e)+1 )

      If you really intended to use the first pattern then an
      equivalent expression that will not raise this error is:

            malloc( strlen(e)-1 )

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="433" id="433">433</a></td>
<td><pre>   Allocated area not large enough for pointer -- An allocation was
      assigned to a pointer whose reach extends beyond the area that
      was allocated.  This would usually happen only with library
      allocation routines such as malloc and calloc.  For example:

            int *p = malloc(1);

      This message is also provided for user-declared allocation
      functions.  For example, if a user's own allocation function is
      provided with the following semantic:

            -sem(ouralloc,@P==malloc(1n))

      We would report the same message.  Please note that it is
      necessary to designate that the returned area is freshly
      allocated (ala malloc).

      This message is always given in conjunction with the more general
      Informational Message 826.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="434" id="434">434</a></td>
<td><pre>   White space ignored between back-slash and new-line -- According
      to the C and C++ standards, any back-slash followed immediately
      by a new-line results in the deletion of both characters.  For
      example:
     
        #define A  \
                34

      defines A to be 34.  If a blank or tab intervenes between the
      back-slash and the new-line then according to a strict
      interpretation of the standard you have defined A to be a
      back-slash.  But this blank is invisible to the naked eye and
      hence could lead to confusion.  Worse, some compilers silently
      ignore the white-space and the program becomes non-portable.

      You should never deliberately place a blank at the end of a line
      and any such blanks should be removed.  If you really need to
      define a macro with a terminal back-slash you can use a comment
      as in:
     
        #define A \   /* commentary */

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="435" id="435">435</a></td>
<td><pre>   integral constant 'String' has precision Integer, use +fll to
      enable long long" -- An integer constant was found that had a
      precision that was too large for a long but would fit within a
      long long.  Yet the +fll flag that enables the long long type was
      not set.

      Check the sizes that you specified for long (-sl#) and for long
      long (-sll#) and make sure they are correct.  Turn on +fll if
      your compiler supports long long. Otherwise use smaller
      constants.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="436" id="436">436</a></td>
<td><pre>   Apparent preprocessor directive in invocation of macro 'Symbol'
      -- A function like macro was invoked whose arguments extended for
      multiple lines which included preprocessor statements.  This is
      almost certainly an error brought about by a missing right
      parenthesis.

      By the rules of Standard C the preprocessing directive is
      absorbed into the macro argument but then will not subsequently
      get executed.  For this reason some compilers treat the apparent
      preprocessor directive as a directive.  This is logical but not
      portable.  It is therefore best to avoid this construct.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="437" id="437">437</a></td>
<td><pre>   Passing struct 'Symbol' to ellipsis -- A struct is being passed
      to a function at a parameter position identified by an ellipsis.
      For example:
     
          void g()
              {
              struct A { int a; } x;
              void f( int, ... );
              f( 1, x );
              ...
              }
     
      This is sufficiently unusual that it is worth pointing out on the
      likely hood that this is unintended.  The situation becomes more
      severe in the case of a Non-POD struct [10].  In this case the
      behavior is considered undefined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="438" id="438">438</a></td>
<td><pre>   Last value assigned to variable 'Symbol' not used -- A value had
      been assigned to a variable that was not subsequently used.  The
      message is issued either at a return statement or at the end of a
      block when the variable goes out of scope.  For example, consider
      the following function:
     
              void f( int n )
                  {
                  int x = 0, y = 1;
                  if( n &gt; 0 )
                      {
                      int z;
                      z = x + y;
                      if( n &gt; z ) { x = 3; return; }
                      z = 12;
                      }
                  }
     
      Here we can report that x was assigned a value that had not been
      used by the time the return statement had been encountered.  We
      also report that the most recently assigned value to z is unused
      at the point that z goes out of scope.  See message 838 in
      Section <ref,13.4 c="" informational="" messages,13.4=""> and flags -fiw
      and -fiz in Sections <ref,2.3.6 initialization-is-considered-a-write="" flag="" (-fiw)="" ,2.3.6=""> and
      <ref,2.3.7 initialization-by-zero-is-considered-a-write="" flag="" (-fiz)="" ,2.3.7="">.

      This message is suppressed if the variable's address is assigned
      to a pointer (or, equivalently, the variable is used to directly
      initialize a reference to non-const).

</ref,2.3.7></ref,2.3.6></ref,13.4></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="440" id="440">440</a></td>
<td><pre>   for clause irregularity: variable 'Symbol' tested in 2nd
      expression does not match 'Symbol' modified in 3rd -- A for
      clause has a suspicious structure.  The loop variable, as
      determined by an examination of the 3rd for clause expression,
      does not match the variable that is tested in the 2nd for clause
      expression.  For example:
     
              for( i = 0; i &lt; 10; j++ )
                  ...
     
      would draw this complaint since the 'i' of the 2nd expression
      does not match the 'j' of the third expression.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="441" id="441">441</a></td>
<td><pre>   for clause irregularity: loop variable 'Symbol' not found in 2nd
      for expression -- The loop variable is determined by an
      examination of the 3rd for clause expression.  A loop variable
      was found (and its name is given in the message) but it did not
      appear as one of the accessed symbols of the condition expression
      (the 2nd for expression).  For example:
     
              for( p = a; *p; j++ )
                  ...
     
      would draw this complaint since the 2nd expression does not
      contain the 'j' of the third expression.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="442" id="442">442</a></td>
<td><pre>   for clause irregularity: testing direction inconsistent with
      increment direction -- A for clause was encountered that appeared
      to have a parity problem.  For example:
     
              for( i = 0; i &lt; 10; i-- )
                  ...
     
      Here the test for i less than 10 seems inconsistent with the 3rd
      expression of the for clause which decreases the value of i.
      This same message would be given if i were being increased by the
      3rd expression and was being tested for being greater than some
      value in the 2nd expression.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="443" id="443">443</a></td>
<td><pre>   for clause irregularity: variable 'Symbol' initialized in 1st
      expression does not match 'Symbol' modified in 3rd -- A for
      clause has a suspicious structure.  The loop variable, as
      determined by an examination of the 3rd for clause expression,
      does not match the variable that is initialized in the 1st
      expression.  For example:
     
              for( ii = 0; i &lt; 10; i++ )
                  ...
     
      would draw this complaint since the 'ii' of the 1st expression
      does not match the 'i' of the third expression.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="444" id="444">444</a></td>
<td><pre>   for clause irregularity: pointer 'Symbol' incremented in 3rd
      expression is tested for NULL in 2nd expression -- The following
      kind of situation has been detected:
     
              for( ... ; p == NULL; p++ )
                  ...
     
      A loop variable being incremented or decremented would not
      normally be checked to see if it is NULL.  This is more likely a
      programmer error.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="445" id="445">445</a></td>
<td><pre>   reuse of for loop variable 'Symbol' at 'Location' could cause
      chaos -- A for loop nested within another for loop employed the
      same loop variable.  For example:
     
              for( i = 0; i &lt; 100; i++ )
                  {
                  ...
                  for( i = 0; i &lt; n; i++ ) { ... }
                  }
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="446" id="446">446</a></td>
<td><pre>   side effect in initializer -- An initializer containing a side
      effect can be potentially troublesome. For example, given the
      code:
     
          void f( int i )
              {
              int a[2] = {i++, i++};
              }
     
      The values of the array elements are unspecified because the
      order of evaluation is unspecified by the C standard.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="447" id="447">447</a></td>
<td><pre>   Extraneous whitespace ignored in include directive for file
      'FileName'; opening file 'FileName' -- A named file was found to
      contain either leading or trailing whitespace in the #include
      directive.  While legal, the ISO Standards allow compilers to
      define how files are specified or the header is identified,
      including the appearance of whitespace characters immediately
      after the &lt; or opening " or before the &gt; or closing ".  Since
      filenames tend not to contain leading or trailing whitespace,
      Lint ignores the (apparently) extraneous characters and processes
      the directive as though the characters were never given.  The use
      of a -efile option on either String for this message will cause
      Lint to process #include's with whitespace intact.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="448" id="448">448</a></td>
<td><pre>   Likely access of pointer pointing Integer bytes past nul
      character by operator 'String' -- Accessing past the terminating
      nul character is often an indication of a programmer error.  For
      example:
     
              char buf[20];
              strcpy( buf, "a" );
              char c = buf[4];   // legal but suspect.
     
      Although buf has 20 characters, after the strcpy, there would be
      only two that the programmer would normally be interested in.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="449" id="449">449</a></td>
<td><pre>   Pointer variable 'Symbol' previously deallocated -- A pointer
      variable (designated in the message) was freed or deleted in an
      earlier statement.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="451" id="451">451</a></td>
<td><pre>   Header file 'FileName' repeatedly included but does not have a
      standard include guard -- The file named in the message has
      already been included in the current module.  Moreover it has
      been determined that this header does not have a standard include
      guard.  A standard include guard has the form
     
              #ifndef Name
              #define Name
               ...
              #endif
     
      with nothing but comments before and after this sequence and
      nothing but comments between the #ifndef and the #define Name.

      This warning may also be accompanied by a 537 (repeated include
      header).  Message 537 is often suppressed because if you are
      working with include guards, it is not a helpful message.
      However, the message 451 should be left on in order to check the
      consistency of the include guards themselves.

      See also Elective Note 967 in Section <ref,13.5 c="" elective="" notes,13.5="">.

</ref,13.5></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="452" id="452">452</a></td>
<td><pre>   typedef Symbol 'Symbol' redeclared (TypeDiff) conflicts with
      Location", -- A typedef symbol is being declared to be a
      different type.  This can be legal, especially with multiple
      modules, but is not good programming practice.  It inteferes with
      program legibility.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="453" id="453">453</a></td>
<td><pre>   Function 'Symbol', previously designated pure, String 'Name' -- A
      semantic option designated that the named function, Symbol, is
      pure (lacking non-local side-effects; see the pure semantic in
      Section <ref,4. semantics,4.=""> ).  However, an impurity was
      detected.  Such impurities include calling a function through a
      function pointer, accessing a volatile variable, modifying a
      static variable or calling a function whose purity
      PC-lint/FlexeLint cannot verify.  String describes which of these
      reasons apply and Name shows the related variable or function, as
      appropriate.

      Despite the inconsistency reported, the function will continue to
      be regarded as pure.

</ref,4.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="454" id="454">454</a></td>
<td><pre>   A thread mutex has been locked but not unlocked -- A return point
      in a function has been reached such that a mutex lock that had
      been previously set has not been unlocked.  E.g.,
     
              //lint -sem( lock, thread_lock )
              void f( int x )
                  {
                  lock();
                  if( x &lt; 0 ) return; // Warning 454
                  ...
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="455" id="455">455</a></td>
<td><pre>   A thread mutex that had not been locked is being unlocked -- A
      call to an unlock() function was made that was not preceded by a
      balancing lock().  It is assumed that every mutex lock() function
      must be balanced by exactly one unlock() function, no more, no
      less.  For example:
     
              //lint -sem( lock, thread_lock )
              //lint -sem( unlock, thread_unlock )
              void f( bool x )
                  {
                  lock();
                  /* something */;
                  unlock();
                  /* something else */
                  unlock();   // Warning 455
                  }
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="456" id="456">456</a></td>
<td><pre>   Two execution paths are being combined with different mutex lock
      states -- It is the purpose of this message to make absolutely
      certain that every lock has a corresponding unlock in the same
      unbroken sequence of code in the same function.

      Execution paths can be combined at the end of an if statement,
      switch statement, or the begining of while, for and do
      statements, a label (target of goto), etc.  In all these cases we
      check to make sure that the mutex lock states are the same.  For
      example:
     
              //lint -sem( lock, thread_lock )
              void f( bool x )
                  {
                  if( x ) lock();
                  // Warning 456 issued here
                  ...
     
      It could be argued that if an unlock() call would appear under
      control of the very same bool x in the example above then all
      would be well.  And if this is your coding style you are free to
      turn this message off.  But errors in mutex locking have such
      horrible programming consequences as to suggest especially strong
      measures to assure code correctness.  We recommend, for example:
     
              //lint -sem( lock, thread_lock )
              //lint -sem( unlock, thread_unlock )
              void f( bool x )
                  {
                  if( x )
                      { lock(); /* something */; unlock(); }
                  else
                      { /* something */ }
                  }
     
      If the 'something' that is being executed is sufficently complex,
      then it can be made into a function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="457" id="457">457</a></td>
<td><pre>   Function 'Symbol1' of thread 'Symbol2' has an unprotected write
      access to variable 'Symbol3' which is used by function 'Symbol4'
      of thread 'Symbol5' -- A variable (Symbol3) was modified by
      function (Symbol1) of thread (Symbol2) outside of any recognized
      mutex lock.  It was also accessed by a function (Symbol4) of a
      second thread (Symbol5).  The latter access may or may not have
      been protected.  If unprotected, a second message will be issued
      with the roles of Symbol1 and Symbol4 interchanged.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="458" id="458">458</a></td>
<td><pre>   Function 'Symbol1' of thread 'Symbol2' has an unprotected read
      access to variable 'Symbol3' which is modified by function
      'Symbol4' of thread 'Symbol5' -- A variable identified in the
      message was accessed (non-modifiing) by a function (Symbol1) of
      thread (Symbol2) outside of any recognized mutex lock.  It was
      also modified by a function (Symbol4) in a second thread
      (Symbol5).  The modification may or may not have been protected.
      If unprotected, Warning 457 will also be issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="459" id="459">459</a></td>
<td><pre>   Function 'Symbol' whose address was taken has an unprotected
      access to variable 'Symbol' -- This message is activated only
      when it appears that the program has more than one thread.  See
      Section <ref,8. multi-thread="" suppport,8.=""> to determine what those
      conditions might be.

      If a function's address is taken, we presume that we are unable
      to determine statically all the locations from which the function
      may be called and so we presume that any and all threads can call
      this function and so the function needs to have protected access
      to every static variable that it might touch.

      There are several remedies to such a message.  If multiple
      threads can indeed access this function, then place a mutex lock
      in the function.  If there already is a mutex lock and we don't
      recognize it, then set the thread_protected semantic for the
      function.  If only one thread really accesses this function or if
      the access is guaranteed to be benign, then, after making sure
      this condition is commented in the code, use the same
      thread_protected semantic for the function.

</ref,8.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="460" id="460">460</a></td>
<td><pre>   Thread 'Symbol' has unprotected call to thread unsafe function
      'Symbol' which is also called by thread 'Symbol' -- The second
      symbol in the message represents a function that was designated
      as being thread_unsafe through the -sem option.  It was being
      called in an unprotected region of a thread whose root function
      is the first symbol in the message.   Another thread is also
      accessing this function and this thread is identified by the
      third parameter of the message.

      Calls to thread unsafe functions need to be protected by mutex
      locks if they are to be employed by more than one thread.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="461" id="461">461</a></td>
<td><pre>   Thread 'Symbol' has unprotected call to function 'Symbol' of
      group 'Name' while thread 'Symbol' calls function 'Symbol' of the
      same group -- This message is similar to Warning 460 in that a
      thread (identified in the message as the first Symbol) is making
      a call on a function (the second Symbol) which had been deduced
      (through options) as being thread unsafe.  Like message 460 there
      is another thread that is also doing some calling.  In this case
      the other thread is not calling the same function as the first
      but one which has been placed within the same group (identified
      by the third parameter) as the first function.  See Section
      <ref,8. multi-thread="" support,8.=""> to obtain further information on
      thread unsafe function groups and options to determine them.

</ref,8.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="462" id="462">462</a></td>
<td><pre>   Thread 'Symbol' calling function 'Symbol' is inconsistent with
      the 'String' semantic -- The first Symbol in the message
      identifies a thread.  The second Symbol identifies a function
      called directly or indirectly by the thread.  The String argument
      specifies a semantic that had been attributed to the functon.  It
      should have one of the following forms:

                thread_not
                thread_not( list )
                thread_only( list )

      If the second form is given, it means that the thread appears on
      the list.  If the 3rd form is given it means that the thread was
      not on the list.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="464" id="464">464</a></td>
<td><pre>   Buffer argument will be copied into itself -- This is issued when
      we encounter a function argument expression used in such a way
      that there will be an attempt to copy its contents onto itself.
      E.g.
     
          sprintf( s, "%s", s );
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="483" id="483">483</a></td>
<td><pre>   boolean value in switch expression -- At least one standards
      organization has expressed the perspective, if the expression of
      a switch-statement is boolean in nature, if-else should be used
      instead.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="484" id="484">484</a></td>
<td><pre>   Stringize operator followed by macro parameter followed by
      pasting operator -- Due to order of evaluation issues, the mixing
      of stringizing and pasting operators, particularly when appearing
      in the order # parameter ##, results in unspecified behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="485" id="485">485</a></td>
<td><pre>   Duplicate initialization of object element -- This message is
      given upon an inconsistent use of designated initializers (used
      for specific fields of arrays or structures).  It is possible for
      an element of such an aggregate to be initialized twice either
      through the use of two separate designators or through a
      designator and the conventional sequential initialization
      process.  In either case the end result is not specified and the
      construction is usually a sign of a logic error.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="501" id="501">501</a></td>
<td><pre>   Expected signed type -- The unary minus operator was applied to
      an unsigned type.  The resulting value is a positive unsigned
      quantity and may not be what was intended.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="502" id="502">502</a></td>
<td><pre>   Expected unsigned type -- Unary ~ being a bit operator would more
      logically be applied to unsigned quantities rather than signed
      quantities.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="503" id="503">503</a></td>
<td><pre>   Boolean argument to relational -- Normally a relational would not
      have a Boolean as argument.  An example of this is a &lt; b &lt; c
      which is technically legal but does not produce the same result
      as the mathematical expression which it resembles.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="504" id="504">504</a></td>
<td><pre>   Unusual shift operation (String) -- Either the quantity being
      shifted or the amount by which a quantity is to be shifted was
      derived in an unusual way such as with a bit-wise logical
      operator, a negation, or with an unparenthesized expression.  If
      the shift value is a compound expression that is not
      parenthesized, parenthesize it.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="505" id="505">505</a></td>
<td><pre>   Redundant left argument to comma -- The left argument to the
      comma operator had no side effects in its top-most operator and
      hence is redundant.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="506" id="506">506</a></td>
<td><pre>   Constant value Boolean -- A Boolean, i.e., a quantity found in a
      context that requires a Boolean such as an argument to &amp;&amp; or ||
      or an if( ) or while( ) clause or ! was found to be a constant
      and hence will evaluate the same way each time.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="507" id="507">507</a></td>
<td><pre>   Size incompatibility -- A cast was made to an integral quantity
      from a pointer and according to other information given or
      implied it would not fit.  For example a cast to an unsigned int
      was specified and information provided by the options indicate
      that a pointer is are larger than an int.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="508" id="508">508</a></td>
<td><pre>   extern used with definition -- A function definition was
      accompanied with an extern storage class.  extern is normally
      used with declarations rather than with definitions.  At best the
      extern is redundant.  At worst you may trip up a compiler.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="509" id="509">509</a></td>
<td><pre>   extern used with definition -- A data object was defined with a
      storage class of extern.  This is technically legal in ANSI and
      you may want to suppress this message.  However, it can easily
      trip up a compiler and so the practice is not recommended at this
      time.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="510" id="510">510</a></td>
<td><pre>   File extension 'String' reserved for future versions of this
      product -- File name extensions that are not those recognized as
      implying C++ source code or indirect files for lint or
      pre-compiled headers for lint or lint object modules or project
      files are assumed to be C source code.  If we recognize a new
      file extension in some future version of lint it can be
      beneficial to warn about the use of this file extension in any
      earlier version of lint.  One reason for this is to aid in the
      transition between versions of the product.  During this
      transition period a new file extension may be provided
      unintentionally to a former version of the product resulting in
      surprising behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="511" id="511">511</a></td>
<td><pre>   Size incompatibility -- A cast was made from an integral type to
      a pointer and the size of the quantity was too large to fit into
      the pointer.  For example if a long is cast to a pointer and if
      options indicate that a long ise larger than a pointer, this
      warning would be reported.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="512" id="512">512</a></td>
<td><pre>   Symbol 'Symbol' previously used as static (Location) -- The
      Symbol name given is a function name that was declared as static
      in some other module (the location of that declaration is
      provided).  The use of a name as static in one module and
      external in another module is legal but suspect.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="514" id="514">514</a></td>
<td><pre>   Unusual use of a Boolean -- An argument to an arithmetic operator
      (+ - / * %) or a bit-wise logical operator (| &amp; ^) was a Boolean.
      This can often happen by accident as in:

            if( flags &amp; 4 == 0 )

      where the ==, having higher precedence than &amp;, is done first (to
      the puzzlement of the programmer).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="515" id="515">515</a></td>
<td><pre>   Symbol 'Symbol' has arg. count conflict (Integer vs. Integer)
      with Location -- An inconsistency was found in the number of
      actual arguments provided in a function call and either the
      number of formal parameters in its definition or the number of
      actual arguments in some other function call.  See the +fva
      option to selectively suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="516" id="516">516</a></td>
<td><pre>   Symbol 'Symbol' has arg. type conflict (no. Integer -- TypeDiff)
      with Location -- An inconsistency was found in the type of an
      actual argument in a function call with either the type of the
      corresponding formal parameter in the function definition or the
      type of an actual argument in another call to the same function
      or with the type specified for the argument in the function's
      prototype.  The call is not made in the presence of a prototype.
      See options -ean, -eau, -eas and -eai for selective suppression
      of some kinds of type differences. If the conflict involves types
      char or short then you may want to consider using the +fxc or
      +fxs option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="517" id="517">517</a></td>
<td><pre>   defined not K&amp;R -- The defined function (not a K&amp;R construct) was
      employed and the K&amp;R preprocessor flag (+fkp) was set. Either do
      not set the flag or do not use defined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="518" id="518">518</a></td>
<td><pre>   Expected '(' -- sizeof type is not strict C.  sizeof(type) or
      sizeof expression are both permissible.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="519" id="519">519</a></td>
<td><pre>   Size incompatibility -- An attempt was made to cast a pointer to
      a pointer of unequal size.  This could occur for example in a P
      model where pointers to functions require 4 bytes whereas
      pointers to data require only 2.  This error message can be
      circumvented by first casting the pointer to an integral quantity
      (int or long) before casting to a pointer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="520" id="520">520</a></td>
<td><pre>   Highest operator or function lacks side-effects -- The first
      expression of a for clause should either be one of the privileged
      operators: assignment, increment, decrement or call to an impure
      function or one modifying its argument(s).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="521" id="521">521</a></td>
<td><pre>   Highest operator or function lacks side-effects -- The third
      expression of a for clause should either be one of the privileged
      operators: assignment, increment, decrement or call to an impure
      function or one modifying its argument(s).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="522" id="522">522</a></td>
<td><pre>   Highest operator or function lacks side-effects -- If a statement
      consists only of an expression, it should either be one of the
      privileged operators: assignment, increment, decrement or call to
      an impure function or one modifying its argument(s).  For example
      if operator * is the built-in operator, the statement *p++; draws
      this message but p++; does not.  This is because the highest
      operator is '*' which has no side effects.

      The definition of pure and impure functions and function calls
      which have side effects are given in the discussion of the pure
      semantic in section <ref,4. semantics,4.="">

</ref,4.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="524" id="524">524</a></td>
<td><pre>   Loss of precision (Context) (Type to Type) -- There is a possible
      loss of a fraction in converting from a float to an integral
      quantity.  Use of a cast will suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="525" id="525">525</a></td>
<td><pre>   Negative indentation from Location -- The current line was found
      to be negatively indented (i.e., not indented as much) from the
      indicated line.  The latter corresponds to a clause introducing a
      control structure and statements and other control clauses and
      braces within its scope are expected to have no less indentation.
      If tabs within your program are other than 8 blanks you should
      use the -t option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="526" id="526">526</a></td>
<td><pre>   'Symbol' (Location) not defined -- The named external was
      referenced but not defined and did not appear declared in any
      library header file nor did it appear in a Library Module.  This
      message is suppressed for unit checkout (-u option).  Please note
      that a declaration, even one bearing prototype information is not
      a definition.  See the glossary at the beginning of this chapter.
      If the Symbol is a library symbol, make sure that it is declared
      in a header file that you're including.  Also make sure that the
      header file is regarded by PC-lint/FlexeLint as a Library Header
      file.  Alternatively, the symbol may be declared in a Library
      Module.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="527" id="527">527</a></td>
<td><pre>   Unreachable code at token Symbol -- A portion of the program
      cannot be reached.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="528" id="528">528</a></td>
<td><pre>   Symbol 'Symbol' (Location) not referenced -- The named static
      variable or static function was not referenced in the module
      after having been declared.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="529" id="529">529</a></td>
<td><pre>   Symbol 'Symbol' (Location) not subsequently referenced -- The
      named variable was declared but not referenced in a function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="530" id="530">530</a></td>
<td><pre>   Symbol 'Symbol' (Location) not initialized -- An auto variable
      was used before it was initialized.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="531" id="531">531</a></td>
<td><pre>   Field size too large for 'Symbol' -- The size given for a bit
      field of a structure exceeds the size of an int.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="532" id="532">532</a></td>
<td><pre>   Return mode of function 'Symbol' inconsistent with Location -- A
      declaration (or a definition) of a function implies a different
      return mode than a previous statement.  (The return mode of a
      function has to do with whether the function does, or does not,
      return a value).  A return mode is determined from a declaration
      by seeing if the function returns void or, optionally, by
      observing whether an explicit type is given.  See the fdr flag
      for a further explanation of this.  See also the fvr and fvo
      flags.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="533" id="533">533</a></td>
<td><pre>   function 'Symbol' should (not) return a value (see Location) -- A
      return statement within a function (or lack of a return at the
      end of the function) implies a different return mode than a
      previous statement at Location (The return mode of a function has
      to do with whether the function does, or does not, return a
      value.)

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="534" id="534">534</a></td>
<td><pre>   Ignoring return value of function 'Symbol' (compare with
      Location) -- A function that returns a value is called just for
      side effects as, for example, in a statement by itself or the
      left-hand side of a comma operator.  Try: (void) function( ); to
      call a function and ignore its return value.  See also the fvr,
      fvo and fdr flags.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="537" id="537">537</a></td>
<td><pre>   Repeated include file 'FileName' -- The file whose inclusion
      within a module is being requested has already been included in
      this compilation.  The file is processed normally even if the
      message is given.  If it is your standard practice to repeat
      included files then simply suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="538" id="538">538</a></td>
<td><pre>   Excessive size -- The size of an array equals or exceeds 64K
      bytes.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="539" id="539">539</a></td>
<td><pre>   Did not expect positive indentation from Location -- The current
      line was found to be positively indented from a clause that did
      not control the line in question.  For example:
     
            if( n &gt; 0 )
                x = 3;
                y = 4;

      will result in this warning being issued for y = 4;.  The
      Location cited will be that of the if clause.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="540" id="540">540</a></td>
<td><pre>   Excessive size -- A string initializer required more space than
      what was allocated.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="541" id="541">541</a></td>
<td><pre>   Excessive size -- The size of a character constant specified with
      \xddd or \xhhh equalled or exceeded 2**b where b is the number of
      bits in a byte (established by the -sb option).  The default is
      -sb8.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="542" id="542">542</a></td>
<td><pre>   Excessive size for bit field -- An attempt was made to assign a
      value into a bit field that appears to be too small.  The value
      to be assigned is either another bit field larger than the
      target, or a numeric value that is simply too large.  You may
      cast the value to the generic unsigned type to suppress the
      error.

      You may get this message unexpectedly if the base of the bit
      field is an int.  For example:
     
           struct { int b : 1 } s;
           s.b = 1;        /* Warning - - requires 0 or -1 */

      The solution in this case is to use 'unsigned' rather than 'int'
      in the declaration of b.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="544" id="544">544</a></td>
<td><pre>   endif or else not followed by EOL -- The preprocessor directive
      #endif should be followed by an end-of-line.  Some compilers
      specifically allow commentary to follow the #endif.  If you are
      following that convention simply turn this error message off.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="545" id="545">545</a></td>
<td><pre>   Suspicious use of &amp; -- An attempt was made to take the address of
      an array name.  At one time such an expression was officially
      illegal (K&amp;R C [1]), was not consistently implemented, and was,
      therefore, suspect.  However, the expression is legal in ANSI C
      and designates a pointer to an array.  For example, given

           int a[10];
           int (*p) [10];

      Then a and &amp;a, as pointers, both represent the same bit pattern,
      but whereas a is a pointer to int, &amp;a is a pointer to array 10 of
      int.  Of the two only &amp;a may be assigned to p without complaint.
      If you are using the &amp; operator in this way, we recommend that
      you disable this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="546" id="546">546</a></td>
<td><pre>   Suspicious use of &amp; -- An attempt was made to take the address of
      a function name. Since names of functions by themselves are
      promoted to address, the use of the &amp; is redundant and could be
      erroneous.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="547" id="547">547</a></td>
<td><pre>   Redefinition of symbol 'Symbol' conflicts with Location -- The
      indicated symbol had previously been defined (vis #define)to some
      other value.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="548" id="548">548</a></td>
<td><pre>   else expected -- A construct of the form if(e); was found which
      was not followed by an else. This is almost certainly an unwanted
      semi-colon as it inhibits the if from having any effect.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="549" id="549">549</a></td>
<td><pre>   Suspicious cast -- A cast was made from a pointer to some
      enumerated type or from an enumerated type to a pointer.  This is
      probably an error.  Check your code and if this is not an error,
      then cast the item to an intermediate form (such as an int or a
      long) before making the final cast.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="550" id="550">550</a></td>
<td><pre>   Symbol 'Symbol' (Location) not accessed -- A variable (local to
      some function) was not accessed.  This means that the value of a
      variable was never used.  Perhaps the variable was assigned a
      value but was never used.  Note that a variable's value is not
      considered accessed by autoincrementing or autodecrementing
      unless the autoincrement/decrement appears within a larger
      expression which uses the resulting value.  The same applies to a
      construct of the form: var += expression.  If an address of a
      variable is taken, its value is assumed to be accessed. An array,
      struct or union is considered accessed if any portion thereof is
      accessed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="551" id="551">551</a></td>
<td><pre>   Symbol 'Symbol' (Location) not accessed -- A variable (declared
      static at the module level) was not accessed though the variable
      was referenced.  See the explanation under message 550 (above)
      for a description of "access".

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="552" id="552">552</a></td>
<td><pre>   Symbol 'Symbol' (Location) not accessed -- An external variable
      was not accessed though the variable was referenced.  See the
      explanation under message 550 above for a description of
      "access".

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="553" id="553">553</a></td>
<td><pre>   Undefined preprocessor variable 'Name', assumed 0 -- The
      indicated variable had not previously been defined within a
      #define statement and yet it is being used in a preprocessor
      condition of the form #if or #elif.  Conventionally all variables
      in preprocessor expressions should be pre-defined.  The value of
      the variable is assumed to be 0.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="555" id="555">555</a></td>
<td><pre>   #elif not K&amp;R -- The #elif directive was used and the K&amp;R
      preprocessor flag (+fkp) was set.  Either do not set the flag or
      do not use #elif.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="556" id="556">556</a></td>
<td><pre>   indented # -- A preprocessor directive appeared indented within a
      line and the K&amp;R preprocessor flag (+fkp) was set.  Either do not
      set the flag or do not indent the #.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="557" id="557">557</a></td>
<td><pre>   unrecognized format -- The format string supplied to printf,
      fprintf, sprintf, scanf, fscanf, or sscanf was not recognized.
      It is neither a standard format nor is it a user-defined format
      (see printf_code and scanf_code).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="558" id="558">558</a></td>
<td><pre>   Too few arguments for format (Integer missing)  -- The number of
      arguments supplied to printf, sprintf, fprintf, scanf, fscanf or
      sscanf was inconsistent with the number expected as a result of
      analyzing the format string.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="559" id="559">559</a></td>
<td><pre>   size of argument number Integer inconsistent with format -- The
      given argument (to printf, sprintf, or fprintf) was inconsistent
      with that which was anticipated as the result of analyzing the
      format string.  Argument counts begin at 1 and include file,
      string and format specifications.  For example,

            sprintf( buffer, "%f", 371 )

      will show an error in argument number 3 because constant 371 is
      not floating point.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="560" id="560">560</a></td>
<td><pre>   argument no. Integer should be a pointer -- The given argument
      (to one of the scanf or printf family of functions) should be a
      pointer.  For the scanf family, all arguments corresponding to a
      format specification should be pointers to areas that are to be
      modified (receive the results of scanning).  For the printf
      family, arguments corresponding to %s or %n also need to be
      pointers.

      Argument counts begin at 1 and include file, string and format
      specifications.  For example

            scanf( "%f", 3.5 )

      will generate the message that argument no. 2 should be a
      pointer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="561" id="561">561</a></td>
<td><pre>   (arg. no. Integer) indirect object inconsistent with format --
      The given argument (to scanf, sscanf, or fscanf) was a pointer to
      an object that was inconsistent with that which was anticipated
      as the result of analyzing the format string.  Argument counts
      begin at 1 and include file, string and format specifications.
      For example if n is declared as int then:

            scanf( "%c", &amp;n )

      will elicit this message for argument number 2.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="562" id="562">562</a></td>
<td><pre>   Ellipsis (...) assumed -- Within a function prototype a comma was
      immediately followed by a right parenthesis.  This is taken by
      some compilers to be equivalent to an ellipsis (three dots) and
      this is what is assumed by PC-lint/FlexeLint.  If your compiler
      does not accept the ellipsis but makes this assumption, then you
      should suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="563" id="563">563</a></td>
<td><pre>   Label 'Symbol' (Location) not referenced -- The Symbol at the
      cited Location appeared as a label but there was no statement
      that referenced this label.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="564" id="564">564</a></td>
<td><pre>   variable 'Symbol' depends on order of evaluation -- The named
      variable was both modified and accessed in the same expression in
      such a way that the result depends on whether the order of
      evaluation is left-to-right or right-to-left.  One such example
      is:  n + n++ since there is no guarantee that the first access to
      n occurs before the increment of n.  Other, more typical cases,
      are given in the manual.  Volatile variables are also checked for
      repeated use in an expression.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="565" id="565">565</a></td>
<td><pre>   tag 'Symbol' not previously seen, assumed file-level scope -- The
      named tag appeared in a prototype or in an inner block and was
      not previously seen in an outer (file-level) scope.  The ANSI
      standard is dubious as to how this tag could link up with any
      other tag.  For most compilers this is not an error and you can
      safely suppress the message.  On the other hand, to be strictly
      in accord with ANSI C you may place a small stub of a declaration
      earlier in the program.  For example:

            struct name;

      is sufficient to reserve a place for name in the symbol table at
      the appropriate level.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="566" id="566">566</a></td>
<td><pre>   Inconsistent or redundant format char 'Char' -- This message is
      given for format specifiers within formats for the printf/scanf
      family of functions.  The indicated character Char found in a
      format specifier was inconsistent or redundant with an earlier
      character found in the same format specifier.  For example a
      format containing "%ls" will yield this error with the character
      's' indicated.  This is because the length modifier is designed
      to be used with integral or float conversions and has no meaning
      with the string conversion.  Such characters are normally ignored
      by compilers.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="567" id="567">567</a></td>
<td><pre>   Expected a numeric field before char 'Char' -- This message is
      given for format specifiers within formats for the printf/scanf
      family of functions.  A numeric field or asterisk was expected at
      a particular point in the scanning of the format.  For example:
      %-d requests left justification of a decimal integer within a
      format field.  But since no field width is given, the request is
      meaningless.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="568" id="568">568</a></td>
<td><pre>   nonnegative quantity is never less than zero. -- Comparisons of
      the form:

           u &gt;= 0  0 &lt;= u
           u &lt;  0  0 &gt;  u

      are suspicious if u is an unsigned quantity or a quantity judged
      to be never less then 0.  See also message 775.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="569" id="569">569</a></td>
<td><pre>   Loss of information (Context) (Integer bits to Integer bits) --
      An assignment (or implied assignment, see Context) was made from
      a constant to an integral variable that is not large enough to
      hold the constant.  Examples include placing a hex constant whose
      bit requirement is such as to require an unsigned int into a
      variable typed as int.  The number of bits given does not count
      the sign bit.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="570" id="570">570</a></td>
<td><pre>   Loss of sign (Context) (Type to Type) -- An assignment (or
      implied assignment, see Context) is being made from a negative
      constant into an unsigned quantity.  Casting the constant to
      unsigned will remove the diagnostic but is this what you want.
      If you are assigning all ones to an unsigned, remember that ~0
      represents all ones and is more portable than -1.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="571" id="571">571</a></td>
<td><pre>   Suspicious Cast -- Usually this warning is issued for casts of
      the form:

            (unsigned) ch

      where ch is declared as char and char is signed.  Although the
      cast may appear to prevent sign extension of ch, it does not.
      Following the normal promotion rules of C, ch is first converted
      to int which extends the sign and only then is the quantity cast
      to unsigned.  To suppress sign extension you may use:

            (unsigned char) ch

      Otherwise, if sign extension is what you want and you just want
      to suppress the warning in this instance you may use:

            (unsigned) (int) ch

      Although these examples have been given in terms of casting a
      char they will also be given whenever this cast is made upon a
      signed quantity whose size is less than the casted type.
      Examples include signed bit fields (a possibility in the new
      standard), expressions involving char, and expressions involving
      short when this type is smaller than int or a direct cast of an
      int to an unsigned long (if int's is smaller than long).  This
      message is not issued for constants or for expressions involving
      bit operations.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="572" id="572">572</a></td>
<td><pre>   Excessive shift value (precision Integer shifted right by
      Integer) -- A quantity is being shifted to the right whose
      precision is equal to or smaller than the shifted value.  For
      example,

            ch &gt;&gt; 10

      will elicit this message if ch is typed char and where char is
      less than 10 bits wide (the usual case).  To suppress the message
      you may cast the shifted quantity to a type whose length is at
      least the length of the shift value.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="573" id="573">573</a></td>
<td><pre>   Signed-unsigned mix with divide -- one of the operands to / or %
      was signed and the other unsigned; moreover the signed quantity
      could be negative.  For example:

            u / n

      where u is unsigned and n is signed will elicit this message
      whereas:

            u / 4

      will not, even though 4 is nominally an int.  It is not a good
      idea to mix unsigned quantities with signed quantities in any
      case (a 737 will also be issued) but, with division, a negative
      value can create havoc. For example, the innocent looking:

            n = n / u

      will, if n is -2 and u is 2, not assign -1 to n but will assign
      some very large value.

      To resolve this problem, either cast the integer to unsigned if
      you know it can never be less than zero or cast the unsigned to
      an integer if you know it can never exceed the maximum integer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="574" id="574">574</a></td>
<td><pre>   Signed-unsigned mix with relational -- The four relational
      operators are:
            &gt;   &gt;=   &lt;   &lt;=

      One of the operands to a relational operator was signed and the
      other unsigned; also, the signed quantity could be negative.  For
      example:

            if( u &gt; n ) ...

      where u is unsigned and n is signed will elicit this message
      whereas:

            if( u &gt; 12 ) ...

      will not (even though 12 is officially an int it is obvious that
      it is not negative).  It is not a good idea to mix unsigned
      quantities with signed quantities in any case (a 737 will also be
      issued) but, with the four relationals, a negative value can
      produce obscure results. For example, if the conditional:

            if( n &lt; 0 ) ...

      is true then the similar appearing:

            u = 0;
            if( n &lt; u ) ...

      is false because the promotion to unsigned makes n very large.

      To resolve this problem, either cast the integer to unsigned if
      you know it can never be less than zero or cast the unsigned to
      an int if you know it can never exceed the maximum int.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="575" id="575">575</a></td>
<td><pre>   enumeration constant exceeds range for integers -- For many
      compilers the value of an enumeration constant is limited to
      those values that can fit within a signed or unsigned int.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="577" id="577">577</a></td>
<td><pre>   Mixed memory model (option 'String') -- The indicated option
      requested a change to the memory model after part or all of
      another module was processed.  The memory model option should be
      specified before any module is processed.  The most common cause
      of this error is specifying the memory model after having
      specified the standard library.  This would be a natural error to
      make if the standard library file were specified via a LINT
      environment variable.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="578" id="578">578</a></td>
<td><pre>   Declaration of symbol 'Symbol' hides symbol 'Symbol' (Location)
      -- A local symbol has the identical name as a global symbol ( or
      possibly another local symbol).  This could be dangerous.  Was
      this deliberate?  It is usually best to rename the local symbol.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="579" id="579">579</a></td>
<td><pre>   parameter preceding ellipsis has invalid type -- When an ellipsis
      is used, the type preceding the ellipsis should not be a type
      that would undergo a default promotion such as char, short or
      float.  The reason is that many compilers' variable argument
      schemes (using stdarg.h) will break down.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="580" id="580">580</a></td>
<td><pre>   Redeclaration of function 'Symbol' (hiding Location) causes loss
      of prototype -- A declaration of a function within a block hides
      a declaration in an outer scope in such a way that the inner
      declaration has no prototype and the outer declaration does.  A
      common misconception is that the resulting declaration is a
      composite of both declarations but this is only the case when the
      declarations are in the same scope not within nested scopes.  If
      you don't care about prototypes you may suppress this message.
      You will still receive other type-difference warnings.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="581" id="581">581</a></td>
<td><pre>   Option 'String' is obsolete and should no longer be used -- This
      message is issued whenever we encounter an option that appears to
      do more harm than good.  'String' is the option in question.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="582" id="582">582</a></td>
<td><pre>   esym (or emacro) name 'String' should not contain '(' -- The name
      provided to esym should not contain a (.  For example, to
      suppress message 534 when calling f(int) use the option
      -esym(534,f) even if f is overloaded.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="583" id="583">583</a></td>
<td><pre>   Comparing type 'Type' with EOF -- The message is issued when some
      form of character is compared against the EOF macro.  EOF is
      normally defined to be -1.  For example:
     
              while( (ch = getchar()) != EOF ) ...
     
      If ch is defined to be an int all is well.  If however it is
      defined to be some form of char, then trouble might ensue.  If ch
      is an unsigned char then it can never equal EOF.  If ch is a
      signed char then you could get a premature termination because
      some data character happened to be all ones.

      Note that getchar returns an int.  The reason it returns an int
      and not a char is because it must be capable of returning 257
      different values (256 different characters plus EOF, assuming an
      8-bit character).  Once this value is assigned to a char only 256
      values are then possible -- a clear loss of information.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="584" id="584">584</a></td>
<td><pre>   Trigraph sequence (??Char) detected -- This message is issued
      whenever a trigraph sequence is detected and the trigraph
      processing has been turned off (with a -ftg).  If this is not
      within a string (or character) constant then the trigraph
      sequence is ignored.  This is useful if your compiler does not
      process trigraph sequences and you want linting to mirror
      compilation.  Outside of a string we issue the Warning but we do
      translate the sequence since it cannot make syntactic sense in
      its raw state.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="585" id="585">585</a></td>
<td><pre>   The sequence (??Char) is not a valid Trigraph sequence -- This
      warning is issued whenever a pair of '?' characters is seen
      within a string (or character) constant but that pair is not
      followed by a character which would make the triple a valid
      Trigraph sequence.  Did the programmer intend this to be a
      Trigraph sequence and merely err?  Even if no Trigraph were
      intended, it can easily be mistaken by the reader of the code to
      be a Trigraph.  Moreover, what assurances do we have that in the
      future the invalid Trigraph might not become a valid Trigraph and
      change the meaning of the string? To protect yourself from such
      an event you may place a backslash between the '?' characters.
      Alternatively you may use concatenation of string constants.  For
      example:
     
              pattern = "(???) ???-????";         // warning 585
              pattern = "(?\?\?) ?\?\?-?\?\?\?";  // no warning
              #define Q "?"
              pattern = "(" Q Q Q ") " Q Q Q "-" Q Q Q Q  // no warning
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="586" id="586">586</a></td>
<td><pre>   String 'Name' is deprecated. String -- The Name has been
      deprecated by some use of the deprecate option.  See Section
      <ref,2.5.7 -deprecate,2.5.7="">.  The first String is one of the
      allowed categories of deprecation.  The trailing String is part
      of the deprecate option and should explain why the facility has
      been deprecated.

</ref,2.5.7></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="587" id="587">587</a></td>
<td><pre>   Predicate 'String' can be pre-determined and always evaluates to
      String -- The predicate, identified by the first String, (one of
      greater than, greater than or equal, less than, less than or
      equal, equal, or not equal), cannot possibly be other than what
      is indicated by the second String parameter.  For example:
     
              unsigned u; ...
              if( (u &amp; 0x10) == 0x11 ) ...
     
      would be greeted with the message that '==' always evaluates to
      'False'.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="588" id="588">588</a></td>
<td><pre>   Predicate 'String' will always evaluate to String unless an
      overflow occurs -- The predicate, identified by the first String,
      cannot possibly be other than what is indicated by the second
      String parameter unless an overflow occurred.  For example:
     
              unsigned u; ...
              if( (u + 2) != 1 ) ...
     
      would be greeted with the message that '!=' always evaluates to
      'True'.  See also Message 587.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="589" id="589">589</a></td>
<td><pre>   Predicate 'String' will always evaluate to String assuming
      standard division semantics -- The predicate, identified by the
      first String parameter, cannot possibly be other than what is
      indicated by the second String parameter assuming standard signed
      integer division semantics.  For example:
     
              int n; ...
              if( n % 2 == 2 ) ...
     
      would be greeted with the message that '==' always evaluates to
      'False'.

      By standard integer division semantics we mean truncation toward
      zero so that, for example, -1/4 has quotient 0 and remainder -1
      and not quotient -1, remainder 3.  Although the current C
      standard [4] has endorsed this, the current C++ standard [10]
      regards integer division involving negative numbers to be
      'implementation defined'.

      See also Message 587.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="590" id="590">590</a></td>
<td><pre>   Predicate 'String' will always evaluate to String assuming
      standard shift semantics -- The predicate, identified by the
      first String parameter, cannot possibly be other than what is
      indicated by the second String parameter assuming standard signed
      integer shift semantics.  For example:
     
              int n; ...
              if( (5 &lt;&lt; n) &lt; 0 ) ...
     
      would be greeted with the message that the less-than always
      evaluates to 'False'.  It is true that if you shift 5 left by 29
      bits (or 31 bits) you will have in many cases (probably most
      cases) a negative number but this is not guaranteed.  According
      to the C Standard [4], shifting a positive signed integer (5 in
      this case) left by a number of places (n in this case) is only
      valid if the type can accomodate 5*(2**n).  This is equivalent to
      not shifting a one into or through the sign bit.

      As another example:
     
              int n; ...
              if( (n &gt;&gt; 5) &gt;= 0 ) ...
     
      would always be regarded as true.  This is because shifting a
      negative number to the right yields results that are
      implementation defined.

      See also Message 587.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="591" id="591">591</a></td>
<td><pre>   Variable 'Symbol' depends on the order of evaluation; it is
      used/modified through function 'Symbol' via calls: String" -- The
      indicated variable (given by the first Symbol) was involved in an
      expression that contained a call of a function (given by the
      second Symbol) that would use or modify the variable.  Further,
      the order of evaluation of the two is not determinable.  For
      example:
     
              extern int n;
              void f() { n++; }
              int g() { f(); return 1; }
              int h() { return n + g(); }    // Warning 591
     
      The above code, on the second pass, will elicit the following
      warning:
     
              Warning 591: Variable 'n' depends on the order of evaluation;
              it is modified through function 'g(void)' via calls: g() =&gt; f()
     
      If the function g() is called and then n is added, you will
      obtain a different result than if n were first evaluated and then
      the call made.

      The programmer should generally rewrite these expressions so that
      the compiler is constrained to use the intended order.  For
      example if the programmer wanted to use the n prior to the call
      on g() it can alter h() to the following:
     
              int h()
                  { int k = n; return k + g(); }
     
      This analysis requires two passes; the first pass builds the
      necessary call trees.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="592" id="592">592</a></td>
<td><pre>   Non-literal format specifier used without arguments -- A
      printf/scanf style function received a non-literal format
      specifier without trailing arguments.  For example:
     
              char msg[100];
              ...
              printf( msg );
     
      This can easily be rewritten to the relatively safe:
     
              char msg[100];
              ...
              printf( "%s", msg );
     
      The danger lies in the fact that msg can contain hidden format
      codes.  If msg is read from user input, then in the first
      example, a naive user could cause a glitch or a crash and a
      malicious user might exploit this to undermine system security.
      Since the unsafe form can easily be transformed into the safe
      form the latter should always be used.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="593" id="593">593</a></td>
<td><pre>   Custodial pointer 'Symbol' (Location) possibly not freed or
      returned -- This is the 'possible' version of message 429.  A
      pointer of auto storage class was allocated storage and not all
      paths leading to a return statement or to the end of the function
      contained either a free or a return of the pointer.  Hence there
      is a potential memory leak.  For example:
     
      void f( int n )
          {
          int *p = new int;
          if( n ) delete p;
          }                   // message 593
     
      In this example an allocation is made and, if n is 0, no delete
      will have been made.

      Please see message 429 for an explaination of "custodial" and
      ways of regulating when pointer variables retain custody of
      allocations.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="598" id="598">598</a></td>
<td><pre>   Excessive shift value (precision Integer shifted left by Integer)
      -- A quantity is being shifted to the left by a value greater
      than or equal to the precision of that quantity or by a negative
      value. For example,

        i &lt;&lt; 32

      will elicit this message if i is typed int and where int is 32
      bits wide or less (the usual case). Such shift results in
      undefined behavior. To suppress the message you may cast the
      shifted quantity to a type whose length is at least the length of
      the shift value.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="601" id="601">601</a></td>
<td><pre>   Expected a type for symbol Symbol, int assumed -- A declaration
      did not have an explicit type.  int was assumed.  Was this a
      mistake?  This could easily happen if an intended comma was
      replaced by a semicolon.  For example, if instead of typing:
     
            double       radius,
                         diameter;
     
      the programmer had typed:
     
            double       radius;
                         diameter;
     
      this message would be raised.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="602" id="602">602</a></td>
<td><pre>   Comment within comment -- The sequence /* was found within a
      comment.  Was this deliberate? Or was a comment end inadvertently
      omitted?  If you want PC-lint/FlexeLint to recognize nested
      comments you should set the Nested Comment flag using the +fnc
      option.  Then this warning will not be issued.  If it is your
      practice to use the sequence:
     
                /*
                /*            */

      then use -e602.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="603" id="603">603</a></td>
<td><pre>   Symbol 'Symbol' (Location) not initialized -- The address of the
      named symbol is being passed to a function where the
      corresponding parameter is declared as pointer to const.  This
      implies that the function will not modify the object.  If this is
      the case then the original object should have been initialized
      sometime earlier.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="604" id="604">604</a></td>
<td><pre>   Returning address of auto variable 'Symbol' -- The address of the
      named symbol is being passed back by a function.  Since the
      object is an auto and since the duration of an auto is not
      guaranteed past the return, this is most likely an error.  You
      may want to copy the value into a global variable and pass back
      the address of the global or you might consider having the caller
      pass an address of one of its own variables to the callee.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="605" id="605">605</a></td>
<td><pre>   Increase in pointer capability (Context) -- This warning is
      typically caused by assigning a (pointer to const) to an ordinary
      pointer.  For example:
     
            int *p;
            const int *q;
            p = q;      /* 605 */
     
      The message will be inhibited if a cast is used as in:

            p = (int *) q;

      An increase in capability is indicated because the const pointed
      to by q can now be modified through p.  This message can be given
      for the volatile qualifier as well as the const qualifier and may
      be given for arbitrary pointer depths (pointers to pointers,
      pointers to arrays, etc.).

      If the number of pointer levels exceeds one, things get murky in
      a hurry.  For example:
     
            const char ** ppc;
            char ** pp;
            pp = ppc;        /* 605 - clearly not safe */
            ppc = pp;        /* 605 - looks safe but it's not */
     
      It was not realized by the C community until very recently that
      assigning pp to ppc was dangerous.  The problem is that after the
      above assignment, a pointer to a const char can be assigned
      indirectly through ppc and accessed through pp which can then
      modify the const char.

      The message speaks of an "increase in capability" in assigning to
      ppc, which seems counter intuitive because the indirect pointer
      has less capability.  However, assigning the pointer does not
      destroy the old one and the combination of the two pointers
      represents a net increase in capability.

      The message may also be given for function pointer assignments
      when the prototype of one function contains a pointer of higher
      capability than a corresponding pointer in another prototype.
      There is a curious inversion here whereby a prototype of lower
      capability translates into a function of greater trust and hence
      greater capability (a Trojan Horse).  For example, let

            void warrior( char * );

      be a function that destroys its argument.  Consider the function:

            void Troy( void (*horse)(const char *) );

      Troy( ) will call horse( ) with an argument that it considers
      precious believing the horse( ) will do no harm.  Before
      compilers knew better and believing that adding in a const to the
      destination never hurt anything, earlier compilers allowed the
      Greeks to pass warrior( ) to Troy and the rest, as they say, is
      history.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="606" id="606">606</a></td>
<td><pre>   Non-ANSI escape sequence: '\String' -- An escape sequence
      occurred, within a character or string literal, that was not on
      the approved list which is:

           \'  \"  \?  \\  \a  \b  \f  \n  \r  \t  \v

           \octal-digits    \xhex-digits

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="607" id="607">607</a></td>
<td><pre>   Parameter 'Symbol' of macro found within string -- The indicated
      name appeared within a string or character literal within a macro
      and happens to be the same as the name of a formal parameter of
      the macro as in:

            #define mac(n) printf( "n = %d,", n );

      Is this a coincidence?  The ANSI standard indicates that the name
      will not be replaced but since many C compilers do replace such
      names the construction is suspect.  Examine the macro definition
      and if you do not want substitution, change the name of the
      parameter. If you do want substitution, set the +fps flag
      (Parameter within String) and suppress the message with -e607.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="608" id="608">608</a></td>
<td><pre>   Assigning to an array parameter -- An assignment is being made to
      a parameter that is typed array.  For the purpose of the
      assignment, the parameter is regarded as a pointer.  Normally
      such parameters are typed as pointers rather than arrays.
      However if this is your coding style you should suppress this
      message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="609" id="609">609</a></td>
<td><pre>   Suspicious pointer conversion -- An assignment is being made
      between two pointers which differ in size (one is far and the
      other is near) but which are otherwise compatible.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="610" id="610">610</a></td>
<td><pre>   Suspicious pointer combination -- Pointers of different size (one
      is far and the other is near) are being compared, subtracted, or
      paired (in a conditional expression).  This is suspicious because
      normally pointers entering into such operations are the same
      size.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="611" id="611">611</a></td>
<td><pre>   Suspicious cast -- Either a pointer to a function is being cast
      to a pointer to an object or vice versa.  This is regarded as
      questionable by the ANSI standard.  If this is not a user error,
      suppress this warning.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="612" id="612">612</a></td>
<td><pre>   Expected a declarator -- A declaration contained just a storage
      class and a type.  This is almost certainly an error since the
      only time a type without a declarator makes sense is in the case
      of a struct, union or enum but in that case you wouldn't use a
      storage class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="613" id="613">613</a></td>
<td><pre>   Possible use of null pointer 'Symbol' in [left/right] argument to
      operator 'String' Reference -- From information gleaned from
      earlier statements, it is possible that a null pointer (a pointer
      whose value is 0) can be used in a context where null pointers
      are inappropriate.  Such contexts include:  Unary *, pointer
      increment (++) or decrement(--), addition of pointer to numeric,
      and subtraction of two pointers.  In the case of binary
      operators, one of the words 'left' or 'right' is used to
      designate which operand is null.  Symbol identifies the pointer
      variable that may be NULL.  See also messages 413 and 794.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="614" id="614">614</a></td>
<td><pre>   auto aggregate initializer not constant -- An initializer for an
      auto aggregate normally consists of a collection of
      constant-valued expressions.  Some compilers may, however, allow
      variables in this context in which case you may suppress this
      message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="615" id="615">615</a></td>
<td><pre>   auto aggregate initializer has side effects -- This warning is
      similar to 614.  Auto aggregates (arrays, structures and union)
      are normally initialized by a collection of constant-valued
      expressions without side-effects.  A compiler could support
      side-effects in which case you might want to suppress this
      message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="616" id="616">616</a></td>
<td><pre>   control flows into case/default -- It is possible for flow of
      control to fall into a case statement or a default statement from
      above.  Was this deliberate or did the programmer forget to
      insert a break statement?  If this was deliberate then place a
      comment immediately before the statement that was flagged as in:

            case 'a':  a = 0;
               /* fall through */
            case 'b':  a++;

      Note that the message will not be given for a case that merely
      follows another case without an intervening statement.  Also,
      there must actually be a possibility for flow to occur from
      above.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="617" id="617">617</a></td>
<td><pre>   String is both a module and an include file -- The named file is
      being used as both an include file and as a module.  Was this a
      mistake?  Unlike Error 306 (repeated module) this is just a
      warning and processing of the file is attempted.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="618" id="618">618</a></td>
<td><pre>   Storage class specified after a type -- A storage class specifier
      (static, extern, typedef, register or auto) was found after a
      type was specified.  This is legal but deprecated.  Either place
      the storage class specifier before the type or suppress this
      message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="619" id="619">619</a></td>
<td><pre>   Loss of precision (Context) (Pointer to Pointer) -- A far pointer
      is being assigned to a near pointer either in an assignment
      statement or an implied assignment such as an initializer, a
      return statement, or passing an argument in the presence of a
      prototype (Context indicates which).  Such assignments are a
      frequent source of error when the actual segment is not equal to
      the default data segment.  If you are sure that the segment of
      the far pointer equals the default data segment you should use a
      cast to suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="620" id="620">620</a></td>
<td><pre>   Suspicious constant (L or one?) -- A constant ended in a
      lower-case letter 'l'.  Was this intended to be a one?  The two
      characters look very similar.  To avoid misinterpretations, use
      the upper-case letter 'L'.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="621" id="621">621</a></td>
<td><pre>   Identifier clash (Symbol 'Name' with Symbol 'Name' at String) --
      The two symbols appeared in the same name space but are identical
      to within the first count characters set by option
      -idlen(count,option).  See -idlen.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="622" id="622">622</a></td>
<td><pre>   Size of argument no. Integer inconsistent with format -- The
      argument to scanf, fscanf or sscanf, where position is given by
      Integer, was a pointer whose size did not match the format.  For
      example,

            int far *p;
            scanf( "%d", p );

      will draw this warning (in the default memory model).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="623" id="623">623</a></td>
<td><pre>   redefining the storage class of symbol 'Symbol' (TypeDiff)
      conflicts with Location -- An inter-module symbol was a typedef
      symbol in one module and an ordinary symbol in another module.
      This is legal but potentially confusing.  Is this what the
      programmer intended?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="624" id="624">624</a></td>
<td><pre>   typedef 'Symbol' redeclared (TypeDiff) (Location) -- A symbol was
      declared in a typedef differently in two different modules.  This
      is technically legal but is not a wise programming practice.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="625" id="625">625</a></td>
<td><pre>   auto symbol 'Symbol' has unusual type modifier -- Some type
      modifiers such as far, near, fortran are inappropriate for auto
      variables.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="626" id="626">626</a></td>
<td><pre>   argument no. Integer inconsistent with format -- The argument to
      a printf (or fprintf or sprintf) was inconsistent with the
      format.  Although the size of the quantity was appropriate the
      type was not.  You might consider casting the quantity to the
      correct type.  You could also suppress this message, as more
      flagrant violations are picked up with warning 559.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="627" id="627">627</a></td>
<td><pre>   (arg. no. Integer) indirect object inconsistent with format --
      The type of an argument to scanf (or fscanf or sscanf) was
      inappropriate to the format.  However, the argument was a pointer
      and it pointed to a quantity of the expected size.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="628" id="628">628</a></td>
<td><pre>   no argument information provided for function 'Symbol' (Location)
      -- The named function was called but there was no argument
      information supplied.  Argument information can come from a
      prototype or from a function definition.  This usually happens
      when an old-style function declaration indicates that the
      function is in a library but no prototype is given for the
      function nor is any argument information provided in a standard
      library file.  This message is suppressed if you are producing a
      lint object module because presumably the object module will be
      compared with a library file at some later time.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="629" id="629">629</a></td>
<td><pre>   static class for function 'Symbol' is non standard -- A static
      class was found for a function declaration within a function.
      The static class is only permitted for functions in declarations
      that have file scope (i.e., outside any function).  Either move
      the declaration outside the function or change static to extern;
      if the second choice is made, make sure that a static declaration
      at file scope also exists before the extern declaration.  Though
      technically the construct is not portable, many compilers do
      tolerate it.  If you suppress the message, PC-lint/FlexeLint will
      treat it as a proper function declaration.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="630" id="630">630</a></td>
<td><pre>   ambiguous reference to symbol 'Name' -- If the +fab flag is set,
      then if two structures containing the same member name (not
      necessarily different kinds of structures) are embedded in the
      same structure and a reference to this member name omits one of
      the intervening (disambiguating) names, this warning is emitted.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="631" id="631">631</a></td>
<td><pre>   tag 'Symbol' defined differently at Location -- The struct, union
      or enum tag Symbol was defined differently in different scopes.
      This is not necessarily an error since C permits the
      redefinition, but it can be a source of subtle error.  It is not
      generally a programming practice to be recommended.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="632" id="632">632</a></td>
<td><pre>   Assignment to strong type 'Name' in context: Context -- An
      assignment (or implied assignment, Context indicates which)
      violates a Strong type check as requested by a -strong(A...
      option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="633" id="633">633</a></td>
<td><pre>   Assignment from a strong type 'Name' in context: Context -- An
      assignment (or implied assignment, Context indicates which)
      violates a Strong type check as requested by a -strong(X...
      option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="634" id="634">634</a></td>
<td><pre>   Strong type mismatch (type 'Symbol') in equality or conditional
      -- An equality operation (== or !=) or a conditional operation (?
      :) violates a Strong type check as requested by a -strong(J...
      option.  This message would have been suppressed using flags
      "Je".

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="635" id="635">635</a></td>
<td><pre>   resetting strong parent of type 'Symbol', old parent == type
      'Symbol' -- The strong parent of the given Symbol is being reset.
      This is being done with a -parent option or by a typedef.  Note
      that this may not necessarily be an error; you are being alerted
      to the fact that the old link is being erased.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="636" id="636">636</a></td>
<td><pre>   ptr to strong type 'Name' versus another type -- Pointers are
      being compared and there is a strong type clash below the first
      level.  For example,

            /*lint -strong(J,INT) */
            typedef int INT;
            INT *p;  int *q;

            if( p == q )    /* Warning 636 */

      will elicit this warning.  This message would have been
      suppressed using flags "Je" or "Jr" or both.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="637" id="637">637</a></td>
<td><pre>   Expected index type 'Symbol' for strong type 'Symbol' -- This is
      the message you receive when an inconsistency with the -index
      option is recognized.  A subscript is not the stipulated type
      (the first type mentioned in the message) nor equivalent to it
      within the hierarchy of types.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="638" id="638">638</a></td>
<td><pre>   Strong type mismatch for type 'Name' in relational -- A
      relational operation ( &gt;=  &lt;=  &gt;  &lt; ) violates a Strong type
      check as requested by a -strong(J... option.  This message would
      have been suppressed using flags "Jr".

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="639" id="639">639</a></td>
<td><pre>   Strong type mismatch for type 'Name' in binary operation -- A
      binary operation other than an equality or a relational operation
      violates a Strong type check as requested by a -strong(J...
      option.  This message would have been suppressed using flags
      "Jo".

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="640" id="640">640</a></td>
<td><pre>   Expected strong type 'Name' in Boolean context -- A Boolean
      context expected a type specified by a -strong(B... option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="641" id="641">641</a></td>
<td><pre>   Converting enum to int -- An enumeration type was used in a
      context that required a computation such as an argument to an
      arithmetic operator or was compared with an integral argument.
      This warning will be suppressed if you use the integer model of
      enumeration (+fie) but you will lose some valuable type-checking
      in doing so.  An intermediate policy is to simply turn off this
      warning.  Assignment of int to enum will still be caught.

      This warning is not issued for a tagless enum without variables.
      For example

            enum {false,true};

      This cannot be used as a separate type.  PC-lint/FlexeLint
      recognizes this and treats false and true as arithmetic
      constants.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="642" id="642">642</a></td>
<td><pre>   Format char 'Char' not supported by wsprintf -- This means that
      you are using an option of the form: -printf(w...  and you are
      using a format character not supported by the Microsoft Windows
      function wsprintf.  If you are not really using wsprintf but are
      using the w flag to get far pointers you should turn this message
      off.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="643" id="643">643</a></td>
<td><pre>   Loss of precision in pointer cast -- A far pointer was cast to a
      near pointer.  Such casts have had disastrous consequences for
      Windows programmers.  If you really need to make such a cast, you
      can do it in stages.  If you cast to a long first (i.e., some
      integral type that can hold the pointer) and then into a shorter
      value, we don't complain.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="644" id="644">644</a></td>
<td><pre>   Variable 'Symbol' (Location) may not have been initialized -- An
      auto variable was not necessarily assigned a value before use.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="645" id="645">645</a></td>
<td><pre>   Symbol 'Symbol' (Location) may not have been initialized -- An
      auto variable was conditionally assigned a value before being
      passed to a function expecting a pointer to a const object.  See
      Warning 603 for an explanation of the dangers of such a
      construct.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="646" id="646">646</a></td>
<td><pre>   case/default within Kind loop; may have been misplaced -- A case
      or default statement was found within a for, do, or while loop.
      Was this intentional?  At the very least, this reflects poor
      programming style.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="647" id="647">647</a></td>
<td><pre>   Suspicious truncation -- This message is issued when it appears
      that there may have been an unintended loss of information during
      an operation involving int or unsigned int the result of which is
      later converted to long.  It is issued only for systems in which
      int is smaller than long.  For example:

            (long) (n &lt;&lt; 8)

      might elicit this message if n is unsigned int, whereas

            (long) n &lt;&lt; 8

      would not.  In the first case, the shift is done at int precision
      and the high order 8 bits are lost even though there is a
      subsequent conversion to a type that might hold all the bits.  In
      the second case, the shifted bits are retained.

      The operations that are scrutinized and reported upon by this
      message are:  shift left, multiplication, and bit-wise
      complementation.  Addition and subtraction are covered by
      Informational message 776.

      The conversion to long may be done explicitly with a cast as
      shown or implicitly via assignment, return, argument passing or
      initialization.

      The message can be suppressed by casting.  You may cast one of
      the operands so that the operation is done in full precision as
      is given by the second example above.  Alternatively, if you
      decide there is really no problem here (for now or in the
      future), you may cast the result of the operation to some form of
      int.  For example, you might write:

          (long) (unsigned) (n &lt;&lt; 8)

      In this way PC-lint/FlexeLint will know you are aware of and
      approve of the truncation.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="648" id="648">648</a></td>
<td><pre>   Overflow in computing constant for operation: String --
      Arithmetic overflow was detected while computing a constant
      expression.  For example, if int is 16 bits then 200 * 200 will
      result in an overflow. String gives the operation that caused the
      overflow and may be one of: addition, unsigned addition,
      multiplication, unsigned multiplication, negation, shift left,
      unsigned shift left, subtraction, or unsigned sub.

      To suppress this message for particular constant operations you
      may have to supply explicit truncation.  For example, if you want
      to obtain the low order 8 bits of the integer 20000 into the high
      byte of a 16-bit int, shifting left would cause this warning.
      However, truncating first and then shifting would be OK.  The
      following code illustrates this where int is 16 bits.
     
           20000u &lt;&lt; 8;                  /* 648 */
           (0xFF &amp; 20000u) &lt;&lt; 8;         /* OK  */
     
      If you truncate with a cast you may make a signed expression out
      of an unsigned.  For example, the following receives a warning
      (for 16 bit int).

           (unsigned char) OxFFFu &lt;&lt; 8       /* 648 */

      because the unsigned char is promoted to int before shifting.
      The resulting quantity is actually negative.  You would need to
      revive the unsigned nature of the expression with

           (unsigned) (unsigned char) OxFFF &lt;&lt; 8     /* OK */

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="649" id="649">649</a></td>
<td><pre>   Sign fill during constant shift -- During the evaluation of a
      constant expression a negative integer was shifted right causing
      sign fill of vacated positions.  If this is what is intended,
      suppress this error, but be aware that sign fill is
      implementation-dependent.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="650" id="650">650</a></td>
<td><pre>   Constant out of range for operator String -- In a comparison
      operator or equality test (or implied equality test as for a case
      statement), a constant operand is not in the range specified by
      the other operand.  For example, if 300 is compared against a
      char variable, this warning will be issued.  Moreover, if char is
      signed (and 8 bits) you will get this message if you compare
      against an integer greater than 127.  The problem can be fixed
      with a cast.  For example:

           if( ch == 0xFF ) ...
           if( (unsigned char) ch == 0xFF ) ...

      If char is signed (+fcu has not been set) the first receives a
      warning and can never succeed.  The second suppresses the warning
      and corrects the bug.

      PC-lint/FlexeLint will take into account the limited precision of
      some operands such as bit-fields and enumerated types.  Also,
      PC-lint/FlexeLint will take advantage of some computations that
      limit the precision of an operand.  For example,

           if( (n &amp; 0xFF) &gt;&gt; 4 == 16 ) ...

      will receive this warning because the left-hand side is limited
      to 4 bits of precision.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="651" id="651">651</a></td>
<td><pre>   Potentially confusing initializer -- An initializer for a complex
      aggregate is being processed that contains some subaggregates
      that are bracketed and some that are not.  ANSI recommends either
      "minimally bracketed" initializers in which there are no interior
      braces or "fully bracketed" initializers in which all interior
      aggregates are bracketed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="652" id="652">652</a></td>
<td><pre>   #define of symbol 'Symbol' declared previously at Location -- A
      macro is being defined for a symbol that had previously been
      declared.  For example:

            int n;
            #define n N

      will draw this complaint.  Prior symbols checked are local and
      global variables, functions and typedef symbols, and struct,
      union and enum tags.  Not checked are struct and union member.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="653" id="653">653</a></td>
<td><pre>   Possible loss of fraction -- When two integers are divided and
      assigned to a floating point variable the fraction portion is
      lost.  For example, although

            double x = 5 / 2;

      appears to assign 2.5 to x it actually assigns 2.0.  To make sure
      you don't lose the fraction, cast at least one of the operands to
      a floating point type.  If you really wish to do the truncation,
      cast the resulting divide to an integral (int or long) before
      assigning to the floating point variable.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="654" id="654">654</a></td>
<td><pre>   Option String obsolete; use -width(W,I) -- The option -w is now
      used to set the warning level and should no longer be used to
      specify the width of error messages.  Instead use -width with the
      same arguments as before to set the width.  To set the warning
      level to 3, for example, use the option -w3, not -w(3).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="655" id="655">655</a></td>
<td><pre>   bit-wise operation uses (compatible) enum's -- A bit-wise
      operator (one of '|', '&amp;' or '^') is used to combine two
      compatible enumerations.  The type of the result is considered to
      be the enumeration.  This is considered a very minor deviation
      from the strict model and you may elect to suppress this warning.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="656" id="656">656</a></td>
<td><pre>   Arithmetic operation uses (compatible) enum's -- An arithmetic
      operator (one of '+', or '-') is used to combine two compatible
      enumerations.  The type of the result is considered to be the
      enumeration.  This is considered a very minor deviation from the
      strict model and you may elect to suppress this warning.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="657" id="657">657</a></td>
<td><pre>   Unusual (nonportable) anonymous struct or union -- A struct or
      union declaration without a declarator was taken to be anonymous.
      However, the anonymous union supported by C++ and other dialects
      of C require untagged union's.  Tagged unions and tagged or
      untagged structs are rarely supported, as anonymous.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="658" id="658">658</a></td>
<td><pre>   Anonymous union assumed (use flag +fan) -- A union without a
      declarator was found.  Was this an attempt to define an anonymous
      union?  If so, anonymous unions should be activated with the +fan
      flag.  This flag is activated automatically for C++.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="659" id="659">659</a></td>
<td><pre>   Nothing follows '}' on line within struct/union/enum declaration
      -- A struct/union/class/enum definition occurred and the closing
      '}' was not followed on the same line by another token.  It looks
      suspicious.  Missing semi-colons after such definitions can be a
      source of strange and mysterious messages.  If you intentionally
      omitted the semi-colon then simply place the token which follows
      on the same line as the '}'.  At the very least follow the '}'
      with a comment.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="660" id="660">660</a></td>
<td><pre>   Option 'String' requests removing an extent that is not on the
      list -- A number of options use the '-' prefix to remove and '+'
      to add elements to a list.  For example to add (the most unusual)
      extension .C++ to designate C++ processing of files bearing that
      extension, a programmer should employ the option:
     
          +cpp(.C++)
     
      However, if a leading '-' is employed (a natural mistake) this
      warning will be emitted.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="661" id="661">661</a></td>
<td><pre>   possible access of out-of-bounds pointer ('Integer' beyond end of
      data) by operator 'String' -- An out-of-bounds pointer may have
      been accessed.  See message 415 for a description of the
      parameters Integer and String.  For example:
     
            int a[10];
            if( n &lt;= 10 ) a[n] = 0;

      Here the programmer presumably should have written n&lt;10.  This
      message is similar to messages 415 and 796 but differs from them
      by the degree of probability.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="662" id="662">662</a></td>
<td><pre>   possible creation of out-of-bounds pointer ('Integer' beyond end
      of data) by operator 'String' -- An out-of-bounds pointer may
      have been created.  See message 415 for a description of the
      parameters Integer and String.  For example:
     
            int a[10];
            if( n &lt;= 20 ) f( a + n );

      Here, it appears as though an illicit pointer is being created,
      but PC-lint/FlexeLint cannot be certain.  See also messages 416
      and 797.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="663" id="663">663</a></td>
<td><pre>   Suspicious array to pointer conversion -- This warning occurs in
      the following kind of situation:
     
            struct x { int a; } y[2];
            ...  y-&gt;a  ...

      Here, the programmer forgot to index the array but the error
      normally goes undetected because the array reference is
      automatically and implicitly converted to a pointer to the first
      element of the array.  If you really mean to access the first
      element use y[0].a.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="664" id="664">664</a></td>
<td><pre>   Left side of logical OR (||) or logical AND (&amp;&amp;) does not return
      -- An exiting function was found on the left hand side of an
      operator implying that the right hand side would never be
      executed.  For example:
     
            if( (exit(0),n == 0) || n &gt; 2 ) ...

      Since the exit function does not return, control can never flow
      to the right hand operator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="665" id="665">665</a></td>
<td><pre>   Unparenthesized parameter Integer in macro 'Symbol' is passed an
      expression -- An expression was passed to a macro parameter that
      was not parenthesized.  For example:
     
            #define mult(a,b) (a*b)
            ...   mult( 100, 4 + 10 )

      Here the programmer is beguiled into thinking that the 4+10 is
      taken as a quantity to be multiplied by 100 but instead results
      in: 100*4+10 which is quite different.  The recommended remedy
      ([22, 20.4]) is to parenthesize such parameters as in:

           #define mult(a,b) ((a)*(b))

      The message is not arbitrarily given for any unparenthesized
      parameter but only when the actual macro argument sufficiently
      resembles an expression and the expression involves binary
      operators.  The priority of the operator is not considered except
      that it must have lower priority than the unary operators.  The
      message is not issued at the point of macro definition because it
      may not be appropriate to parenthesize the parameter.  For
      example, the following macro expects that an operator will be
      passed as argument.  It would be an error to enclose op in
      parentheses.
     
          #define check(x,op,y) if( ((x) op (y)) == 0 ) print( ... )
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="666" id="666">666</a></td>
<td><pre>   Expression with side effects passed to repeated parameter Integer
      of macro 'Symbol' -- A repeated parameter within a macro was
      passed an argument with side-effects.  For example:
     
            #define ABS(x) ((x) &lt; 0 ? -(x) : (x))

            ... ABS( n++ )

      Although the ABS macro is correctly defined to specify the
      absolute value of its argument, the repeated use of the parameter
      x implies a repeated evaluation of the actual argument n++.  This
      results in two increments to the variable n.  [22, 20.6]  Any
      expression containing a function call is also considered to have
      side-effects.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="667" id="667">667</a></td>
<td><pre>   Inconsistent use of qualifiers for symbol 'Symbol' (type 'Type'
      vs. 'Type') conflicts with Location -- A declaration for the
      identified Symbol is inconsistent with a prior declaration for
      the same symbol.  There was a nominal difference in the
      declaration but owing to the memory model chosen there was no
      real difference.  For example, in large model, one declaration
      declares external symbol alpha to be a far pointer and another
      declaration omits the memory model specification.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="668" id="668">668</a></td>
<td><pre>   Possibly passing a null pointer to function 'Symbol', Context
      Reference -- A NULL pointer is possibly being passed to a
      function identified by Symbol.  The argument in question is given
      by Context.  The function is either a library function designed
      not to receive a NULL pointer or a user function dubbed so via
      the option -function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="669" id="669">669</a></td>
<td><pre>   Possible data overrun for function 'Symbol', argument Integer
      exceeds argument Integer Reference -- This message is for data
      transfer functions such as memcpy, strcpy, fgets, etc. when the
      size indicated by the first cited argument (or arguments) can
      possibly exceed the size of the buffer area cited by the second.
      The message may also be issued for user functions via the
      -function option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="670" id="670">670</a></td>
<td><pre>   Possible access beyond array for function 'Symbol', argument
      Integer exceeds Integer Reference -- This message is issued for
      several library functions (such as fwrite, memcmp, etc) wherein
      there is a possible attempt to access more data than exist.  For
      example, if the length of data specified in the fwrite call
      exceeds the size of the data specified.  The function is
      specified by Symbol and the arguments are identified by argument
      number.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="671" id="671">671</a></td>
<td><pre>   Possibly passing to function 'Symbol' a negative value (Integer),
      Context Reference -- An integral value that may possibly be
      negative is being passed to a function that is expecting only
      positive values for a particular argument.  The message contains
      the name of the function (Symbol), the questionable value
      (Integer) and the argument number (Context).  The function may be
      a standard library function designed to accept only positive
      values such as malloc or memcpy (third argument), or may have
      been identified by the user as such through the -function or -sem
      options.  See message 422 for an example and further explanation.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="672" id="672">672</a></td>
<td><pre>   Possible memory leak in assignment to pointer 'Symbol' -- An
      assignment was made to a pointer variable (designated by Symbol)
      which may already be holding the address of an allocated object
      which had not been freed.  The allocation of memory which is not
      freed is considered a 'memory leak'.  The memory leak is
      considered 'possible' because only some lines of flow will result
      in a leak.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="673" id="673">673</a></td>
<td><pre>   Possibly inappropriate deallocation (Name1) for 'Name2' data. --
      This message indicates that a deallocation (free( ), delete, or
      delete[]) as specified by String1 may be inappropriate for the
      data being freed.  The kind of data is one or more of: malloc,
      new, new[], static, auto, member, modified or constant.  The word
      'Possibly' is used in the message to indicate that only some of
      the lines of flow to the deallocation show data inconsistent with
      the allocation.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="674" id="674">674</a></td>
<td><pre>   Returning address of auto through variable 'Symbol'. -- The value
      held by a pointer variable contains the address of an auto
      variable.  It is normally incorrect to return the address of an
      item on the stack because the portion of the stack allocated to
      the returning function is subject to being obliterated after
      return.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="675" id="675">675</a></td>
<td><pre>   No prior semantics associated with 'Name' in option 'String' --
      The -function option is used to transfer semantics from its first
      argument to subsequent arguments.  However it was found that the
      first argument Name did not have semantics.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="676" id="676">676</a></td>
<td><pre>   Possibly negative subscript (Integer) in operator 'String' -- An
      integer whose value was possibly negative was added to an array
      or to a pointer to an allocated area (allocated by malloc,
      operator new, etc.) This message is not given for pointers whose
      origin is unknown since a negative subscript is in general legal.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="677" id="677">677</a></td>
<td><pre>   sizeof used within preprocessor statement. -- Whereas the use of
      sizeof during preprocessing is supported by a number of compilers
      it is not a part of the ANSI C or C++ standard.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="678" id="678">678</a></td>
<td><pre>   Member 'Symbol' field length (Integer) too small for enum
      precision (Integer) -- A bit field was found to be too small to
      support all the values of an enumeration (that was used as the
      base of the bit field).  For example:
     
            enum color { red, green, yellow, blue };
            struct abc { enum color c:2; };

      Here, the message is not given because the four enumeration
      values of color will just fit within 2 bits.  However, if one
      additional color is inserted, Warning 678 will be issued
      informing the programmer of the undesirable and dangerous
      condition.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="679" id="679">679</a></td>
<td><pre>   Suspicious Truncation in arithmetic expression combining with
      pointer -- This message is issued when it appears that there may
      have been an unintended loss of information during an operation
      involving integrals prior to combining with a pointer whose
      precision is greater than the integral expression.  For example:
     
            //lint -sp8  pointers are 8 bytes
            //lint -si4  integers are 4 bytes
            char *f( char *p, int n, int m )
                {
                return p + (n + m);  // warning 679
                }

      By the rules of C/C++, the addition n+m is performed
      independently of its context and is done at integer precision.
      Any overflow is ignored even though the larger precision of the
      pointer could easily accommodate the overflow.  If, on the other
      hand the expression were: p+n+m, which parses as (p+n)+m, no
      warning would be issued.

      If the expression were p + n * m then, to suppress the warning, a
      cast is needed.  If long were the same size as pointers you could
      use the expression:

            return p + ((long) n * m);

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="680" id="680">680</a></td>
<td><pre>   Suspicious Truncation in arithmetic expression converted to
      pointer -- An arithmetic expression was cast to pointer.
      Moreover, the size of the pointer is greater than the size of the
      expression.  In computing the expression, any overflow would be
      lost even though the pointer type would be able to accommodate
      the lost information.  To suppress the message, cast one of the
      operands to an integral type large enough to hold the pointer.
      Alternatively, if you are sure there is no problem you may cast
      the expression to an integral type before casting to pointer.
      See messages 647, 776, 790 and 679.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="681" id="681">681</a></td>
<td><pre>   Loop is not entered -- The controlling expression for a loop
      (either the expression within a while clause or the second
      expression within a for clause) evaluates initially to 0 and so
      it appears as though the loop is never entered.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="682" id="682">682</a></td>
<td><pre>   sizeof applied to a parameter 'Symbol' whose type is a sized
      array -- If a parameter is typed as an array it is silently
      promoted to pointer.  Taking the size of such an array will
      actually yield the size of a pointer.  Consider, for example:

            unsigned f( char a[100] ) { return sizeof(a); }

      Here it looks as though function f( ) will return the value 100
      but it will actually return the size of a pointer which is
      usually 4.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="683" id="683">683</a></td>
<td><pre>   function 'Symbol' #define'd -- This message is issued whenever
      the name of a function with some semantic association is defined
      as a macro.  For example:

             #define strlen mystrlen

      will raise this message.  The problem is that the semantics
      defined for strlen will then be lost.  Consider this message an
      alert to transfer semantics from strlen to mystrlen, using
      -function(strlen, mystrlen) The message will be issued for
      built-in functions (with built-in semantics) or for user-defined
      semantics.  The message will not be issued if the function is
      defined to be a function with a similar name but with underscores
      either appended or prepended or both.  For example:

             #define strlen __strlen

      will not produce this message.  It will produce Info 828 instead.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="684" id="684">684</a></td>
<td><pre>   Passing address of auto variable 'Symbol' into caller space --
      The address of an auto variable was passed via assignment into a
      location specified by the caller to the function.  For example:
     
            void f( int *a[] )
                {
                int n;
                a[1] = &amp;n;
                }

      Here the address of an auto variable (n) is being passed into the
      second element of the array passed to the function f.  This looks
      suspicious because upon return the array will contain a pointer
      to a variable whose lifetime is over.  It is possible that this
      is benign since it could be that the caller to f( ) is merely
      passing in a working space to be discarded upon return.  If this
      is the case, you can suppress the message for function f( ) using
      the option

            -efunc(684,f).

      See also Warning 604.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="685" id="685">685</a></td>
<td><pre>   Relational operator 'String,' always evaluates to 'String' -- The
      first String is one of '&gt;', '&gt;=', '&lt;' or '&lt;=' and identifies the
      relational operator.  The second string is one of 'True' or
      'False,0&gt;'.  The message is given when an expression is compared
      to a constant and the precision of the expression indicates that
      the test will always succeed or always fail.  For example,
     
        char ch;
        ...
        if( ch &gt;= -128 ) ...

      In this example, the precision of char ch is 8 bits signed
      (assuming the fcu flag has been left in the OFF state) and hence
      it has a range of values from -128 to 127 inclusive.  Hence the
      trest is always True.

      Note that, technically, ch is promoted to int before comparing
      with the constant.  For the purpose of this comparison we
      consider only the underlying precision.  As another example, if u
      is an unsigned int then

        if( (u &amp; 0xFF) &gt; 0xFF ) ...

      will also raise a 685 because the expression on the left hand
      side has an effective precision of 16 bits.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="686" id="686">686</a></td>
<td><pre>   Option 'String' is suspicious because of 'Name' -- An option is
      considered suspicious for one of a variety of reasons.  The
      reason is designated by a reason code that is specified by Name.
      At this writing the following reasons for issuing this message
      exist:

      o  unbalanced quotes -- An option was seen with a quote character
      which was not balanced within that same option.

      o  backtick preceding non-meta character is superfluous and has
      been dropped -- A backtick (`) was seen before a character other
      than a * or a ?. The use of a backtick in this fashion has no
      effect.

      o  Upper case characters within extension 'String'; these will
      match lower case when +fff is on; try -fff -- A file extension
      involving capital letters was seen in a +cpp(), +lnt(), or +ext()
      option while the +fff flag was active. If, for example, you
      intend for .c to indicate a C module and .C to indicate a C++
      module, turning off the fff flag will help avoid unnecessary
      complaints from Lint.

      o  extraneous characters following String -- One or more
      characters were seen immediately following a character which is
      expected to signify the end of an option, such as a closing right
      parenthesis. While the extraneous characters are ignored, their
      presence may indicate a typographical error.

      o  missing field-specifier in a non-empty format string [No data
      will be generated for this category.] -- A -program_info() option
      was expecting a field-specifier which was actually missing. As
      noted, no data for this particular category will be generated.

      o  the likelihood of causing meaningless output -- An option,
      such as -elib(*), -wlib(0), or +fce was seen; this typically
      hides a problem in the Lint configuration. When using a new Lint
      configuration, it's common for a user to encounter Error messages
      from Lint about library header code. (This usually does not
      indicate a problem with library headers.) For example, a
      misconfiguration of Lint's preprocessor is by far the most common
      source of these errors.  If you merely suppress basic Syntax
      Errors (like Error 10) and/or Fatal Errors (like Error 309), the
      underlying Lint configuration problem still exists; as a result,
      Lint will fail to parse your code correctly (because your code
      depends on the aforementioned library code). The output from Lint
      would then seem illogical and/or meaningless. Therefore, blanket
      suppression options like this are highly discouraged.  Instead,
      other aspects of the Lint configuration should be modified to
      make Lint's behavior more similar to that of the compiler at (or,
      typically, before) the point of the Error.

      o  a lack of an argument -- A -message() was found to not include
      text between the parentheses, rendering the option meaningless.
      Did the User possibly intend to include the text immediately
      after this option?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="687" id="687">687</a></td>
<td><pre>   Suspicious use of comma operator -- A comma operator appeared
      unbraced and unparenthesized in a statement following an if,
      else, while or for clause.  For example:
     
              if( n &gt; 0 ) n = 1,
              n = 2;
     
      Thus the comma could be mistaken for a semi-colon and hence be
      the source of subtle bugs.

      If the statement is enclosed in curly braces or if the expression
      is enclosed in parentheses, the message is not issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="688" id="688">688</a></td>
<td><pre>   Cast used within a preprocessor conditional statement -- A cast
      was used within a preprocessor conditional statement such as #if
      or #elif.  As an example you may have written:
     
              #define VERSION 11.3
              ...
              #if (int) VERSION == 11
                  ...
              #endif
     
      Such casts are not allowed by the various C and C++ standards.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="689" id="689">689</a></td>
<td><pre>   Apparent end of comment ignored -- The pair of characters '*/'
      was found not within a comment.  As an example:
     
              void f( void*/*comment*/ );
     
      This is taken to be the equivalent of:
     
              void f( void*  );
     
      That is, an implied blank is inserted between the '*' and the
      '/'.  To avoid this message simply place an explicit blank
      between the two characters.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="690" id="690">690</a></td>
<td><pre>   Possible access of pointer pointing Integer bytes past nul
      character by operator 'String' -- Accessing past the terminating
      nul character is often an indication of a programmer error.  For
      example:
     
              char buf[20];
              char c;
              strcpy( buf, "a" );
              if( i &lt; 20 )
                  c = buf[i];   // legal but suspect.
     
      See also <ref,warning 448="" in="" section="" 13.3,13.3=""> and <ref,info 836="" in="" section="" 13.4,13.4="">

</ref,info></ref,warning></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="691" id="691">691</a></td>
<td><pre>   Suspicious use of backslash -- The backslash character has been
      used in a way that may produce unexpected results.  Typically
      this would occur within a macro such as:
     
              #define A b \ // comment
     
      The coder might be thinking that the macro definition will be
      continued on to the next line.  The standard indicates, however,
      that the newline will not be dropped in the event of an
      intervening comment.  This should probably be recoded as:
     
              #define A b /* comment */ \
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="692" id="692">692</a></td>
<td><pre>   Decimal character 'Char' follows octal escape sequence 'String'
      -- A String was found that contains an '8' or '9' after an octal
      escape sequence with no more than two octal digits, e.g.
     
              "\079"
     
      contains two characters: Octal seven (ASCII BEL) followed by '9'.
      The casual reader of the code (and perhaps even the programmer)
      could be fooled into thinking this is a single character.  If
      this is what the programmer intended he can also render this as
     
              "\07" "9"
     
      so that there can be no misunderstanding.

      On the other hand,
     
             "\1238"
     
      will not raise a message because it is assumed that the
      programmer knows that octal escape sequences cannot exceed four
      characters (including the initial backslash).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="693" id="693">693</a></td>
<td><pre>   Hexadecimal digit 'Char' immediately after 'String' is suspicious
      in string literal. -- A String was found that looks suspiciously
      like (but is not) a hexadecimal escape sequence; rather, it is a
      null character followed by letter "x" followed by some
      hexadecimal digit, e.g.:
     
              "\0x62"
     
      was found where the programmer probably meant to type "\x62".  If
      you need precisely this sequence you can use:
     
              "\0" "x62"
     
      and this warning will not be issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="694" id="694">694</a></td>
<td><pre>   The type of constant 'String' (precision Integer) is dialect
      dependent -- A decimal integer constant that requires all the
      bits of an unsigned long for its representation has a type that
      depends on the dialect of C or C++ implemented by the compiler
      you are using.  For example, the constant 3000000000 requires 32
      bits for its representation.  If longs are 32 bits, then the
      constant is judged to be unsigned long in C90, long long in C99
      and undefined in C++.

      You can remove the ambiguity by applying a clarifying suffix.  If
      you intend this to be unsigned use the 'U' suffix.  If you intend
      this to be a long long use the 'LL' suffix.  If the latter and
      you are using C++ then turn on the +fll flag.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="695" id="695">695</a></td>
<td><pre>   Inline function 'Symbol' defined without a storage-class
      specifier ('static' recommended) -- In C99, the result of a call
      to a function declared with 'inline' but not 'static' or 'extern'
      is unspecified.

      Example: Let the following text represent two translation units:
     
              /* In module_1.c */
              void f() {}

              /* In module_2.c */
              inline void f() {}
              void g() { f(); }  /* which f() is called? */
     
      The C99 Standard dictates that the above call to f() from g() in
      module_2.c may result in the execution of either f().

      The programmer may avoid confusion and improve portability by
      using the keyword 'static' in addition to 'inline'.  The keyword
      'extern' can also be used along with the 'inline' to resolve this
      ambiguity; however, we recommend using 'static' because, as of
      this writing, more compilers correctly interpret 'static inline'.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="696" id="696">696</a></td>
<td><pre>   Variable 'Symbol' has value 'String' that is out of range for
      operator 'String' -- The variable cited in the message is being
      compared (using one of the 6 comparison operations) with some
      other expression called the comperand.  The variable has a value
      that is out of the range of values of this comperand.  For
      example consider:
     
              void f( unsigned char ch )
                  {
                  int n = 1000;
                  if( ch &lt; n )   // Message 696
                  ...
     
      Here a message 696 will be issued stating that n has a value of
      1000 that is out of range because 1000 is not in the set of
      values that ch can hold (assuming default sizes of scalars).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="697" id="697">697</a></td>
<td><pre>   Quasi-boolean values should be equality-compared only with 0 -- A
      quasi-boolean value is being compared (using either != or ==)
      with a value that is not the literal zero.  A quasi-boolean value
      is any value whose type is a strong boolean type and that could
      conceivably be something other than zero or one.  This is
      significant  because in C, all non-zero values are equally true.
      Example:
     
              /*lint -strong(AJXb, B) */
              typedef int B;
              #define YES ((B)1)
              #define NO ((B)0)

              B f( B a, B b ) {
                  B c = ( a == NO );  /* OK, no Warning here */
                  B d = ( a == (b != NO) ); /* Warning 697 for == but not for != */
                  B e = ( a == YES ); /* Warning 697 here */
                  return d == c;      /* Warning 697 here */
              }
     
      Note that if a and b had instead been declared with true boolean
      types, such as 'bool' in C++ or '_Bool' in C99, this diagnostic
      would not have been issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="698" id="698">698</a></td>
<td><pre>   Casual use of realloc can create a memory leak -- A statement of
      the form:
     
              v = realloc( v, ... );
     
      has been detected.  Note the repeated use of the same variable.
      The problem is that realloc can fail to allocate the necessary
      storage.  In so doing it will return NULL.  But then the original
      value of v is overwritten resulting in a memory leak.


              ------ 19.5 C Informational Messages ------


</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="701" id="701">701</a></td>
<td><pre>   Shift left of signed quantity (int) -- Shifts are normally
      accomplished on unsigned operands.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="702" id="702">702</a></td>
<td><pre>   Shift right of signed quantity (int) -- Shifts are normally
      accomplished on unsigned operands.  Shifting an int right is
      machine dependent (sign fill vs. zero fill).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="703" id="703">703</a></td>
<td><pre>   Shift left of signed quantity (long) -- Shifts are normally
      accomplished on unsigned operands.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="704" id="704">704</a></td>
<td><pre>   Shift right of signed quantity (long) -- Shifts are normally
      accomplished on unsigned operands.  Shifting a long right is
      machine dependent (sign fill vs. zero fill).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="705" id="705">705</a></td>
<td><pre>   Argument no. Integer nominally inconsistent with format -- The
      argument to a printf (or fprintf or sprintf) was nominally
      inconsistent with the format.  Although the size of the quantity
      was appropriate the type was similar, but not exact.  (E.g.,
      passing a long to a %d or an int to a %x)  You might consider
      casting the quantity to the correct type.  You could also
      suppress this message, as more flagrant violations are picked up
      with warnings 559 and 626.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="706" id="706">706</a></td>
<td><pre>   (arg. no. Integer) indirect object inconsistent with format --
      The type of an argument to scanf (or fscanf or sscanf) was
      inappropriate to the format.  However, the argument was a pointer
      and it pointed to a quantity of the expected size and similar,
      but not expected type.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="707" id="707">707</a></td>
<td><pre>   Mixing narrow and wide string literals in concatenation. -- The
      following is an example of a mixing of narrow and wide string
      literals.
     
          const wchar_t *s = "abc" L"def";
     
      The concatenation of narrow and wide string literals results in
      undefined behavior for C90 and C++2003.  If your compiler
      supports such combinations or you use a C/C++ dialect that
      supports such, you may either suppress this message or consider
      making the concatenands match.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="708" id="708">708</a></td>
<td><pre>   union initialization -- There was an attempt to initialize the
      value of a union.  This may not be permitted in some older C
      compilers. This is because of the apparent ambiguity: which
      member should be initialized. The standard interpretation is to
      apply the initialization to the first subtype of the union.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="712" id="712">712</a></td>
<td><pre>   Loss of precision (Context) (Type to Type) -- An assignment (or
      implied assignment, see Context) is being made between two
      integral quantities in which the first Type is larger than the
      second Type.  A cast will suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="713" id="713">713</a></td>
<td><pre>   Loss of precision (Context) (Type to Type) -- An assignment (or
      implied assignment, see Context) is being made from an unsigned
      quantity to a signed quantity, that will result in the possible
      loss of one bit of integral precision such as converting from
      unsigned int to int.  A cast will suppress the message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="714" id="714">714</a></td>
<td><pre>   Symbol 'Symbol' (Location) not referenced -- The named external
      variable or external function was defined but not referenced.
      This message is suppressed for unit checkout (-u option).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="715" id="715">715</a></td>
<td><pre>   Symbol 'Symbol' (Location) not referenced -- The named formal
      parameter was not referenced.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="716" id="716">716</a></td>
<td><pre>   while(1) ... -- A construct of the form while(1) ... was found.
      Whereas this represents a constant in a context expecting a
      Boolean, it may reflect a programming policy whereby infinite
      loops are prefixed with this construct.  Hence it is given a
      separate number and has been placed in the informational
      category. The more conventional form of infinite loop prefix is
      for(;;).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="717" id="717">717</a></td>
<td><pre>   do ... while(0) -- Whereas this represents a constant in a
      context expecting a Boolean, this construct is probably a
      deliberate attempt on the part of the programmer to encapsulate a
      sequence of statements into a single statement, and so it is
      given a separate error message.  [22, 20.7]  For example:

           #define f(k) do {n=k; m=n+1;} while(0)

      allows f(k) to be used in conditional statements as in

           if(n&gt;0) f(3);
           else f(2);

      Thus, if you are doing this deliberately use -e717

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="718" id="718">718</a></td>
<td><pre>   Symbol 'Symbol' undeclared, assumed to return int -- A function
      was referenced without (or before) it had been declared or
      defined within the current module.  This is not necessarily an
      error and you may want to suppress such messages.  Note that by
      adding a declaration to another module, you will not suppress
      this message.  It can only be suppressed by placing a declaration
      within the module being processed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="719" id="719">719</a></td>
<td><pre>   Too many arguments for format (Integer too many) -- The number of
      arguments to a function in the printf/scanf family was more than
      what is specified in the format.  This message is similar to
      Warning 558 which alerts users to situations in which there were
      too few arguments for the format.  It receives a lighter
      Informational classification because the additional arguments are
      simply ignored.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="720" id="720">720</a></td>
<td><pre>   Boolean test of assignment -- An assignment was found in a
      context that requires a Boolean (such as in an if( ) or while( )
      clause or as an operand to &amp;&amp; or ||).  This may be legitimate or
      it could have resulted from a mistaken use of = for ==.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="721" id="721">721</a></td>
<td><pre>   Suspicious use of ; -- A semi-colon was found immediately to the
      right of a right parenthesis in a construct of the form if(e);.
      As such it may be overlooked or confused with the use of
      semi-colons to terminate statements.  The message will be
      inhibited if the ';' is separated by at least one blank from the
      ')'. Better, place it on a separate line. See also message 548.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="722" id="722">722</a></td>
<td><pre>   Suspicious use of ; -- A semi-colon was found immediately to the
      right of a right parenthesis in a construct of the form while(e);
      or for(e;e;e);.  As such it may be overlooked or confused with
      the use of semi-colons to terminate statements.  The message will
      be inhibited if the ';' is separated by at least one blank from
      the ')'.  Better, place it on a separate line.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="723" id="723">723</a></td>
<td><pre>   Suspicious use of = -- A preprocessor definition began with an =
      sign.  For example:

            #define LIMIT = 50

      Was this intentional?  Or was the programmer thinking of
      assignment when he wrote this?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="725" id="725">725</a></td>
<td><pre>   Expected positive indentation from Location -- The current line
      was found to be aligned with, rather than indented with respect
      to, the indicated line.  The indicated line corresponds to a
      clause introducing a control structure and statements within its
      scope are expected to be indented with respect to it.  If tabs
      within your program are other than 8 blanks you should use the -t
      option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="726" id="726">726</a></td>
<td><pre>   Extraneous comma ignored -- A comma followed by a right-brace
      within an enumeration is not a valid ANSI construct.  The comma
      is ignored.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="727" id="727">727</a></td>
<td><pre>   Symbol 'Symbol' (Location) not explicitly initialized -- The
      named static variable (local to a function) was not explicitly
      initialized prior to use.  The following remarks apply to
      messages 728 and 729 as well as 727.  By no explicit
      initialization we mean that there was no initializer present in
      the definition of the object, no direct assignment to the object,
      and no address operator applied to the object or, if the address
      of the object was taken, it was assigned to a pointer to const.
      These messages do not necessarily signal errors since the
      implicit initialization for static variables is 0.  However, the
      messages are helpful in indicating those variables that you had
      forgotten to initialize to a value.  To extract the maximum
      benefit from the messages we suggest that you employ an explicit
      initializer for those variables that you want to initialize to 0.
      For example:

            static int n = 0;

      For variables that will be initialized dynamically, do not use an
      explicit initializer as in:

            static int m;

      This message will be given for any array, struct or union if no
      member or element has been assigned a value.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="728" id="728">728</a></td>
<td><pre>   Symbol 'Symbol' (Location) not explicitly initialized -- The
      named intra-module variable (static variable with file scope) was
      not explicitly initialized.  See the comments on message 727 for
      more details.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="729" id="729">729</a></td>
<td><pre>   Symbol 'Symbol' (Location) not explicitly initialized -- The
      named inter-module variable (external variable) was not
      explicitly initialized.  See the comments on message 727 for more
      details.  This message is suppressed for unit checkout (-u).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="730" id="730">730</a></td>
<td><pre>   Boolean argument to function -- A Boolean was used as an argument
      to a function.  Was this intended?  Or was the programmer
      confused by a particularly complex conditional statement.
      Experienced C programmers often suppress this message.  This
      message is given only if the associated parameter is not declared
      bool.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="731" id="731">731</a></td>
<td><pre>   Boolean argument to equal/not equal -- A Boolean was used as an
      argument to == or !=.  For example:

            if( (a &gt; b) == (c &gt; d) ) ...

      tests to see if the inequalities are of the same value.  This
      could be an error as it is an unusual use of a Boolean (see
      Warnings 503 and 514) but it may also be deliberate since this is
      the only way to efficiently achieve equivalence or exclusive or.
      Because of this possible use, the construct is given a relatively
      mild 'informational' classification.  If the Boolean argument is
      cast to some type, this message is not given.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="732" id="732">732</a></td>
<td><pre>   Loss of sign (Context) (Type to Type) -- An assignment (or
      implied assignment, see Context) is made from a signed quantity
      to an unsigned quantity.  Also, it could not be determined that
      the signed quantity had no sign.  For example:

            u  =  n;      /* Info 732 */
            u  =  4;      /*  OK      */

      where u is unsigned and n is not, warrants a message only for the
      first assignment, even though the constant 4 is nominally a
      signed int.

      Make sure that this is not an error (that the assigned value is
      never negative) and then use a cast (to unsigned) to remove the
      message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="733" id="733">733</a></td>
<td><pre>   Assigning address of auto variable 'Symbol' to outer scope symbol
      'Symbol' -- The address of an auto variable is only valid within
      the block in which the variable is declared.  An address to such
      a variable has been assigned to a variable that has a longer life
      expectancy.  There is an inherent danger in doing this.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="734" id="734">734</a></td>
<td><pre>   Loss of precision (Context) (Integer bits to Integer bits) -- An
      assignment is being made into an object smaller than an int.  The
      information being assigned is derived from another object or
      combination of objects in such a way that information could
      potentially be lost.  The number of bits given does not count the
      sign bit.  For example if ch is a char and n is an int then:

            ch  =  n;

      will trigger this message whereas:

            ch  =  n &amp; 1;

      will not.  To suppress the message a cast can be made as in:

            ch  =  (char) n;

      You may receive notices involving multiplication and shift
      operators with subinteger variables.  For example:

            ch = ch &lt;&lt; 2
            ch = ch * ch

      where, for example, ch is an unsigned char.  These can be
      suppressed by using the flag +fpm (precision of an operator is
      bound by the maximum of its operands).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="735" id="735">735</a></td>
<td><pre>   Loss of precision (Context) (Integer bits to Integer bits) -- An
      assignment (or implied assignment, see Context) is made from a
      long double to a double.  Using a cast will suppress the message.
      The number of bits includes the sign bit.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="736" id="736">736</a></td>
<td><pre>   Loss of precision (Context) (Integer bits to Integer bits) -- An
      assignment (or implied assignment, see Context) is being made to
      a float from a value or combination of values that appear to have
      higher precision than a float.  You may suppress this message by
      using a cast.  The number of bits includes the sign bit.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="737" id="737">737</a></td>
<td><pre>   Loss of sign in promotion from Type to Type -- An unsigned
      quantity was joined with a signed quantity in a binary operator
      (or 2nd and 3rd arguments to the conditional operator ? :) and
      the signed quantity is implicitly converted to unsigned.  The
      message will not be given if the signed quantity is an unsigned
      constant, a Boolean, or an expression involving bit manipulation.
      For example,

             u  &amp;  ~0xFF 

      where u is unsigned does not draw the message even though the
      operand on the right is technically a signed integer constant.
      It looks enough like an unsigned to warrant not giving the
      message.

      This mixed mode operation could also draw Warnings 573 or 574
      depending upon which operator is involved.

      You may suppress the message with a cast but you should first
      determine whether the signed value could ever be negative or
      whether the unsigned value can fit within the constraints of a
      signed quantity.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="738" id="738">738</a></td>
<td><pre>   Symbol 'Symbol' (Location) not explicitly initialized -- The
      named static local variable was not initialized before being
      passed to a function whose corresponding parameter is declared as
      pointer to const.  Is this an error or is the programmer relying
      on the default initialization of 0 for all static items.  By
      employing an explicit initializer you will suppress this message.
      See also message numbers 727 and 603.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="739" id="739">739</a></td>
<td><pre>   Trigraph Sequence 'String' in literal (Quiet Change) -- The
      indicated Trigraph (three-character) sequence was found within a
      string.  This trigraph reduces to a single character according to
      the ANSI standard.  This represents a "Quiet Change" from the
      past where the sequence was not treated as exceptional.  If you
      had no intention of mapping these characters into a single
      character you may precede the initial '?' with a backslash.  If
      you are aware of the convention and you intend that the Trigraph
      be converted you should suppress this informational message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="740" id="740">740</a></td>
<td><pre>   Unusual pointer cast (incompatible indirect types) -- A cast is
      being made to convert one pointer to another such that neither of
      the pointers is a generic pointer (neither is pointer to char,
      unsigned char, or void) and the indirect types are truly
      different.  The message will not be given if the indirect types
      differ merely in signedness (e.g., pointer to unsigned versus
      pointer to int) or in qualification (e.g., pointer to const int
      versus pointer to int).  The message will also not be given if
      one of the indirect types is a union.

      The main purpose of this message is to report possible problems
      for machines in which pointer to char is rendered differently
      from pointer to word.  Consider casting a pointer to pointer to
      char to a pointer to pointer to word.  The indirect bit pattern
      remains unchanged.

      A second reason is to identify those pointer casts in which the
      indirect type doesn't seem to have the proper bit pattern such as
      casting from a pointer to int to a pointer to double.

      If you are not interested in running on machines in which char
      pointers are fundamentally different from other pointers then you
      may want to suppress this message.  You can also suppress this
      message by first casting to char pointer or to void pointer but
      this is only recommended if the underlying semantics are right.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="741" id="741">741</a></td>
<td><pre>   Unusual pointer cast (function qualification) -- A cast is being
      made between two pointers such that their indirect types differ
      in one of the Microsoft qualifiers: pascal, fortran, cdecl and
      interrupt.  If this is not an error you may cast to a more
      neutral pointer first such as a void *.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="742" id="742">742</a></td>
<td><pre>   Multiple character constant -- A character constant was found
      that contained multiple characters, e.g., 'ab'.  This is legal C
      but the numeric value of the constant is implementation defined.
      It may be safe to suppress this message because, if more
      characters are provided than what can fit in an int, message
      number 25 is given.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="743" id="743">743</a></td>
<td><pre>   Negative character constant -- A character constant was specified
      whose value is some negative integer.  For example, on machines
      where a byte is 8 bits, the character constant '\xFF' is flagged
      because its value (according to the ANSI standard) is -1 (its
      type is int).  Note that its value is not 0xFF.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="744" id="744">744</a></td>
<td><pre>   switch statement has no default -- A switch statement has no
      section labeled default:.  Was this an oversight?  It is standard
      practice in many programming groups to always have a default:
      case.  This can lead to better (and earlier) error detection.
      One way to suppress this message is by introducing a vacuous
      default: break; statement.  If you think this adds too much
      overhead to your program, think again.  In all cases tested so
      far, the introduction of this statement added absolutely nothing
      to the overall length of code.  If you accompany the vacuous
      statement with a suitable comment, your code will at least be
      more readable.

      This message is not given if the control expression is an
      enumerated type.  In this case, all enumerated constants are
      expected to be represented by case statements, else 787 will be
      issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="745" id="745">745</a></td>
<td><pre>   function 'Name' has no explicit type or class, int assumed -- A
      function declaration or definition contained no explicit type.
      Was this deliberate?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="746" id="746">746</a></td>
<td><pre>   call to function 'Name' not made in the presence of a prototype
      -- A call to a function is not made in the presence of a
      prototype.  This does not mean that PC-lint/FlexeLint is unaware
      of any prototype; it means that a prototype is not in a position
      for a compiler to see it.  If you have not adopted a strict
      prototyping convention you will want to suppress this message
      with -e746.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="747" id="747">747</a></td>
<td><pre>   Significant prototype coercion (Context) Type to Type -- The type
      specified in the prototype differed from the type provided as an
      argument in some significant way.  Usually the two types are
      arithmetic of differing sizes or one is float and the other
      integral.  This is flagged because if the program were to be
      translated by a compiler that does not support prototype
      conversion, the conversion would not be performed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="748" id="748">748</a></td>
<td><pre>   Symbol 'Symbol' (Location) is a register variable used with
      setjmp -- The named variable is a register variable and is used
      within a function that calls upon setjmp.  When a subsequent
      longjmp is issued the values of register variables may be
      unpredictable.  If this error is not suppressed for this
      variable, the variable is marked as uninitialized at this point
      in the program.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="749" id="749">749</a></td>
<td><pre>   local enumeration constant 'Symbol' (Location) not referenced --
      A member (name provided as Symbol) of an enum was defined in a
      module but was not otherwise used within that module.  A 'local'
      member is one that is not defined in a header file.  Compare with
      messages 754 and 769.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="750" id="750">750</a></td>
<td><pre>   local macro 'Symbol' (Location) not referenced -- A 'local' macro
      is one that is not defined in a header file.  The macro was not
      referenced throughout the module in which it is defined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="751" id="751">751</a></td>
<td><pre>   local typedef 'Symbol' (Location) not referenced -- A 'local'
      typedef symbol is one that is not defined in any header file.  It
      may have file scope or block scope but it was not used through
      its scope.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="752" id="752">752</a></td>
<td><pre>   local declarator 'Symbol' (Location) not referenced -- A 'local'
      declarator symbol is one declared in a declaration which appeared
      in the module file itself as opposed to a header file.  The
      symbol may have file scope or may have block scope.  But it
      wasn't referenced.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="753" id="753">753</a></td>
<td><pre>   local struct, union or enum tag 'Symbol' (Location) not
      referenced -- A 'local' tag is one not defined in a header file.
      Since its definition appeared, why was it not used?   Use of a
      tag is implied by the use of any of its members.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="754" id="754">754</a></td>
<td><pre>   local structure member 'Symbol' (Location) not referenced -- A
      member (name provided as Symbol) of a struct or union was defined
      in a module but was not otherwise used within that module.  A
      'local' member is one that is not defined in a header file.  See
      message 768.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="755" id="755">755</a></td>
<td><pre>   global macro 'Symbol' (Location) not referenced -- A 'global'
      macro is one defined in a header file.  This message is given for
      macros defined in non-library headers.  The macro is not used in
      any of the modules comprising the program.  This message is
      suppressed for unit checkout (-u option).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="756" id="756">756</a></td>
<td><pre>   global typedef 'Symbol' (Location) not referenced -- This message
      is given for a typedef symbol declared in a non-library header
      file.  The symbol is not used in any of the modules comprising a
      program.  This message is suppressed for unit checkout (-u
      option).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="757" id="757">757</a></td>
<td><pre>   global declarator 'Symbol' (Location) not referenced -- This
      message is given for objects that have been declared in
      non-library header files and that have not been used in any
      module comprising the program being checked.  The message is
      suppressed for unit checkout (-u).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="758" id="758">758</a></td>
<td><pre>   global struct, union or enum tag 'Symbol' (Location) not
      referenced -- This message is given for struct, union and enum
      tags that have been defined in non-library header files and that
      have not been used in any module comprising the program.  The
      message is suppressed for unit checkout (-u).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="759" id="759">759</a></td>
<td><pre>   header declaration for symbol 'Symbol' (Location) could be moved
      from header to module -- This message is given for declarations,
      within non-library header files, that are not referenced outside
      the defining module.  Hence, it can be moved inside the module
      and thereby 'lighten the load' on all modules using the header.
      This message is only given when more than one module is being
      linted.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="760" id="760">760</a></td>
<td><pre>   Redundant macro 'Symbol' defined identically at Location -- The
      given macro was defined earlier (location given) in the same way
      and is hence redundant.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="761" id="761">761</a></td>
<td><pre>   Redundant typedef 'Symbol' previously declared at Location -- A
      typedef symbol has been typedefed earlier at the given location.
      Although the declarations are consistent you should probably
      remove the second.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="762" id="762">762</a></td>
<td><pre>   Redundantly declared symbol 'Symbol' previously declared at
      Location -- A declaration for the given symbol was found to be
      consistent with an earlier declaration in the same scope.  This
      declaration adds nothing new and it can be removed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="763" id="763">763</a></td>
<td><pre>   Redundant declaration for symbol 'Symbol' previously declared at
      Location -- A tag for a struct, union or enum was defined twice
      in the same module (consistently).  The second one can be
      removed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="764" id="764">764</a></td>
<td><pre>   switch statement does not have a case -- A switch statement has
      been found that does not have a case statement associated with it
      (it may or may not have a default statement).  This is normally a
      useless construct.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="765" id="765">765</a></td>
<td><pre>   external 'Symbol' (Location) could be made static -- An external
      symbol was referenced in only one module.  It was not declared
      static (and its type is not qualified with the Microsoft keyword
      __export).  Some programmers like to make static every symbol
      they can, because this lightens the load on the linker.  It also
      represents good documentation.  On the other hand, you may want
      the symbol to remain external because debuggers often work only
      on external names.  It's possible, using macros, to have the best
      of both worlds.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="766" id="766">766</a></td>
<td><pre>   Header file FileName not used in module String -- The named
      header file was directly #include'd in the named module but the
      #include can be removed because it was not used in processing the
      named module or in any header included by the module.  It
      contained no macro, typedef, struct, union or enum tag or
      component, or declaration referenced by the module.  One of the
      reasons a particular #include can be removed is because it had
      been included by an earlier header file.  Warning 537 can be used
      to detect such cases.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="767" id="767">767</a></td>
<td><pre>   macro 'Symbol' was defined differently in another module
      (Location) -- Two macros processed in two different modules had
      inconsistent definitions.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="768" id="768">768</a></td>
<td><pre>   global struct member 'Symbol' (Location) not referenced -- A
      member (name provided as Symbol) of a struct or union appeared in
      a non-library header file but was not used in any module
      comprising the program.  This message is suppressed for unit
      checkout.  Since struct's may be replicated in storage, finding
      an unused member can pay handsome storage dividends.  However,
      many structures merely reflect an agreed upon convention for
      accessing storage and for any one program many members are
      unused.  In this case, receiving this message can be a nuisance.
      One convenient way to avoid unwanted messages (other than the
      usual -e and -esym) is to always place such structures in library
      header files.  Alternatively, you can place the struct within a
      ++flb ... --flb sandwich to force it to be considered library.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="769" id="769">769</a></td>
<td><pre>   global enumeration constant 'Symbol' (Location) not referenced --
      A member (name provided as Symbol) of an enum appeared in a
      non-library header file but was not used in any module comprising
      the program.  This message is suppressed for unit checkout.
      There are reasons why a programmer may occasionally want to
      retain an unused enum and for this reason this message is
      distinguished from 768 (unused member).  See message 768 for ways
      of selectively suppressing this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="770" id="770">770</a></td>
<td><pre>   tag 'Symbol' defined identically at Location -- The struct,
      union, or enum tag Symbol was defined identically in different
      locations (usually two different files).  This is not an error
      but it is not necessarily good programming practice either.  It
      is better to place common definitions of this kind in a header
      file where they can be shared among several modules.  If you do
      this, you will not get this message.  Note that if the tag is
      defined differently in different scopes, you will receive warning
      631 rather than this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="771" id="771">771</a></td>
<td><pre>   Symbol 'Symbol' (Location) conceivably not initialized -- The
      named symbol, declared at Location, was initialized in the main
      portion of a control loop (while, for, or do) and subsequently
      used outside the loop.  If it is possible for the main body of
      the loop to not be fully executed, then the given symbol would
      remain uninitialized resulting in an error.

      PC-lint/FlexeLint does not do a great job of evaluating
      expressions and hence may not recognize that a loop is executed
      at least once.  This is particularly true after initializing an
      array.  Satisfy yourself that the loop is executed and then
      suppress the message.  You may wish to suppress the message
      globally with -e771 or just for specific symbols using -esym.
      Don't forget that a simple assignment statement may be all that's
      needed to suppress the message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="772" id="772">772</a></td>
<td><pre>   Symbol 'Symbol' (Location) conceivably not initialized -- The
      address of the named Symbol was passed to a function expecting to
      receive a pointer to a const item.  This requires the Symbol to
      have been initialized.  See Warning 603 for an explanation of the
      dangers of such a construct.  See Informational message 771 for
      an explanation of "conceivably not initialized."

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="773" id="773">773</a></td>
<td><pre>   Expression-like macro 'Symbol' not parenthesized -- A macro that
      appeared to be an expression contained unparenthesized binary
      operators and therefore may result in unexpected associations
      when used with other operators.  For example,

            #define A  B + 1

      may be used later in the context:

            f( A * 2 );

      with the surprising result that B+2 gets passed to f and not the
      (B+1)*2 corrective action is to define A as:

            #define A  (B + 1)

      Lowest precedence binary operators are not reported upon.  Thus:

            #define A  s.x

      does not elicit this message because this case does not seem to
      represent a problem.  Also, unparenthesized unary operators
      (including casts) do not generate this message.  Information
      about such unparenthesized parameters can be found by enabling
      Elective Note 973.  [22, 20.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="774" id="774">774</a></td>
<td><pre>   Boolean within 'String' always evaluates to [True/False] -- The
      indicated clause (String is one of if, while or for (2nd
      expression)) has an argument that appears to always evaluate to
      either 'True' or 'False' (as indicated in the message).
      Information is gleaned from a variety of sources including prior
      assignment statements and initializers.  Compare this with
      message 506 which is based on testing constants or combinations
      of constants.  Also compare with the Elective Note 944 which can
      sometimes provide more detailed information.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="775" id="775">775</a></td>
<td><pre>   non-negative quantity cannot be less than zero -- A non-negative
      quantity is being compared for being &lt;=0.  This is a little
      suspicious since a non-negative quantity can be equal to 0 but
      never less than 0.  The non-negative quantity may be of type
      unsigned or may have been promoted from an unsigned type or may
      have been judged not to have a sign by virtue of it having been
      AND'ed with a quantity known not to have a sign bit an enum that
      may not be negative, etc.  See also Warning 568.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="776" id="776">776</a></td>
<td><pre>   Possible truncation of addition -- An int expression (signed or
      unsigned) involving addition or subtraction is converted to long
      implicitly or explicitly.  Moreover, the precision of a long is
      greater than that of int.  If an overflow occurred, information
      would be lost.  Either cast one of the operands to some form of
      long or cast the result to some form of int.

      See Warning 647 for a further description and an example of this
      kind of error.  See also 790 and 942.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="777" id="777">777</a></td>
<td><pre>   Testing float's for equality -- This message is issued when the
      operands of operators == and != are some form of floating type
      (float, double, or long double).  Testing for equality between
      two floating point quantities is suspect because of round-off
      error and the lack of perfect representation of fractions.  If
      your numerical algorithm calls for such testing turn the message
      off.  The message is suppressed when one of the operands can be
      represented exactly, such as 0 or 13.5.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="778" id="778">778</a></td>
<td><pre>   Constant expression evaluates to 0 in operation: String -- A
      constant expression involving addition, subtraction,
      multiplication, shifting, or negation resulted in a 0.  This
      could be a purposeful computation but could also have been
      unintended.  If this is intentional, suppress the message.  If
      one of the operands is 0 Elective Note 941 may be issued rather
      than a 778.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="779" id="779">779</a></td>
<td><pre>   String constant in comparison operator: Operator -- A string
      constant appeared as an argument to a comparison operator.  For
      example:

            if( s == "abc" ) ...

      This is usually an error.  Did the programmer intend to use
      strcmp?  It certainly looks suspicious. At the very least, any
      such comparison is bound to be machine-dependent.  If you cast
      the string constant, the message is suppressed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="780" id="780">780</a></td>
<td><pre>   Vacuous array element -- A declaration of an array looks
      suspicious because the array element is an array of 0 dimension.
      For example:

            extern int a[][];
            extern int a[10][];

      will both emit this message but

            extern int a[][10];

      will not.  In the latter case, proper array accessing will take
      place even though the outermost dimension is missing.

      If extern were omitted, the construct would be given a more
      serious error message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="782" id="782">782</a></td>
<td><pre>   Line exceeds Integer characters -- An internal limit on the size
      of the input buffer has been reached.  The message contains the
      maximum permissible size.  This does not necessarily mean that
      the input will be processed erroneously.  Additional characters
      will be read on a subsequent read.  However the line sequence
      numbers reported on messages will be incorrect.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="783" id="783">783</a></td>
<td><pre>   Line does not end with new-line -- This message is issued when an
      input line is not terminated by a new-line or when a NUL
      character appears within an input line.  When input lines are
      read, an fgets is used.  A strlen call is made to determine the
      number of characters read.  If the new-line character is not seen
      at the presumed end, this message is issued.  If your editor is
      in the habit of not appending new-lines onto the end of the last
      line of the file then suppress this message.  Otherwise, examine
      the file for NUL characters and eliminate them.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="784" id="784">784</a></td>
<td><pre>   Nul character truncated from string -- During initialization of
      an array with a string constant there was not enough room to hold
      the trailing NUL character.  For example:

            char a[3] = "abc";

      would evoke such a message.  This may not be an error since the
      easiest way to do this initialization is in the manner indicated.
      It is more convenient than:
            char a[3] = { 'a', 'b', 'c' };

      On the other hand, if it really is an error it may be especially
      difficult to find.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="785" id="785">785</a></td>
<td><pre>   Too few initializers for aggregate 'Symbol' -- The number of
      initializers in a brace-enclosed initializer was less than the
      number of items in the aggregate.  Default initialization is
      taken.  An exception is made with the initializer {0}.  This is
      given a separate message number in the Elective Note category
      (943).  It is normally considered to be simply a stylized way of
      initializing all members to 0.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="786" id="786">786</a></td>
<td><pre>   String concatenation within initializer -- Although it is
      perfectly 'legal' to concatenate string constants within an
      initializer, this is a frequent source of error.  Consider:

            char *s[] = { "abc" "def" };

      Did the programmer intend to have an array of two strings but
      forget the comma separator?  Or was a single string intended?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="787" id="787">787</a></td>
<td><pre>   enum constant 'Symbol' not used within switch -- A switch
      expression is an enumerated type and at least one of the
      enumerated constants was not present as a case label.  Moreover,
      no default case was provided.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="788" id="788">788</a></td>
<td><pre>   enum constant 'Symbol' not used within defaulted switch -- A
      switch expression is an enumerated type and at least one of the
      enumerated constants was not present as a case label.  However,
      unlike Info 787, a default case was provided.  This is a mild
      form of the case reported by Info 787.  The user may thus elect
      to inhibit this mild form while retaining Info 787.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="789" id="789">789</a></td>
<td><pre>   Assigning address of auto variable 'Symbol' to static -- The
      address of an auto variable (Symbol) is being assigned to a
      static variable.  This is dangerous because the static variable
      will persist after return from the function in which the auto is
      declared but the auto will be, in theory, gone.  This can prove
      to be among the hardest bugs to find.  If you have one of these,
      make certain there is no error and use -esym to suppress the
      message for a particular variable.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="790" id="790">790</a></td>
<td><pre>   Suspicious truncation, integral to float. -- This message is
      issued when it appears that there may have been an unintended
      loss of information during an operation involving integrals the
      result of which is later converted to a floating point quantity.
      The operations that are scrutinized and reported upon by this
      message are:  shift left and multiplication. Addition and
      subtraction are covered by Elective Note 942. See also 647 and
      776.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="791" id="791">791</a></td>
<td><pre>   unusual option sequence -- A temporary message suppression option
      (one having the form:  !e...) followed a regular option.  Was
      this intended?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="792" id="792">792</a></td>
<td><pre>   void cast of void expression -- A void expression has been cast
      to void.  Was this intended?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="793" id="793">793</a></td>
<td><pre>   ANSI limit of String 'String' 'Name' exceeded -- processing is
      unaffected -- Some ANSI limit has been exceeded.  These limits
      are described in Section 2.2.4.1 of the ANSI C Standard.
      Programs exceeding these limits are not considered maximally
      portable.  However, they may work for individual compilers.

      Many large programs exceed the ANSI limit of 511 external
      identifiers.  This will result in message 793  "ANSI limit of 511
      'external identifiers' exceeded".  It may not be obvious how to
      inhibit this message for identifiers while leaving other limits
      in a reportable state.  The second parameter of the message is
      designated Name and so the -esym may be used.  Because the symbol
      contains a blank, quotes must be used.  The option becomes:

            -"esym(793,external identifiers)"

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="794" id="794">794</a></td>
<td><pre>   Conceivable use of null pointer 'Symbol' in [left/right] argument
      to operator 'String' Reference -- From information gleaned from
      earlier statements it is conceivable that a null pointer (a
      pointer whose value is 0) can be used in a context where null
      pointers are inappropriate.  In the case of binary operators one
      of the words 'left' or 'right' is used to designate which operand
      is null.  Symbol identifies the pointer variable that may be
      NULL.  This is similar to messages 413 and 613 and differs from
      them in that the likelihood is not as great.  For example:
     
                int *p = 0;
                int i;
                for( i = 0; i &lt; n; i++ )
                    p = &amp;a[i];
                *p = 0;

      If the body of the for loop is never taken then p remains null.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="795" id="795">795</a></td>
<td><pre>   Conceivable division by 0 -- In a division or modulus operation
      the division is deduced to be conceivably 0.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="796" id="796">796</a></td>
<td><pre>   Conceivable access of out-of-bounds pointer ('Integer' beyond end
      of data) by operator 'String' -- An out-of-bounds pointer may
      conceivably have been accessed.  See message 415 for a
      description of the parameters Integer and String.  For example:
     
                int a[10];
                int j = 100;
                for( i = 0; i &lt; n; i++ )
                    j = n;
                a[j] = 0;

      Here, the access to a[j] is flagged because it is conceivable
      that the for loop is not executed leaving the unacceptable index
      of 100 in variable j.  This message is similar to messages 415
      and 661 but differing from them by the degree of probability.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="797" id="797">797</a></td>
<td><pre>   Conceivable creation of out-of-bounds pointer ('Integer' beyond
      end of data) by operator 'String' -- An out-of-bounds pointer is
      potentially being created.  See message 415 for a description of
      the parameters Integer and String.  See message 796 for an
      example of how a probability can be considered 'conceivable'.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="798" id="798">798</a></td>
<td><pre>   Redundant character 'Char' -- The indicated character char is
      redundant and can be eliminated from the input source.  A typical
      example is a backslash on a line by itself.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="799" id="799">799</a></td>
<td><pre>   numerical constant 'Integer' larger than unsigned long -- An
      integral constant was found to be larger than the largest value
      allowed for unsigned long quantities.  By default, an unsigned
      long is 4 bytes but can be respecified via the option -sl#.  If
      the long long type is permitted (see option +fll) this message is
      automatically suppressed.  See also message 417.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="801" id="801">801</a></td>
<td><pre>   Use of goto is deprecated -- A goto was detected.  Use of the
      goto is not considered good programming practice by most authors
      and its use is normally discouraged.  There are a few cases where
      the goto can be effectively employed but often these can be
      rewritten just as effectively without the goto.  The use of
      goto's can have a devastating effect on the structure of large
      functions creating a mass of spaghetti-like confusion.  For this
      reason its use has been banned in many venues.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="802" id="802">802</a></td>
<td><pre>   Conceivably passing a null pointer to function 'Symbol', Context
      Reference -- A NULL pointer is conceivably being passed to a
      function identified by Symbol.  The argument in question is given
      by Context.  The function is either a library function designed
      not to receive a NULL pointer or a user function dubbed so via
      the option -function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="803" id="803">803</a></td>
<td><pre>   Conceivable data overrun for function 'Symbol', argument Integer
      exceeds argument Integer Reference -- This message is for data
      transfer functions such as memcpy, strcpy, fgets, etc. when the
      size indicated by the first cited argument (or arguments) can
      conceivably exceed the size of the buffer area cited by the
      second.  The message may also be issued for user functions via
      the -function option.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="804" id="804">804</a></td>
<td><pre>   Conceivable access beyond array for function 'Symbol', argument
      Integer exceeds Integer Reference -- This message is issued for
      several library functions (such as fwrite, memcmp, etc) wherein
      there is conceivably an attempt to access more data than exist.
      For example, if the length of data specified in the fwrite call
      can exceed the size of the data specified.  The function is
      specified by Symbol and the arguments are identified by argument
      number.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="805" id="805">805</a></td>
<td><pre>   Expected L"..." to initialize wide char string -- An initializer
      for a wide character array or pointer did not use a preceding
      'L'.  For example:

                wchar_t a[] = "abc";

      was found whereas

                wchar_t a[] = L"abc":

      was expected.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="806" id="806">806</a></td>
<td><pre>   Small bit field is signed rather than unsigned -- A small bit
      field (less than an int wide) was found and the base type is
      signed rather than unsigned.  Since the most significant bit is a
      sign bit this practice can produce surprising results.  For
      example,
     
        struct { int b:1; } s;
        s.b = 1;
        if( s.b &gt; 0 ) /* should succeed but actually fails */
            ...

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="807" id="807">807</a></td>
<td><pre>   Conceivably passing to function 'Symbol' a negative value
      (Integer), Context Reference -- An integral value that may
      conceivably be negative is being passed to a function that is
      expecting only positive values for a particular argument.  The
      message contains the name of the function (Symbol), the
      questionable value (Integer) and the argument number (Context).
      The function may be a standard library function designed to
      accept only positive values such as malloc or memcpy (third
      argument), or may have been identified by the user as such
      through the -function or -sem options.  See message 422 for an
      example and further explanation.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="808" id="808">808</a></td>
<td><pre>   No explicit type given symbol 'Sybmol', assumed int -- An
      explicit type was missing in a declaration.  Unlike Warning 601,
      the declaration may have been accompanied by a storage class or
      modifier (qualifier) or both.  For example:
     
                extern f(void);

      will draw message 808.  Had the extern not been present, a 601
      would have been raised.

      The keywords unsigned, signed, short and long are taken to be
      explicit type specifiers even though int is implicitly assumed as
      a base.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="809" id="809">809</a></td>
<td><pre>   Possible return of address of auto through variable 'Symbol' --
      The value held by a pointer variable may have been the address of
      an auto variable.  It is normally incorrect to return the address
      of an item on the stack because the portion of the stack
      allocated to the returning function is subject to being
      obliterated after return.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="810" id="810">810</a></td>
<td><pre>   Arithmetic modification of custodial pointer 'Symbol' --
      810,Arithmetic modification of custodial pointer 'Symbol' We
      define the custodial variable as that variable directly receiving
      the result of a malloc or new or equivalent call.  It is
      inappropriate to modify such a variable because it must
      ultimately be free'ed or delete'ed.  You should first make a copy
      of the custodial pointer and then modify the copy.  The copy is
      known as an alias.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="811" id="811">811</a></td>
<td><pre>   Possible deallocation of pointer alias -- A free or a delete was
      applied to a pointer that did not appear to be the custodial
      variable of the storage that had been allocated.  Please refer to
      message 810 for the definition of 'custodial variable'.  Deleting
      an alias pointer is bad because it can result in deleting the
      same area twice.  This can cause strange behavior at
      unpredictable times.  Always try to identify the custodial
      pointer as opposed to copies (or aliases) of it.  Then deallocate
      storage through the custodial pointer.  Modify only the alias
      pointers.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="812" id="812">812</a></td>
<td><pre>   static variable 'Symbol' has size 'Integer' -- The amount of
      storage for a static symbol has reached or exceeded a value that
      was specified in a -size option (See Section 5.7, "Other
      Options").

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="813" id="813">813</a></td>
<td><pre>   auto variable 'Symbol' in function 'Symbol' has size 'Integer' --
      The amount of storage for an auto symbol has reached or exceeded
      a value that was specified in a -size option (See Section 5.7,
      "Other Options").

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="814" id="814">814</a></td>
<td><pre>   useless declaration -- A tagless struct was declared without a
      declarator.  For example:
     
          struct { int n; };
     
      Such a declaration cannot very well be used.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="815" id="815">815</a></td>
<td><pre>   Arithmetic modification of unsaved pointer -- An allocation
      expression (malloc, calloc, new) is not immediately assigned to a
      variable but is used as an operand in some expression.  This
      would make it difficult to free the allocated storage.  For
      example:

            p = new X[n] + 2;

      will elicit this message.  A preferred sequence is:

            q = new X[n];
            p = q+2;

      In this way the storage may be freed via the custodial pointer q.

      Another example of a statement that will yield this message is:

            p = new (char *) [n];

      This is a gruesome blunder on the part of the programmer.  It
      does NOT allocate an array of pointers as a novice might think.
      It is parsed as:

            p = (new (char *)) [n];

      which represents an allocation of a single pointer followed by an
      index into this 'array' of one pointer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="816" id="816">816</a></td>
<td><pre>   Non-ANSI format specification -- A non-standard format specifier
      was found in a format-processing function such as printf or
      scanf.  Such a specifier could be unique to a particular compiler
      or could be a de facto standard but is not ANSI.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="817" id="817">817</a></td>
<td><pre>   Conceivably negative subscript (Integer) in operator 'String' --
      An integer whose value was conceivably negative was added to an
      array or to a pointer to an allocated area (allocated by malloc,
      operator new, etc.) This message is not given for pointers whose
      origin is unknown since a negative subscript is in general legal.

      The addition could have occurred as part of a subscript operation
      or as part of a pointer arithmetic operation.  The operator is
      denoted by String.  The value of the integer is given by Integer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="818" id="818">818</a></td>
<td><pre>   Pointer parameter 'Symbol' (Location) could be declared ptr to
      const -- As an example:

         int f( int *p ) { return *p; }

      can be redeclared as:

         int f( const int *p ) { return *p; }

      Declaring a parameter a pointer to const offers advantages that a
      mere pointer does not.  In particular, you can pass to such a
      parameter the address of a const data item.  In addition it can
      offer better documentation.

      Other situations in which a const can be added to a declaration
      are covered in messages 952, 953, 954 and 1764.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="820" id="820">820</a></td>
<td><pre>   Boolean test of a parenthesized assignment -- A Boolean test was
      made on the result of an assignment and, moreover, the assignment
      was parenthesized.  For example:

            if ( (a = b) ) ...  // Info 820

      will draw this informational whereas

            if ( a = b ) ...    // Info 720

      (i.e. the unparenthesized case) will, instead, draw Info 720.
      We, of course, do not count the outer parentheses required by the
      language that always accompany the if clause.

      The reason for partitioning the messages in this fashion is to
      allow the programmer to adopt the convention, advanced by some
      compilers (in particular gcc), of always placing a redundant set
      of parentheses around any assignment that is to be tested.  In
      this case you can suppress Info 820 (via -e820) while still
      enabling Info 720.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="821" id="821">821</a></td>
<td><pre>   Right hand side of assignment not parenthesized -- An assignment
      operator was found having one of the following forms:
     
            a = b || c
            a = b &amp;&amp; c
            a = b ? c : d

      Moreover, the assignment appeared in a context where a value was
      being obtained.  For example:

            f( a = b ? c : d );

      The reader of such code could easily confuse the assignment for a
      test for equality.  To eliminate any such doubts we suggest
      parenthesizing the right hand side as in:

            f( a = (b ? c : d) );

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="825" id="825">825</a></td>
<td><pre>   control flows into case/default without -fallthrough comment -- A
      common programming mistake is to forget a break statement between
      case statements of a switch.  For example:
     
        case 'a':  a = 0;
        case 'b':  a++;

      Is the fall through deliberate or is this a bug?  To signal that
      this is intentional use the -fallthrough option within a lint
      comment as in:
     
        case 'a':  a = 0;
            //lint -fallthrough
        case 'b':  a++;

      This message is similar to Warning 616 ("control flows into
      case/default") and is intended to provide a stricter alternative.
      Warning 616 is suppressed by any comment appearing between the
      case's.  Thus, an accidental omission of a break can go
      undetected by the insertion of a neutral comment.  This can be
      hazardous to well-commented programs.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="826" id="826">826</a></td>
<td><pre>   Suspicious pointer-to-pointer conversion (area too small) -- A
      pointer was converted into another either implicitly or
      explicitly.  The area pointed to by the destination pointer is
      larger than the area that was designated by the source pointer.
      For example:

            long *f( char *p ) { return (long *) p; }

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="827" id="827">827</a></td>
<td><pre>   Loop not reachable -- A loop structure (for, while, or do) could
      not be reached.  Was this an oversight?  It may be that the body
      of the loop has a labeled statement and that the plan of the
      programmer is to jump into the middle of the loop through that
      label.  It is for this reason that we give an Informational
      message and not the Warning (527) that we would normally deliver
      for an unreachable statement.  But please note that jumping into
      a loop is a questionable practice in any regard.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="828" id="828">828</a></td>
<td><pre>   Semantics of function 'Name' copied to function 'Name' -- A
      function with built-in semantics or user-defined semantics was
      #define'd to be some other function with a similar name formed by
      prepending or appending underscores.  For example:

            #define strcmp(a,b) __strcmp__(a,b)

      will cause Info 828 to be issued.  As the message indicates, the
      semantics will be automatically transferred to the new function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="829" id="829">829</a></td>
<td><pre>   A +headerwarn option was previously issued for header 'Symbol --
      Some coding standards discourage or even prohibit the use of
      certain header files.  PC-lint can guard against their use if we
      by activating the lint option +headerwarn(Symbol).  Later, if the
      file is used, we will then issue this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="830" id="830">830</a></td>
<td><pre>   Location cited in prior message -- Message 830 is a vehicle to
      convey in 'canonical form' the location information embedded
      within some other message.  For example, consider the (somewhat
      simplified) message:

     
      file x.c line 37:  Declaration for 'x' conflicts with line 22
     

      This contains the location ("line 22") embedded in the text of
      the message.  Embedded location information is not normally
      understood by editors and IDE's (Interactive Development
      Environments) which can only position to the nominal location
      (line 37 in this example).  By adding this additional message
      with the nominal location of line 22 the user can, by stepping to
      the next message and, in this case, see what the 'conflict' is
      all about.  This message and message 831 below do not follow the
      ordinary rules for message suppression.  If they did then when
      the option -w2 was employed to turn the warning level down to 2
      these messages (at level 3) would also vanish.  Instead they
      continue to function as expected.  To inhibit them you need to
      explicitly turn them off using one of:
     
          -e830
          -e831
     
      They may be restored via +e830 and +e831;  they state of
      suppression can be saved and restored via the -save -restore
      options.  Options such as -e8* and -e{831} will have no effect.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="831" id="831">831</a></td>
<td><pre>   Reference cited in prior message -- Message 831 is similar to
      message 830 in that it is a vehicle to convey in 'canonical form'
      location information embedded within some other message.  In the
      case of Info 831 the information is 'Reference' information.
      This is a sequence of 1 or more locations that support a
      particular message.  For example, consider the (somewhat
      simplified) message:

     
          file y.c line 701:  Possible divide by 0 [Reference: file z.c lines 22, 23]
     

      Accompanying this message will be two Info 831 messages, one for
      each of the references cited in the message.  Without this it
      would be a relatively tedious matter to locate each one of the
      references to determine just why there is a potential divide by
      0.  With these additional messages, editors and IDE's can
      automatically position the focus of editing to the nominal
      locations of the message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="832" id="832">832</a></td>
<td><pre>   Parameter 'Symbol' not explicitly declared, int assumed -- In an
      old-style function definition a parameter was not explicitly
      declared.  To illustrate:
     
        void f( n, m )
            int n;
            { ...

      This is an example of an old-style function definition with n and
      m the parameters.  n is explicitly declared and m is allowed to
      default to int.  An 832 will be issued for m.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="833" id="833">833</a></td>
<td><pre>   Symbol 'Symbol' is typed differently (String) in another module,
      Location, -- Two objects, functions or definials are typed
      differently in two different modules.  This is a case where the
      difference is legal but may cause confusion on the part of
      program maintenance.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="834" id="834">834</a></td>
<td><pre>   Operator 'Name' followed by operator 'Name' is confusing.  Use
      parentheses. -- Some combinations of operators seem to be
      confusing.  For example

             a = b - c - d;
             a = b - c + d;
             a = b / c / d;
             a = b / c * d;

      tend to befuddle the reader.  To reduce confusion we recommend
      using parentheses to make the association of these operators
      explicit.  For example:

             a = (b - c) - d;
             a = (b - c) + d;
             a = (b / c) / d;
             a = (b / c) * d;

      in place of the above.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="835" id="835">835</a></td>
<td><pre>   A zero has been given as [left/right] argument to operator 'Name'
      -- A 0 has been provided as an operand to an arithmetic operator.
      The name of the operator is provided in the message as well as
      the side of the operator (left or right) that had the unusual
      value.  For example:
     
              n = n + 0 - m;
     
      will produce a message that the right hand operand of operator
      '+' is zero.

      In general the operators examined are the binary operators:
     
              + - * / % | &amp; ^ &lt;&lt; &gt;&gt;
     
      and the unary operators - and +.

      An enumeration constant whose value is 0 is permitted with
      operators:
     
              + - &gt;&gt; &lt;&lt;
     
      Otherwise a message is issued.  For example:
     
              enum color { red,
                           blue = red+100,        /* ok */
                           green= red*0x10        /* 835 */
                         };
     
      The assignment operators that have an arithmetic or bitwise
      component, such as |=, are also examined.  The message given is
      equivalent to that given with the same operator without the
      assignment component.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="836" id="836">836</a></td>
<td><pre>   Conceivable access of pointer pointing Integer bytes past nul
      character by operator 'String' -- A situation was detected where
      it appears remotely possible that a buffer is being accessed
      beyond the (nul-terminated) string that was placed in the buffer.
      An example of accessing beyond the nul character is shown in the
      example below:
     
              char buf[20];
              int k = 4;
              strcpy( buf, "a" );
              if( buf[k] ==  'a' ) ... // legal but suspect
     
      In this particular case the access would be deemed 'likely' and a
      different but related message (<ref,warning 448="" in="" section="" 13.3,13.3="">) would have been issued.  This message (836) could be
      issued if there were some intervening code involving k.  See also
      <ref,warning 690="" in="" section="" 13.3,13.3="">.

</ref,warning></ref,warning></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="838" id="838">838</a></td>
<td><pre>   Previously assigned value to variable 'Symbol' has not been used
      -- An assignment statement was encountered that apparently
      obliterated a previously assigned value that had never had the
      opportunity of being used.  For example, consider the following
      code fragment:
     
              y = 1;
              if( n &gt; 0 ) y = 2;
              y = 4;              // Info 838
              ...
     
      Here we can report that the assignment of 4 to y obliterates
      previously assigned values that were not used.  We, of course,
      cannot report anything unusual about the assignment of 2.  This
      will assign over a prior value of 1 that so far had not been used
      but the existence of an alternative path means that the value of
      1 can still be employed later in the code and is accepted for the
      time being as reasonable.  It is only the final assignment that
      raises alarm bells.  See also <ref,warning 438="" in="" section="" 13.3,13.3="">.

</ref,warning></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="839" id="839">839</a></td>
<td><pre>   Storage class of symbol 'Symbol' assumed static (Location) -- A
      declaration for a symbol that was previously declared static in
      the same module was found without the 'static' specifier.  For
      example:
     
              static void f();
              extern void f();    // Info 839
              void f() {}         // Info 839
     
      By the rules of the language 'static' wins and the symbol is
      assumed to have internal linkage.  This could be the definition
      of a previously declared static function (as in line 3 of the
      above example) in which case by adding the static specifier you
      will inhibit this message.  This could also be a redeclaration of
      either a function or a variable (as in line 2 of the above
      example) in which case the redeclaration is redundant.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="840" id="840">840</a></td>
<td><pre>   Use of nul character in a string literal -- A nul character was
      found in a string literal.  This is legal but suspicious and may
      have been accidental.  This is because a nul character is
      automatically placed at the end of a string literal and because
      conventional usage and most of the standard library's string
      functions ignore information past the first nul character.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="843" id="843">843</a></td>
<td><pre>   Variable 'Symbol' (Location) could be declared as const -- A
      variable of static storage duration is initialized but never
      modified thereafter.  Was this an oversight? If the intent of the
      programmer is to not modify the variable, it could and should be
      declared as const.  See [30, Item 3] in Section <ref,14. added="" bibliography,14.=""> and message 844.

</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="844" id="844">844</a></td>
<td><pre>   Pointer variable 'Symbol' (Location) could be declared as
      pointing to const -- The data pointed to by a pointer of static
      storage duration is never changed (at least not through that
      pointer).  It therefore would be better if the variable were
      typed pointer to const.  See [30, Item 3] in Section <ref,14. added="" bibliography,14.=""> and message 843.

</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="845" id="845">845</a></td>
<td><pre>   The [left/right] argument to operator 'Name' is certain to be 0
      -- An operand that can be deduced to always be 0 has been
      presented to an arithmetic operator in a context that arouses
      suspicion.  The name of the operator is provided in the message
      as well as the side of the operator (left or right) that had the
      unusual value.  For example:
     
              n = 0;
              k = m &amp; n;
     
      will produce a message that the right hand operand of operator
      '&amp;' is certain to be zero.

      The operands examined are the right hand sides of operators
     
              + - | ||
     
      the left hand sides of operators
     
              / %
     
      and both sides of operators
     
              * &amp; &lt;&lt; &gt;&gt; &amp;&amp;
     
      The reason that the left hand side of operator + (and friends) is
      not examined for zero is that zero is the identity operation for
      those operators and hence is often used as an initializing value.
      For example:
     
              sum = 0;
              for( ... )
                  sum = sum + what_ever;       // OK, no message
     
      The message is not issued for arithmetic constant zeros.
      <ref,info 835="" in="" section="" 13.4,13.4=""> is issued in that instance.

      The message is also suspended when the expression has
      side-effects.  For example:
     
              i = 0;
              buf[i++] = 'A';
     
      We don't consider it reasonable to force the programmer to write:
     
              buf[0] = 'A';
              i = 1;
     
</ref,info></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="846" id="846">846</a></td>
<td><pre>   Signedness of bit-field is implementation defined -- A bit-field
      was detected having the form:
     
              int a:5;
     
      Most bit fields are more useful when they are unsigned.  If you
      want to have a signed bit field you must explicitly indicate this
      as follows:
     
              signed int a:5;
     
      The same also holds for typedef's.  For example,
     
              typedef int INT;
              typedef signed int SINT;
              struct  {
                      INT a:16;   // Info 846
                      SINT b:16;  // OK
                      }:
     
      It is very unusual in C or C++ to distinguish between signed int
      and just plain int.  This is one of those rare cases.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="847" id="847">847</a></td>
<td><pre>   Thread 'Symbol' has unprotected call to thread unsafe function
      'Symbol' -- A thread named in the message makes an unprotected
      call (i.e., outside of a critical section) on the function named
      in the message.  The function had previously been identified as
      thread unsafe.  See Section <ref,8. mult-thread="" support,8.=""> for a
      definition of the terms: unprotected and thread unsafe.

      This is not necessarily an error.  Most thread unsafe functions
      may be called outside of critical sections provided no other
      thread is making such a call.  There are other messages (at the
      Warning level) that will be issued when some other thread is also
      calling the same function, so it would normally be safe to
      suppress this message.

</ref,8.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="848" id="848">848</a></td>
<td><pre>   Worst case function for stack usage: String -- This message,
      issued at global wrap-up, will report on the function that
      requires the most stack.  The stack required consists of the
      amount of auto storage the function requires plus the amounts
      required in any chain of functions called.  The worst case chain
      is always reported.

      To obtain a report of all the function use the option
      -ok(filename).

      Reasonable allowances are made for function call overhead and the
      stack requirements of external functions.  These assumptions can
      be controlled via the -stack option.

      If recursion is detected it will be reported here as this is
      considered worse than any finite case.  The next worse case is
      that the stack can't be determined because a function makes a
      call through a function pointer.  The function is said to be
      non-deterministic.  If neither if these conditions prevail, the
      function that heads the worst case chain of calls will be
      reported upon.

      The message will normally provide you with the name of a called
      function.  If the function is recursive this will provide you
      with the first call of a recursive loop.  To determine the full
      loop, use option -ok(filename) which will contain a record for
      each function for which a definition was found.  You will be able
      to follow the chain of calls to determine the recursive path.

      If you can assure yourself through code analysis that there is an
      upper bound to the amount of stack utilized by some recursive
      function then you can employ the -stack option to specify this
      bound.  The function will no longer be considered recursive but
      rather finite.  In this way, possibly through a sequence of
      options, you can progressively eliminate apparent recursion and
      in that way arrive at a safe upper bound for stack usage.
      Similar considerations apply for non-deterministic functions.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="849" id="849">849</a></td>
<td><pre>   Symbol 'Symbol' has same enumerator value 'String' as enumerator
      'Symbol' -- Two enumerators have the same value.  For example:
     
          enum colors { red, blue, green = 1 };
     
      will elicit this informational message.  This is not necessarily
      an error and you may want to suppress this message for selected
      enumerators.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="850" id="850">850</a></td>
<td><pre>   for loop index variable 'Symbol' whose type category is 'String'
      modified in body of the for loop that began at 'String' -- Note:
      This message is delivered after the for loop has been completed.

      A for loop with an identifiable loop index variable was
      programmed in such a way that the loop body also modifies the
      index variable.  For example:
     
              for( i = 0; i &lt; 100; i++ )
                  {
                  a[i++] = 0;
                  }
     
      In general it is better to restrict modifications to for loop
      index variables to the for clause if at all possible.  If this is
      not possible, you can prefix the for loop with an appropriate
      lint comment such as:
     
              /*lint -e{850} i is modified in the body of the for loop */
     
      The message is parameterized with a type category which is one
      of:

        integral some form of integer
        float some form of floating point number
        string some form of char * including wide char
        pointer some form of pointer other than string
        enumeration an enumeration of some kind
        unclassified none of the above

      This will allow you to be more selective in the delivery of
      messages because you may suppress or enable messages according to
      these classifications.  For example:
     
            -e850
            +estring(850,integral)
            +estring(850,float)
     
      will enable Info 850 for integrals or for floats but not for
      other forms of loop variables.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="864" id="864">864</a></td>
<td><pre>   Expression involving variable 'Symbol' possibly depends on order
      of evaluation -- The variable cited in the message is either
      passed to a reference that is not a const reference or its
      address is passed to a pointer that is not a pointer to const.
      Hence the variable is potentially modified by the function.  If
      the same variable is used elsewhere in the same expression, then
      the result may depend on the order of evaluation of the
      expression.  For example:
     
              int g( int );
              int h( int &amp; );
              int f( int k )
                  {
                  return g(k) + h(k);   // Info 864
                  }
     
      Here the compiler is free to evaluate the call to g() first with
      the original value of k and then call h() where k gets modified.
      Alternatively, it can, with equal validity, call h() first in
      which case the value passed to g() would be the new value.

      The object being modified could be the implicit argument (the
      this argument) to a member function call. For example:
     
              void f( int, int );
              class X { public: int bump(); int k; };
              ...
              X x;
              f( x.bump(), x.bump() );  // Info 864
     
      Here the message states that the expression involving object x
      possibly depends on the order of evaluation.  x is an implicit
      argument (by reference) to the bump() member function.  If the
      member function bump() were declared const then the message would
      not have been emitted.

      (See also 11.1 Order of Evaluation in the manual and Warning
      564).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="866" id="866">866</a></td>
<td><pre>   Unusual use of 'String' in argument to sizeof -- An expression
      used as an argument to sizeof() counts as "unusual" if it is not
      a constant, a symbol, a function call, a member access, a
      subscript operation (with indices of zero or one), or a
      dereference of the result of a symbol, scoped symbol, array
      subscript operation, or function call.  Also, since unary '+'
      could legitimately be used to determine the size of a promoted
      expression, it does not fall under the category of "unusual".
      Example:
     
           char A[10];
           unsigned end = sizeof(A - 1);      // 866; Programmer probably meant
                                              //  'sizeof(A) - 1'
           size_of_promoted_char =
                              sizeof(+A[0]);  // '+' makes a difference here
           size_t s1 = sizeof( end+1 );       // 866: use +end to get promoted type
           size_t s2 = sizeof( +(end+1) );    // OK, we won't complain
           struct B *p;                       // B is some POD.
           B b1;

           memcpy( p, &amp;b1, sizeof(&amp;b1) );     // 866; intended to take sizeof(b1)

           size_t s3 = sizeof(A[0]);          // OK, get the size of an element.
           size_t s4 = sizeof(A[2]);          // 866; Not incorrect, but ...
                                              // unusual in a sizeof().
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="867" id="867">867</a></td>
<td><pre>   Unrecognized pragma 'Name' will be ignored -- The first
      identifier after #pragma is considered the name of the pragma.
      If the name is unrecognized then the remainder of the line is
      ignored.  Since the purpose of #pragma is to allow for
      compiler-dependent communication it is not really expected that
      all pragmas will be understood by all third-party processors of
      the code.  Thus, this message does not necessarily indicate that
      there is anything wrong and could easily be supressed entirely.

      Moreover, if the pragma occurs in a libary header this message
      would not normally be issued because the option -wlib(1) would be
      in effect (this option is present in all of our compiler option
      files).

      But if the pragma occurs in user code then it should be examined
      to see if there is something there that might interest a lint
      processor.  There are a variety of facilities to deal with
      pragmas; in particular, they can be mapped into languistic
      constructs or lint options or both.  See <ref,3.5 pragmas="" push_macro="" and="" pop_macro,3.5=""> and <ref,3.6 casting="" pragmas="" as="" macros,3.6="">.


                  ------ 19.6 C Elective Notes ------

</ref,3.6></ref,3.5></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="900" id="900">900</a></td>
<td><pre>   Successful completion, 'Integer' messages produced -- This
      message exists to provide some way of ensuring that an output
      message is always produced, even if there are no other messages.
      This is required for some windowing systems.  For this purpose
      use the option +e900.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="904" id="904">904</a></td>
<td><pre>   Return statement before end of function 'Symbol' -- A return
      statement was found before the end of a function definition.
      Many programming standards require that functions contain a
      single exit point located at the end of the function.  This can
      enhance readability and may make subsequent modification less
      error prone.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="905" id="905">905</a></td>
<td><pre>   Non-literal format specifier used (with arguments) -- A
      printf/scanf style function received a non-literal format
      specifier but, unlike the case covered by <ref,warning 592="" in="" section="" 13.3,13.3=""> the function also received additional
      arguments.  E.g.
     
              char *fmt;
              int a, b;
              ...
              printf( fmt, a, b );
     
      Variable formats represent a very powerful feature of C/C++ but
      they need to be used judiciously.  Unlike the case covered by
      Warning 592, this case cannot be easily rewritten with an
      explicit visible format.  But this Elective Note can be used to
      examine code with non-literal formats to make sure that no errors
      are present and that the formats themselves are properly
      constructed and contain no user-provided data.  See also
      <ref,warning 592="" in="" section="" 13.3,13.3="">

</ref,warning></ref,warning></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="909" id="909">909</a></td>
<td><pre>   Implicit conversion from Type to bool -- A non-bool was tested as
      a Boolean.  For example, in the following function:
     
        int f(int n)
            {
            if( n ) return n;
            else return 0;
            }

      the programmer tests 'n' directly rather than using an explicit
      Boolean expression such as 'n != 0'.  Some shops prefer the
      explicit test.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="910" id="910">910</a></td>
<td><pre>   Implicit conversion (Context) from 0 to pointer -- A pointer was
      assigned (or initialized) with a 0.  Some programmers prefer
      other conventions such as NULL or nil.  This message will help
      such programmers root out cavalier uses of 0.  This is relatively
      easy in C since you can define NULL as follows:

            #define NULL (void *)0

      However, in C++, a void* cannot be assigned to other pointers
      without a cast.  Instead, assuming that NULL is defined to be 0,
      use the option:

            --emacro((910),NULL)

      This will inhibit message 910 in expressions which use NULL.
      This method will also work in C.

      Both methods assume that you expressly turn on this message with
      a +e910 or equivalent.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="911" id="911">911</a></td>
<td><pre>   Implicit expression promotion from Type to Type -- Notes whenever
      a sub-integer expression such as a char, short, enum, or
      bit-field is promoted to int for the purpose of participating in
      some arithmetic operation or function call.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="912" id="912">912</a></td>
<td><pre>   Implicit binary conversion from Type to Type -- Notes whenever a
      binary operation (other than assignment) requires a type
      balancing.  A smaller range type is promoted to a larger range
      type.  For example: 3 + 5.5 will trigger such a message because
      int is converted to double.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="913" id="913">913</a></td>
<td><pre>   Implicit adjustment of expected argument type from Type to Type
      -- Notes whenever an old-style function definition contains a
      sub-integer or float type.  For example:

            int f( ch, x ) char ch; float x; { ...

      contains two 913 adjustments.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="914" id="914">914</a></td>
<td><pre>   Implicit adjustment of function return value from Type to Type --
      Notes whenever the function return value is implicitly adjusted.
      This message is given only for functions returning arrays.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="915" id="915">915</a></td>
<td><pre>   Implicit conversion (Context) Type to Type -- Notes whenever an
      assignment, initialization or return implies an arithmetic
      conversion (Context specifies which).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="916" id="916">916</a></td>
<td><pre>   Implicit pointer assignment conversion (Context) -- Notes
      whenever an assignment, initialization or return implies an
      implicit pointer conversion (Context specifies which).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="917" id="917">917</a></td>
<td><pre>   Prototype coercion (Context) Type to Type -- Notes whenever an
      implicit arithmetic conversion takes place as the result of a
      prototype.  For example:

            double sqrt(double);
            ... sqrt(3); ...

      will elicit this message because 3 is quietly converted to
      double.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="918" id="918">918</a></td>
<td><pre>   Prototype coercion (Context) of pointers -- Notes whenever a
      pointer is implicitly converted because of a prototype.  Because
      of prototype conversion, near pointers will otherwise be silently
      mapped into far pointers.  far pointers mapped into near pointers
      also generate message 619.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="919" id="919">919</a></td>
<td><pre>   Implicit conversion (Context) Type to Type -- A lower precision
      quantity was assigned to a higher precision variable as when an
      int is assigned to a double.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="920" id="920">920</a></td>
<td><pre>   Cast from Type to void -- A cast is being made from the given
      type to void.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="921" id="921">921</a></td>
<td><pre>   Cast from Type to Type -- A cast is being made from one integral
      type to another.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="922" id="922">922</a></td>
<td><pre>   Cast from Type to Type -- A cast is being made to or from one of
      the floating types (float, double, long double).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="923" id="923">923</a></td>
<td><pre>   Cast from Type to Type -- A cast is being made either from a
      pointer to a non-pointer or from a non-pointer to a pointer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="924" id="924">924</a></td>
<td><pre>   Cast from Type to Type -- A cast is being made from a struct or a
      union.  If the cast is not to a compatible struct or union error
      69 is issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="925" id="925">925</a></td>
<td><pre>   Cast from pointer to pointer -- A cast is being made to convert
      one pointer to another such that one of the pointers is a pointer
      to void.  Such conversions are considered harmless and normally
      do not even need a cast.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="926" id="926">926</a></td>
<td><pre>   Cast from pointer to pointer -- A cast is being made to convert a
      char pointer to a char pointer (one or both of the char's may be
      unsigned).  This is considered a 'safe' cast.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="927" id="927">927</a></td>
<td><pre>   Cast from pointer to pointer -- A cast is being made to convert a
      char (or unsigned char) pointer to a non-char pointer.  char
      pointers are sometimes implemented differently from other
      pointers and there could be an information loss in such a
      conversion.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="928" id="928">928</a></td>
<td><pre>   Cast from pointer to pointer -- A cast is being made from a
      non-char pointer to a char pointer.  This is generally considered
      to be a 'safe' conversion.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="929" id="929">929</a></td>
<td><pre>   Cast from pointer to pointer -- A cast is being made to convert
      one pointer to another that does not fall into one of the
      classifications described in 925 through 928 above.  This could
      be nonportable on machines that distinguish between pointer to
      char and pointer to word.  Consider casting a pointer to pointer
      to char to a pointer to pointer to word.  The indirect bit
      pattern remains unchanged.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="930" id="930">930</a></td>
<td><pre>   Cast from Type to Type -- A cast is being made to or from an
      enumeration type.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="931" id="931">931</a></td>
<td><pre>   Both sides have side effects -- Indicates when both sides of an
      expression have side-effects.  An example is n++ + f( ).  This is
      normally benign.  The really troublesome cases such as n++ + n
      are caught via Warning 564.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="932" id="932">932</a></td>
<td><pre>   Passing near pointer to library function '(Symbol)' (Context) --
      A source of error in Windows programming is to pass a near
      pointer to a library function.  If the library is a DLL library,
      then in supplying the missing segment, the library would assume
      its own data segment which would probably be wrong.  See also
      messages 933 and 934.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="933" id="933">933</a></td>
<td><pre>   Passing near pointer to far function (Context) -- A source of
      error in Windows programming is to pass a near pointer to a DLL
      function.  Most Microsoft functions in DLLs are declared with the
      far modifier.  Hence this can be tentatively used as a
      discriminant to decide that a pointer is too short.  An advantage
      that this Note has over 932 is that it can catch functions
      designated only by pointer.  Also you may be using libraries that
      are not DLLs and that share the same DS segment.  In this case,
      932 may produce too many superfluous messages.  See also message
      934.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="934" id="934">934</a></td>
<td><pre>   Taking address of near auto variable 'Symbol' (Context) -- A
      source of error in writing DLL libraries is that the stack
      segment may be different from the data segment.  In taking the
      address of a near data object only the offset is obtained.  In
      supplying the missing segment, the compiler would assume the data
      segment which could be wrong.  See also messages 932 and 933.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="935" id="935">935</a></td>
<td><pre>   int within struct -- This Note helps to locate non-portable data
      items within struct's.  If instead of containing int's and
      unsigned int's, a struct were to contain short's and long's then
      the data would be more portable across machines and memory
      models.  Note that bit fields and union's do not get complaints.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="936" id="936">936</a></td>
<td><pre>   old-style function definition for function 'Symbol' -- An
      "old-style" function definition is one in which the types are not
      included between parentheses.  Only names are provided between
      parentheses with the type information following the right
      parenthesis.  This is the only style allowed by K&amp;R.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="937" id="937">937</a></td>
<td><pre>   old-style function declaration for function 'Symbol' -- An
      "old-style" function declaration is one which does not have type
      information for its arguments.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="938" id="938">938</a></td>
<td><pre>   parameter 'Symbol' not explicitly declared -- In an "old-style"
      function definition it is possible to let a function parameter
      default to int by simply not providing a separate declaration for
      it.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="939" id="939">939</a></td>
<td><pre>   return type defaults to int for function 'Symbol' -- A function
      was declared without an explicit return type.  If no explicit
      storage class is given, then Informational 745 is also given
      provided the Deduce Return mode flag (fdr) is off.  This is meant
      to catch all cases.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="940" id="940">940</a></td>
<td><pre>   omitted braces within an initializer -- An initializer for a
      subaggregate does not have braces.  For example:

            int a[2][2] = { 1, 2, 3, 4 };

      This is legal C but may violate local programming standards.  The
      worst violations are covered by Warning 651.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="941" id="941">941</a></td>
<td><pre>   Result 0 due to operand(s) equaling 0 in operation 'String' --
      The result of a constant evaluation is 0 owing to one of the
      operands of a binary operation being 0.  This is less severe than
      Info 778 wherein neither operand is 0.  For example, expression
      (2&amp;1) yields a 778 whereas expression (2&amp;0) yields a 941.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="942" id="942">942</a></td>
<td><pre>   Possibly truncated addition promoted to float -- An integral
      expression (signed or unsigned) involving addition or subtraction
      is converted to a floating point number. If an overflow occurred,
      information would be lost.  See also messages 647, 776 and 790.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="943" id="943">943</a></td>
<td><pre>   Too few initializers for aggregate 'Symbol' -- The initializer
      {0} was used to initialize an aggregate of more than one item.
      Since this is a very common thing to do it is given a separate
      message number which is normally suppressed.  See 785 for more
      flagrant abuses.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="944" id="944">944</a></td>
<td><pre>   [left/right/] argument for operator 'String' always evaluates to
      [True/False] -- The indicated operator (given by String has an
      argument that appears to always evaluate to either 'True' or
      'False' (as indicated in the message).  This is given for Boolean
      operators (||and &amp;&amp; and for Unary operator !) and information is
      gleaned from a variety of sources including prior assignment
      statements and initializers.  Compare this with message 506 which
      is based on testing constants or combinations of constants.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="945" id="945">945</a></td>
<td><pre>   Undefined struct used with extern -- Some compilers refuse to
      process declarations of the form:

            extern struct X s;

      where struct X is not yet defined.  This note can alert a
      programmer porting to such platforms.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="946" id="946">946</a></td>
<td><pre>   Relational or subtract operator applied to pointers -- A
      relational operator (one of &gt;, &gt;=, &lt;, &lt;=) or the subtract
      operator has been applied to a pair of pointers.  The reason this
      is of note is that when large model pointers are compared (in one
      of the four ways above) or subtracted, only the offset portion of
      the pointers is subject to the arithmetic.  It is presumed that
      the segment portion is the same.  If this presumption is not
      accurate then disaster looms.  By enabling this message you can
      focus in on the potential trouble spots.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="947" id="947">947</a></td>
<td><pre>   Subtract operator applied to pointers -- An expression of the
      form p - q was found where both p and q are pointers.  This is of
      special importance in cases where the maximum pointer can
      overflow the type that holds pointer differences.  For example,
      suppose that the maximum pointer is 3 Gigabytes -1, and that
      pointer differences are represented by a long, where the maximum
      long is 2 Gigabytes -1.  Note that both of these quantities fit
      within a 32 bit word.  Then subtracting a small pointer from a
      very large pointer will produce an apparent negative value in the
      long representing the pointer difference.  Conversely,
      subtracting a very large pointer from a small pointer can produce
      a positive quantity.

      The alert reader will note that a potential problem exists
      whenever the size of the type of a pointer difference equals the
      size of a pointer.  But the problem doesn't usually manifest
      itself since the highest pointer values are usually less than
      what a pointer could theoretically hold.  For this reason, the
      message cannot be given automatically based on scalar types and
      hence has been made an Elective Note.

      Compare this Note with that of 946 which was designed for a
      slightly different pointer difference problem.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="948" id="948">948</a></td>
<td><pre>   Operator 'String' always evaluates to [True/False] -- The
      operator named in the message is one of four relational operators
      or two equality operators in the list:
     
                &gt;    &gt;=    &lt;    &lt;=
                ==   !=
     
      The arguments are such that it appears that the operator always
      evaluates to either True or to False (as indicated in the
      message).  This is similar to message 944.  Indeed there is some
      overlap with that message.  Message 944 is issued in the context
      where a Boolean is expected (such as the left hand side of a ?
      operator) but may not involve a relational operator.  Message 948
      is issued in the case of a relational (or equality) operator but
      not necessarily in a situation that requires a Boolean.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="950" id="950">950</a></td>
<td><pre>   Non-ANSI reserved word or construct: 'Symbol' -- Symbol is either
      a reserved word that is non-ANSI or a construct (such as the //
      form of comment in a C module).  This Elective Note is enabled
      automatically by the -A option.  If these messages are occurring
      in a compiler or library header file over which you have no
      control, you may want to use the option -elib(950).  If the
      reserved word is one which you want to completely disable, then
      use the option -rw(Word).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="951" id="951">951</a></td>
<td><pre>   Pointer to incomplete type 'Symbol' employed in operation -- A
      pointer to an incomplete type (for example, struct X where struct
      X has not yet been defined in the current module) was employed in
      an assignment or in a comparison (for equality) operator.  For
      example, suppose a module consisted only of the following
      function:
     
            struct A * f(struct A *p )
                {
                return p;
                }

      Since struct A had not been defined, this message will be issued.
      Such employment is permitted by the standard but is not permitted
      by all C compilers.  If you want to deploy your application to
      the maximum number of platforms you should enable this Elective
      Note.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="952" id="952">952</a></td>
<td><pre>   Parameter 'Symbol' (Location) could be declared const -- A
      parameter is not modified by a function.  For example:

        int f( char *p, int n ) { return *p = n; }

      can be redeclared as:

        int f( char * const p, const int n ) { return *p = n; }

      There are few advantages to declaring an unchanging parameter a
      const.  It signals to the person reading the code that a
      parameter is unchanging, but, in the estimate of most, reduces
      legibility.  For this reason the message has been given an
      Elective Note status.

      However, there is a style of programming that encourages
      declaring parameters const.  For the above example, this style
      would declare f as

          int f( char * p, int n);

      and would use the const qualifier only in the definition.  Note
      that the two forms are compatible according to the standard.  The
      declaration is considered the interface specification where the
      const's do not matter.  The const's do matter in the definition
      of the function which is considered the implementation.  Message
      952 could be used to support this style.

      Marking a parameter as const does not affect the type of argument
      that can be passed to the parameter.  In particular, it does not
      mean that only const arguments may be passed.  This is in
      contrast to declaring a parameter as pointer to const or
      reference to const.  For these situations, Informational messages
      are issued (818 and 1764 respectively) and these do affect the
      kinds of arguments that may be passed.  See also messages 953 and
      954.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="953" id="953">953</a></td>
<td><pre>   Variable 'Symbol' (Location) could be declared as const -- A
      local variable (either static or auto) is initialized but never
      modified thereafter.  Such a variable could be declared const.
      One advantage in making such a declaration is that it can furnish
      a clue to the program reader that the variable is unchanging.  In
      the case of static data it can mean that the data is ROM'able.
      Other situations in which a const can be added to a declaration
      are covered in messages 818, 952, 954 and 1764.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="954" id="954">954</a></td>
<td><pre>   Pointer variable 'Symbol' (Location) could be declared as
      pointing to a const -- The data pointed to by a pointer is never
      changed (at least not through that pointer).  It may therefore be
      better, or at least more descriptive, if the variable were typed
      pointer to const.  For example:
     
            {
            char *p = "abc";
            for( ; *p; p++ ) print(*p);
            }

      can be redeclared as:
     
            {
            const char *p = "abc";
            for( ; *p; p++ ) print(*p);
            }   

      It is interesting to contrast this situation with that of pointer
      parameters.  The latter is given Informational status (818)
      because it has an effect of enhancing the set of pointers that
      can be passed into a function.  Other situations in which a const
      can be added to a declaration are covered in messages 952, 953
      and 1764.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="955" id="955">955</a></td>
<td><pre>   Parameter name missing from prototype for function 'Symbol' -- In
      a function declaration a parameter name is missing.  For example:

            void f(int);

      will raise this message.  This is perfectly legal but misses an
      opportunity to instruct the user of a library routine on the
      nature of the parameter.  For example:

            void f(int count);

      would presumably be more meaningful. [27, Rule 34].

      This message is not given for function definitions, only function
      declarations.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="956" id="956">956</a></td>
<td><pre>   Non const, non volatile static or external variable 'Symbol' --
      This check has been advocated by programmers whose applications
      are multi-threaded.  Software that contains modifiable data of
      static duration is often non-reentrant.  That is, two or more
      threads cannot run the code concurrently.  By 'static duration'
      we mean variables declared static or variables declared external
      to any function.  For example:
     
            int count = 0;
            void bump( ) { count++; }
            void get_count( ) { return count; }

      If the purpose is to obtain a count of all the bump( )'s by a
      given thread then this program clearly will not do since the
      global variable count sums up the bump( )'s from all the threads.
      Moreover, if the purpose of the code is to obtain a count of all
      bump( )'s by all threads, it still may contain a subtle error
      (depending on the compiler and the machine).  If it is possible
      to interrupt a thread between the access of count and the
      subsequent store, then two threads that are bump( )'ing at the
      same time, may register an increase in the count by just one.

      Please note that not all code is intended to be re-entrant.  In
      fact most programs are not designed that way and so this Elective
      Note need not be enabled for the majority of programs.  If the
      program is intended to be re-entrant, all uses of non-const
      static variables should be examined carefully for non-reentrant
      properties.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="957" id="957">957</a></td>
<td><pre>   Function 'Symbol' defined without a prototype in scope -- A
      function was defined without a prototype in scope.  It is usually
      good practice to declare prototypes for all functions in header
      files and have those header files checked against the definitions
      of the function to assure that they match.

      If you are linting all the files of your project together such
      cross checking will be done in the natural course of things.  For
      this reason this message has been given a relatively low urgency
      of Elective Note.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="958" id="958">958</a></td>
<td><pre>   Padding of Integer byte(s) is required to align member on Integer
      byte boundary -- This message is given whenever padding is
      necessary within a struct to achieve a required member alignment.
      Consider:
     
          struct A { char c; int n; };
     
      Assuming that int must be aligned on a 4-byte boundary and
      assuming the size of a char to be 1, then this message will be
      issued indicating that there will be a padding of 3 bytes.

      The alignment requirements vary with the compiler, the machine
      and, sometimes, compiler options.  When separately compiled
      programs need to share data at the binary level it helps to
      remove any artifically created padding from any of the structures
      that may be shared.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="959" id="959">959</a></td>
<td><pre>   Nominal struct size (Integer bytes) is not an even multiple of
      the maximum member alignment (Integer bytes) -- The alignment of
      a structure (or union) is equal to the maximum alignment of any
      of its members.  When an array of structures is allocated, the
      compiler ensures that each structure is allocated at an address
      with the proper alignment.  This will require padding if the size
      of the structure is not an even multiple of its maximum
      alignment.  For example:
     
          struct A { int n; char ch; } a[10];
     
      Assuming the size and alignment of int is 4 then the size of each
      struct is 5 but its alignment is 4.  As a result each struct in
      the array will be padded with 3 bytes.

      Alignment can vary with the compiler and the machine.  If binary
      data is to be shared by separately compiled modules, it is safer
      to make sure that all shared structures and unions are explicitly
      padded.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="960" id="960">960</a></td>
<td><pre>   Violates MISRA Year Required Rule Name, String -- MISRA is the
      "Guidelines for the use of the C Language in Vehicle Based
      Software". [10]  The first version of the MISRA Standard was
      released in 1998 and the second in 2004.  Lint references the
      rules from each version of the Standard using integers for 1998
      and in decimal form for 2004, as per the Standard numbering
      style.

      The list of required checks made for both MISRA 1998 and 2004 are:

      (Rule 16/12.12) Bit representation of a floating point type used.
      (Rule 19/7.1) Octal constant used.
      (Rule 22/8.7) Could define variable at block scope.
      (Rule 27/8.8) Object/function previously declared.
      (Rule 32/9.3) Should initialize either all enum members or only the first.
      (Rule 33/12.4) Side effects on right hand side of logical operator.
      (Rule 34/12.5) Non-primary expression used with logical operator.
      (Rule 36/12.6) Boolean expression required for operator.
      (Rule 40/12.3) 'sizeof' used on expressions with side effect 
      (Rule 42/12.10) Comma operator used outside of 'for' expression.
      (Rule 47/12.1) Dependence placed on C operator precedence.
      (Rule 54/14.3) Null statement not in line by itself.
      (Rule 57/14.5) continue statement should not be used.
      (Rules 59/14.8 &amp; 14.9) Left brace expected for if, else, for, do, and while.
      (Rule 60/14.10) No 'else' at end of 'if ... else if' chain.
      (Rule 63/15.4) Boolean value in switch expression.
      (Rule 65/13.4) Floating point variable used as loop counter.
      (Rule 68/8.6) Function not declared at file scope.
      (Rule 69/16.1) Function has variable number of arguments.
      (Rule 73/16.3) Either all parameters or no parameters should have identifiers.
      (Rule 74/16.4) Parameter list differs from prior declaration for function.
      (Rule 87/19.1) Declaration before #include.
      (Rule 88/19.2) Header file name with non-standard character.
      (Rule 91/19.5) '#define/#undef' used within a block.
      (Rule 92/19.6) Use of '#undef' prohibited.
      (Rule 98/19.12) Multiple use of '#' and/or '##' operators in macro definition.
      (Rule 100/19.14) Non-standard use of 'defined' preprocessor operator.
      (Rule 115/20.2) Re-use of C90 identifier/identifier pattern.

      Required checks made exclusively for MISRA 1998 are:

      (Rule 8) Multibyte characters and wide string literals prohibited.
      (Rule 42) Comma operator used outside of 'for' expression.
      (Rule 54) Null statement not in line by itself.
      (Rule 58) break used outside of a switch.
      (Rule 73) Either all parameters or no parameters should have identifiers.
      (Rule 87) Declaration before #include.
      (Rule 88) Header file name contains non-standard character.
      (Rule 110) Bitfields inside union.

      Required checks made exclusively for MISRA 2004 are:

      (Rule 4.1) Prohibited escape sequence used.
      (Rule 6.1) Disallowed use of non-character value.
      (Rule 6.2) Disallowed use of non-numeric value.
      (Rule 8.5) No definitions of objects or function in header files.
      (Rules 10.1 &amp; 10.2) Prohibited implicit conversion.
      (Rules 10.3 &amp; 10.4) Prohibited cast of complex expressions.
      (Rule 10.5) Recasting required for operators '~' and '&lt;&lt;'.
      (Rule 10.6) Unsigned integer literals require a 'U' suffix.
      (Rule 11.5) Attempt to cast away const/volatile from a pointer or reference.
      (Rule 12.7) Bitwise operator applied to signed underlying type.
      (Rule 12.9) Prohibited operator applied to unsigned underlying type.
      (Rule 12.10) Comma operator used.
      (Rule 12.13) Increment or decrement combined with another operator.
      (Rule 14.3) Null statement not in line by itself.
      (Rule 14.6) More than one 'break' terminates loop.
      (Rule 14.8) Left brace expected.
      (Rule 16.3) All parameters shall have identifiers.
      (Rule 16.9) Function identifier used without '&amp;' or parenthesized parameter list.
      (Rule 17.4) Pointer arithmetic other than array indexing used.
      (Rule 18.4) Unions shall not be used.
      (Rule 19.13) '#/##' operator used in macro.

      MISRA 1998 checking is achieved using the -misra(1) option.  For
      MISRA 2004 checks, use -misra(2).

      You may disable individual rules to your taste by using the Rule
      number in an esym option.  For example:

     
          -esym( 960, 75, 8? )
     

      will suppress MISRA rules 75 and any of the those between 80 and
      89 inclusive that are issued as the result of a 960.  See [10]
      for information on the MISRA guidelines.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="961" id="961">961</a></td>
<td><pre>   Violates MISRA Year Advisory Rule Name, String" -- This message
      is issued for some violations of the MISRA advisory guidelines.
      Certain rules were advisories in the 1998 Standard and became
      required for the 2004 Standard and vice versa.  Therefore, you
      might see some rules repeated here already listed above for
      message 960.

      The list of advisory checks made for both MISRA 1998 and 2004
      are:

      (Rule 47/12.1) Dependence placed on C's operator precedence 
      (Rule 87/19.1) Only preprocessor statements and comments before '#include'.
      (Rule 93/19.7) Use of function-like macros is discouraged.
      (Rule 102/17.5) More than two pointer indirection levels used.


      Advisory checks made exclusively for MISRA 1998 are:

      (Rule 18) Constant requires numerical suffix 
      (Rule 28) 'register' class discouraged 
      (Rule 40) 'sizeof' used on expressions with side effect 
      (Rule 44) Redundant explicit casting 
      (Rule 55) Non-case label 
      (Rule 60) No 'else' at end of 'if ... else if' chain.
      (Rule 63) Boolean value in switch expression 
      (Rule 92) Use of '#undef' is discouraged 

      Advisory checks made exclusively for MISRA 2004 are:

      (Rule 19.2) Header file name contains non-standard character.
      (Rule 19.13) No use of '#' or '##'.

      Messages can be suppressed based on rule number.  See also
      Message 960.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="962" id="962">962</a></td>
<td><pre>   Macro 'Symbol' defined identically at another location (Location)
      -- The same macro was defined in the same way in two different
      places in the source code.  This is not a good practice since a
      subsequent change to one of the macros could lead to confusion.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="963" id="963">963</a></td>
<td><pre>   Qualifier const or volatile follows/precedes a type; use
      -fqb/+fqb to reverse the test -- The declarations in the
      following example are equivalent:
     
              //lint +e963  report on qualifier-type inversion
              extern const char *p;
              extern char const *p;   // Note 963
     
      The qualifier 'const' and 'volatile' may appear either before or
      after or even between other declaration specifiers.  Many
      programmers prefer a consistent scheme such as always placing the
      qualifier before the type.  If you enable 963 (using +e963) this
      is what you will get by default.  The message will contain the
      word 'follows' rather than the word 'precedes'.

      There is a diametrically opposite convention, viz. that of
      placing the qualifier after the type.  As the message itself
      reminds the user you will obtain the reverse test if you turn off
      the fqb (place qualifiers before types) flag.  Thus
     
              //lint -fqb   turn off the Qualifiers Before types flag
              //lint +e963  report on type-qualifier inversion
              extern const char *p;   // Note 963
              extern char const *p;
     
      Note that the use of this flag will cause 'follows' in the
      message to be replaced by 'precedes' and the alternative option
      mentioned within the 'use' clause is changed to its opposite
      orientation.

      Dan Saks [36] and Vandevoorde and Josuttis [32, section 1.4]
      (<ref,14. added="" bibliography,14.="">), provide convincing evidence
      that this alternative convention is indeed the better one.

</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="964" id="964">964</a></td>
<td><pre>   Header file FileName not directly used in module String -- The
      given header file was not used in the given module, however it,
      itself, included a header file (possibly indirectly) that was
      used.  An example of this is os2.h that is an umbrella header
      serving only to include other headers.  Compare this message with
      766.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="966" id="966">966</a></td>
<td><pre>   Indirectly included header file 'FileName' not used by module
      'String' -- The header file given by FileName was unused directly
      or indirectly in a given module outside of its group.  It was
      not, however, directly included by the module and so may not
      easily be excluded without disturbing the header including it.
      Since this header may be included in other places caution is
      advised.  This message is a weaker version of 766.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="967" id="967">967</a></td>
<td><pre>   Header file 'FileName' does not have a standard include guard --
      You may protect against the repeated inclusion of headers by
      means of a standard include guard having the following form:
     
              #ifndef Name
              #define Name
               ...
              #endif
     
      The header file cited in the message does not have such a guard.
      It is standard practice in many organizations to always place
      include guards within every header.

      See <ref,warning 451="" in="" section="" 13.3,13.3=""> for more information
      about header include guards.

</ref,warning></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="970" id="970">970</a></td>
<td><pre>   Use of modifier or type 'Name' outside of a typedef -- Some
      standards require the use of type names (defined in typedef's) in
      preference to raw names used within the text of the program.  For
      example they may want you to use INT32 rather than int where
      INT32 is typedef's as:

            typedef int INT32;

      This message is normally issued for the standard intrinsic types:
      bool, char, wchar_t, int, float, double, and for modifiers
      unsigned, signed, short and long.  You may enable this message
      and then suppress the message for individual types to obtain
      special effects.  For example the following will enable the
      message for all but bool.

            +e970  -esym(970,bool)

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="971" id="971">971</a></td>
<td><pre>   Use of 'char' without 'signed' or 'unsigned' -- The 'char' type
      was specified without an explicit modifier to indicate whether
      the char was signed or unsigned.  The plain char type can be
      regarded by the compiler as identifying a signed or an unsigned
      quantity whichever is more efficient to implement.  Because of
      this ambiguity, some standards do not like the use of char
      without an explicit modifier to indicate its signedness.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="973" id="973">973</a></td>
<td><pre>   Unary operator in macro 'Symbol' not parenthesized -- A unary
      operator appearing in an expression-like macro was found to be
      not parenthesized.  For example:

            #define N -1

      The user may prefer to parenthesize such things as:

            #define N (-1)

      This has been placed in the elective note category because we
      cannot find an instance when this really produces a problem.  The
      important case of unparenthesized binary operators is covered
      with message 773.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="974" id="974">974</a></td>
<td><pre>   Worst case function for stack usage: String -- This message,
      issued at global wrap-up, will report on the function that
      requires the most stack.  The stack required consists of the
      amount of auto storage the function requires plus the amounts
      required in any chain of functions called.  The worst case chain
      is always reported.

      To obtain a report of all the functions, use the +stack option.

      Reasonable allowances are made for function call overhead and the
      stack requirements of external functions.  These assumptions can
      be controlled via the +stack option.

      If recursion is detected it will be reported here, as this is
      considered worse than any finite case.  The next worse case is
      that the stack can't be determined because a function makes a
      call through a function pointer.  The function is said to be
      non-deterministic.  If neither of these conditions prevail, the
      function that heads the worst case chain of calls will be
      reported upon.

      The message will normally provide you with the name of a called
      function.  If the function is recursive this will provide you
      with the first call of a recursive loop.  To determine the full
      loop, you will need a full stack report as obtained with the
      +stack option.  You need a suboption of the form &amp;file=file to
      specify a file which will contain a record for each function for
      which a definition was found.  You will be able to follow the
      chain of calls to determine the recursive path.

      If you can assure yourself through code analysis that there is an
      upper bound to the amount of stack utilized by some recursive
      function, then you can employ the +stack option to specify the
      bound for this function.  The function will no longer be
      considered recursive but rather finite.  In this way, possibly
      through a sequence of options, you can progressively eliminate
      apparent recursion and in that way arrive at a safe upper bound
      for stack usage.  Similar considerations apply for
      non-deterministic functions.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="975" id="975">975</a></td>
<td><pre>   Unrecognized pragma 'Name' will be ignored -- The first
      identifier after #pragma is considered the name of the pragma.
      If the name is unrecognized then the remainder of the line is
      ignored.  Since the purpose of #pragma is to allow for
      compiler-dependent communication it is not really expected that
      all pragmas will be understood by all third-party processors of
      the code.  Thus, this message does not necessarily indicate that
      there is anything wrong and could easily be supressed entirely.

      Moreover, if the pragma occurs in a libary header this message
      would not normally be issued because the option -wlib(1) would be
      in effect (this option is present in all of our compiler option
      files).

      But if the pragma occurs in user code then it should be examined
      to see if there is something there that might interest a lint
      processor.  There are a variety of facilities to deal with
      pragmas; in particular, they can be mapped into languistic
      constructs or lint options or both.  See <ref,3.5 pragmas="" push_macro="" and="" pop_macro,3.5=""> and <ref,3.6 casting="" pragmas="" as="" macros,3.6="">.


                 ------ 19.7 C++ Syntax Errors ------
</ref,3.6></ref,3.5></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1001" id="1001">1001</a></td>
<td><pre>  Scope 'Name' must be a struct or class name -- In an expression
      of the form X::Y,  X must be a class name.  [11, 10.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1002" id="1002">1002</a></td>
<td><pre>  'this' must be used in class member function -- The keyword this
      refers to the class being passed implicitly to a member function.
      It is invalid outside a class member function.  [11, 5.1]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1003" id="1003">1003</a></td>
<td><pre>  'this' may not be used in a static member function -- A static
      member function receives no this pointer.  [11, 9.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1004" id="1004">1004</a></td>
<td><pre>  Expected a pointer to member after .* or -&gt;* -- The .* and -&gt;*
      operators require pointer to members on the right hand side.
      [11, 5.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1005" id="1005">1005</a></td>
<td><pre>  Destructor declaration requires class -- While expecting a
      declaration a '~' character was encountered.  This was presumed
      to be the start of a destructor.  However no class was specified.
      [11, 12.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1006" id="1006">1006</a></td>
<td><pre>  Language feature 'String' not supported -- The indicated feature,
      while not supported in the current version, will hopefully be
      supported in future versions of the product.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1007" id="1007">1007</a></td>
<td><pre>  Pure specifier for function 'Symbol' requires a virtual function
      -- An '=' was found after a declaration.  Was this the start of a
      pure specifier?  The declaration was not that of a member
      function which it must be.  Also, the member function should be
      virtual.  [11, 10.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1008" id="1008">1008</a></td>
<td><pre>  Expected '0' to follow '=', text ignored -- Some nonstandard
      extensions to C++ allow integers to follow '=' for declarations
      of member functions.  If you are using such extensions simply
      suppress this message.  If only library headers are using this
      extension use -elib(1008).  [11, 10.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1009" id="1009">1009</a></td>
<td><pre>  operator 'String' not redefinable -- The three operators:
     
          .*   ?   .
     
      are not redefinable and may not be overloaded [11, 13.4].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1010" id="1010">1010</a></td>
<td><pre>  Expected a type or an operator -- Following the keyword operator
      the parser expected either an operator (including new, delete, (
      ), [], comma) or a type.  [11, 13.4 and 12.3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1011" id="1011">1011</a></td>
<td><pre>  Conversion Type Name too long -- An upper limit of 50 characters
      has been reached on a conversion type name.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1012" id="1012">1012</a></td>
<td><pre>  Type not needed before 'operator type' -- The return type of a
      function introduced with 'operator Type' is Type and may not be
      preceded with the same or any other Type.  [11, 12.3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1013" id="1013">1013</a></td>
<td><pre>  Symbol 'Name' not a member of class 'Name' -- The second operand
      of a scope operator or a '.' or '-&gt;' operator is not a member of
      the class (struct or union) expressed or implied by the left hand
      operand.  [11, 3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1014" id="1014">1014</a></td>
<td><pre>  Explicit storage class not needed for member function 'Symbol' --
      An explicit Symbol storage class such as extern or static was
      given in a separate definition of a class member.  The storage
      class is effectively defined by its appearance within the class
      and may not be restated at definition time.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1015" id="1015">1015</a></td>
<td><pre>  Symbol 'Name' not found in class -- In an expression of the form
      X::Y, Y must be a member of X or of a public or protected base
      class of X.  [11, 10.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1016" id="1016">1016</a></td>
<td><pre>  Symbol 'Symbol' is supposed to denote a class -- In a
      base-specifier an identifier is supposed to specify a base class.
      However, the identifier was not previously declared in this
      module.  [11, 10]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1017" id="1017">1017</a></td>
<td><pre>  conflicting access-specifier 'String' -- Two different access
      specifiers were given in a simple base-specifier.  [11, 10]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1018" id="1018">1018</a></td>
<td><pre>  Expected a type after 'new' -- In an expression involving new, a
      type is expected after possibly processing a placement.  None was
      found.  [11, 5.3.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1019" id="1019">1019</a></td>
<td><pre>  Could not find match for function 'Symbol(String)' -- In
      attempting to find a match between a set of overloaded functions
      or operators (name given as Symbol) and an actual argument list
      (provided as String) no match could be found.  [11, 13.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1020" id="1020">1020</a></td>
<td><pre>  template specialization for 'Symbol' declared without a
      'template&lt;&gt;' prefix -- A class template specialization is
      generally preceded by a 'template&lt;&gt;' clause as in:
     
              template&lt; class T &gt; class A { };       // a template
              template&lt;&gt; class A<int> { };           // a specialization
     
      If the 'template&lt;&gt;' is omitted, you will get this message but it
      will still be interpreted as a specialization.  Before the
      standardization of template syntax was completed, a template
      specialization did not require this clause and its absence is
      still permitted by some compilers.

</int></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1022" id="1022">1022</a></td>
<td><pre>  Function: 'String' must be a class member -- There are four
      operators which may not be defined except as class members.
      These are:

              =  ( )  []  -&gt;

      The parameter String indicates which it is.  [11, 13.4.3 and
      13.4.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1023" id="1023">1023</a></td>
<td><pre>  Call String(String) is ambiguous; candidates: String -- A call to
      an overloaded function or operator is ambiguous.  The candidates
      of choice are provided in the message.  [11, 13.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1024" id="1024">1024</a></td>
<td><pre>  No function has same argument count as 'Name' -- A call to an
      overloaded function could not be resolved successfully because no
      function is declared with the same number of arguments as in the
      call.  [11, 13.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1025" id="1025">1025</a></td>
<td><pre>  No function matches invocation 'Name' on arg no. Integer -- A
      call to an overloaded function could not be resolved because each
      declared function has a type incompatibility with the indicated
      argument.  [11, 13.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1026" id="1026">1026</a></td>
<td><pre>  Undominated function 'String' does not dominate 'String' on call
      to 'String' -- A call to an overloaded function could not be
      resolved because no one function dominates all others.  This is a
      subtle issue in the overload resolution process.  The selected
      function must be strictly better than any non-selected function
      in at least one argument.  [11, 13.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1027" id="1027">1027</a></td>
<td><pre>  Non-consecutive default arguments in function 'String', assumed 0
      -- Default arguments need to be consecutive.  For example

            void f(int i=0, int j, int k=0);

      is illegal.  [11, 8.2.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1028" id="1028">1028</a></td>
<td><pre>  Last argument not default in first instance of function 'String',
      assumed 0 -- If any argument of a function is given a default
      value then all subsequent arguments need to be given a default
      value.  [11, 8.2.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1029" id="1029">1029</a></td>
<td><pre>  Default argument repeated in function 'String' -- A default value
      for a given argument for a given function should only be given
      once.  [11, 8.2.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1030" id="1030">1030</a></td>
<td><pre>  Not all arguments after arg no. Integer are default in function
      'String' -- An argument that has a default value must either be
      followed by another argument that has a default value, or must be
      the last argument.  [11, 8.2.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1031" id="1031">1031</a></td>
<td><pre>  Local variable 'Symbol' used in default argument expression --
      Default values for arguments may not use local variables.  [11,
      8.2.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1032" id="1032">1032</a></td>
<td><pre>  Member 'String' cannot be called without object -- There was an
      attempt to call a non-static member function without specifying
      or implying an object that could serve as the basis for the this
      pointer.  If the member name is known at compile time it will be
      printed with the message.  [11, 5.24]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1033" id="1033">1033</a></td>
<td><pre>  Static member functions cannot be virtual -- You may not declare
      a static member function virtual.  [11, 10.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1034" id="1034">1034</a></td>
<td><pre>  Static member 'Symbol' is global and cannot be redefined -- This
      can come as a surprise to the novice C++ programmer.  The word
      'static' within a class definition is used to describe a member
      that is alone and apart from any one object of a class.  But such
      a member has program scope not file scope.  The word 'static'
      outside a class definition implies file scope not program scope.
      [11, 9.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1035" id="1035">1035</a></td>
<td><pre>  Non-static member 'Symbol' cannot initialize a default argument
      -- A default argument cannot be initialized from a class member
      unless an instantiation of the class is provided.  [11, 8.2.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1036" id="1036">1036</a></td>
<td><pre>  ambiguous reference to constructor; candidates: 'String' -- There
      is more than one constructor that can be used to make a desired
      conversion.  [11, 12.3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1037" id="1037">1037</a></td>
<td><pre>  ambiguous reference to conversion function; candidates: 'String'
      -- There is more than one conversion function (of the form
      operator type ( ) ) that will perform a desired conversion.  [11,
      12.3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1038" id="1038">1038</a></td>
<td><pre>  type 'Name' not found, nested type 'Name::String' assumed -- We
      have found what appears to be a reference to a type but no such
      type is in scope.  We have, however, been able to locate a type
      buried within another class.  Is this what the user intended?  If
      this is what is intended, use full scoping.  If your compiler
      doesn't support the scoping, suppress with -esym.  [11, 3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1039" id="1039">1039</a></td>
<td><pre>  Symbol 'Symbol' is not a member of class 'String' -- In a
      declaration for the symbol X::Y, Y was not previously established
      as a member of X.  [11, 10.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1040" id="1040">1040</a></td>
<td><pre>  Symbol 'Symbol' is not a legal declaration within class 'String'
      -- A declaration of the symbol X::Y appears within a class
      definition (other than for class X).  It is not a friend
      declaration.  Therefore it is in error.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1041" id="1041">1041</a></td>
<td><pre>  Can't declare 'String', assumed 'operator String' -- This message
      can be given with String equal to new or delete.  A common
      mistake with beginning C++ programmers is to declare (and/or
      define) new when they mean to define operator new.  We presume
      this was what was intended.  [11, 12.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1042" id="1042">1042</a></td>
<td><pre>  At least one class-like operand is required with Name -- In
      defining (or declaring) an operator you must have at least one
      class as an operand.  [11, 13.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1043" id="1043">1043</a></td>
<td><pre>  Attempting to 'delete' a non-pointer -- An expression being
      delete'd is a non-pointer, non-array.  You may only delete that
      which was created with an invocation of new.  [11, 5.3.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1046" id="1046">1046</a></td>
<td><pre>  member 'Symbol', referenced in a static function, requires an
      object -- The Symbol is a non-static member of a class and hence
      requires a class instantiation.  None is in sight.  [10, 9.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1047" id="1047">1047</a></td>
<td><pre>  a template declaration must be made at file scope -- A template
      declaration may not appear within a function or within a class.
      [10, 14.1]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1048" id="1048">1048</a></td>
<td><pre>  expected a constant expression -- Within a template argument list
      a constant expression was expected.  An expression of the form
      T<arg1,arg2,...> was encountered and arg i for some i corresponds
      to a non-class parameter in the original template declaration.
      Such arguments need to be constants.  [10, 14.5]

</arg1,arg2,...></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1049" id="1049">1049</a></td>
<td><pre>  Too many template arguments -- There are more arguments in the
      template class-name than there were parameters in the original
      template declaration.  [10, 14.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1050" id="1050">1050</a></td>
<td><pre>  expected a template argument list '&lt;...&gt;' for template 'Symbol'
      -- The name of a class template identified by Symbol was used
      without specifying a template argument list.  [10, 14.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1051" id="1051">1051</a></td>
<td><pre>  Symbol 'Name' is both a function and a variable -- Whereas it is
      possible to overload a function name by giving it two different
      parameter lists, it is not possible to overload a name in any
      other way.  In particular a function name may not also be used as
      a variable name.  [11, 9.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1052" id="1052">1052</a></td>
<td><pre>  a type was expected, 'class' assumed -- A template parameter list
      consists of 2 kinds of parameters:  class identifier and type.
      The parameter did not begin with class and was not a type.  [10,
      14.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1053" id="1053">1053</a></td>
<td><pre>  'String' cannot be distinguished from 'String' -- An overloaded
      function name had two parameter lists that were so close that
      discrimination between them would be difficult and error prone.
      Eg. void f(const int); and void f(int);  [11, 13]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1054" id="1054">1054</a></td>
<td><pre>  template variable declaration expects a type, int assumed -- An
      expression of the form T<arg,arg,...> was encountered.  One of
      the arguments corresponding to a type parameter in the original
      template declaration is not a type.  [10, 14.5]

</arg,arg,...></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1055" id="1055">1055</a></td>
<td><pre>  Symbol 'Symbol' undeclared, assumed to return int -- Whereas in C
      you may call a function without a prior declaration, in C++ you
      must supply such a declaration.  For C programs you would have
      received an Informational message (718) in this event.  [11,
      5.2.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1056" id="1056">1056</a></td>
<td><pre>  assignment from void * is not allowed in C++ -- Whereas in C you
      may assign from void* to any other (data) pointer without a
      diagnostic, in C++ you may not do this.  It will require a cast.
      [11, 4.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1057" id="1057">1057</a></td>
<td><pre>  member 'Symbol' cannot be used  without an object -- The
      indicated member referenced via scope operator cannot be used in
      the absence of this pointer.  [11, 5.2.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1058" id="1058">1058</a></td>
<td><pre>  Initializing a non-const reference 'Symbol' with a non-lvalue --
      A reference is normally initialized with an lvalue.  If you
      attempt to initialize a reference with a non-lvalue, a temporary
      is created to serve as a surrogate lvalue.  However,
      modifications made to the temporary will be lost.  This was legal
      at one time and is now illegal.  Make the reference a const if
      you can.  You may be initializing a reference without realizing
      it.  A member function has an implicit parameter which is taken
      to be a reference to its object.  If this is the situation make
      the member const.  That is, use void f(...) const; rather than
      void f(...);

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1059" id="1059">1059</a></td>
<td><pre>  Can't convert from 'Type' to 'Type' -- An attempt was made to
      initialize a reference with an object having a type other than
      the target type but no function could be found to effect the
      required conversion.  [11, 12.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1060" id="1060">1060</a></td>
<td><pre>  String member 'Symbol' is not accessible to non-member non-friend
      functions -- There is an attempt to access a private or protected
      member of a class and the access is considered a violation of the
      access rules (although everything else proceeds as though no
      violation occurred).  Specifically, the function attempting to
      make access must be a friend or member of the nominal class
      through which the access is made.  See also 1061.  [11, 11]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1061" id="1061">1061</a></td>
<td><pre>  String member 'Symbol' is not accessible through non-public
      inheritance -- There is an attempt to access a private, protected
      or public member (the text of the message indicates which kind as
      well as which member) of a class through a class derived from the
      original.  There is an access violation (see 1060 for the more
      common access violation) critically dependent on the fact that
      the inheritance relationship is non-public.  [11, 11.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1062" id="1062">1062</a></td>
<td><pre>  template must be either a class or a function -- Following
      template &lt; arglist &gt; the parser expects to find either the token
      class or a function declaration or definition.  [10, 14.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1063" id="1063">1063</a></td>
<td><pre>  Argument to copy constructor for class 'Symbol' should be a
      reference -- A constructor for a class closely resembles a copy
      constructor.  A copy constructor for class X is typically
      declared as:

            X( const X &amp;)

      If you leave off the '&amp;' then a copy constructor would be needed
      just to copy the argument into the copy constructor.  This is a
      runaway recursion.  [11, 12.1]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1064" id="1064">1064</a></td>
<td><pre>  Template parameter list for template 'Symbol' inconsistent with
      Location -- The template parameter list for a template function
      declaration or definition is inconsistent with that of a prior
      declaration or definition.  [10, 14.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1065" id="1065">1065</a></td>
<td><pre>  Symbol 'Symbol' not declared as "C" conflicts with Location -- A
      symbol previously declared as extern "C" in some other module is
      not declared as extern "C" in this module.  This could be the
      source of very mysterious linker diagnostics since a name
      declared as extern "C" is not subject to the name mangling
      procedures that strictly C++ functions are.  [11, 7.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1066" id="1066">1066</a></td>
<td><pre>  Symbol 'Symbol' declared as "C" conflicts with Location -- A
      symbol is being declared as extern "C" and was not so declared in
      some other module.  This could be the source of very mysterious
      linker diagnostics since a name declared as extern "C" is not
      subject to the name mangling procedures that strictly C++
      functions are.  [11, 7.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1067" id="1067">1067</a></td>
<td><pre>  invalid prototype for function 'Symbol' -- Whenever operator
      delete or operator delete [] is defined its first parameter must
      be declared as void *.  For member functions an optional second
      parameter may be size_t.  [10, 12.5].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1068" id="1068">1068</a></td>
<td><pre>  Symbol 'Symbol' can not be overloaded -- operator delete or
      operator delete [] can be redefined but not overloaded.  There
      can only be one operator delete and one operator delete [] but
      neither of these can be overloaded.  [10, 12.5].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1069" id="1069">1069</a></td>
<td><pre>  Symbol 'Name' is not a base class of class 'Name' -- Within a
      constructor initialization list a name was found that did not
      correspond to either a direct base class of the class being
      defined or a member of the class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1070" id="1070">1070</a></td>
<td><pre>  No scope in which to find symbol 'Name' -- This could arise in an
      expression of the form X::Y where X does not represent a valid
      scope.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1071" id="1071">1071</a></td>
<td><pre>  Constructors and destructors can not have return type --
      Constructors and destructors may not be declared with a return
      type, not even void.  See ARM Section 12.1 and 12.4.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1072" id="1072">1072</a></td>
<td><pre>  Reference variable 'Symbol' must be initialized -- A reference
      variable must have an initializer at the point of declaration.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1073" id="1073">1073</a></td>
<td><pre>  Insufficient number of template parameters for 'Symbol'; 'String'
      assumed -- A (class) template instantiation did not have a
      sufficient number of parameters.  String indicates what the
      missing argument is presumed to be.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1074" id="1074">1074</a></td>
<td><pre>  Expected a namespace identifier -- In a declaration of the form:
     
            namespace name = scoped-identifier

      the scoped-identifier must identify a namespace.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1075" id="1075">1075</a></td>
<td><pre>  Ambiguous reference to symbol 'Symbol' and symbol 'Symbol' -- Two
      namespaces contain the same name.  A reference to such a name
      could not be disambiguated.  You must fully qualify this name in
      order in indicate which name is intended.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1076" id="1076">1076</a></td>
<td><pre>  Anonymous union assumed to be 'static' -- Anonymous unions need
      to be declared static.  This is because the names contained
      within are considered local to the module in which they are
      declared.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1077" id="1077">1077</a></td>
<td><pre>  Could not evaluate default template parameter 'String' -- The
      evaluation of template parameters is deferred until needed.
      Thus:

            template&lt; class T = abc &gt; class A { /* ... */ };

      will be greeted with an Error 1077 only if an instantiation of
      A&lt;&gt; requires evaluation of the default argument and if that
      evaluation cannot be made.  In that event int is assumed for type
      parameters and 0 is assumed for object parameters.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1078" id="1078">1078</a></td>
<td><pre>  class 'Symbol' should not have itself as a base class -- The
      following situation will trigger this message.

            class A : public A { };

      You can't define A in terms of itself as there is no escape from
      the recursive plummet.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1079" id="1079">1079</a></td>
<td><pre>  Could not find '&gt;' or ',' to terminate template parameter at
      Location -- The default value for a template parameter appears to
      be malformed.  For example, suppose the user mistakenly
      substituted a ']' for a '&gt;' producing the following:
     
            template <class t="A<" int="" ]="">
                class X
                    {
                    };

      This will cause PC-lint/FlexeLint to process to the end of the
      file looking (in vain) for the terminating pointy bracket.  Not
      finding it will cause this message to be printed.  Fortunately,
      the message will bear the Location of the malformed template.

</class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1080" id="1080">1080</a></td>
<td><pre>  Definition for class 'Name' is not in scope -- This message would
      be issued whenever a class definition were required and it were
      not available.  For example:

            class X;        // declare class X
            X *p;           // OK, no definition required
            X a;            // Error 1080

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1081" id="1081">1081</a></td>
<td><pre>  Object parameter does not contain the address of a variable --
      A template argument that is passed to a pointer parameter is
      supposed to identify a symbol.  The expression passed does not do so.
      For example
     
              template&lt; int *P &gt; class A { ... };
              int a[10];
              A&lt; a+2 &gt; x;     // a+2 does not represent a symbol
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1082" id="1082">1082</a></td>
<td><pre>  Object parameter for a reference type should be an external
      symbol -- A template argument that is passed to a reference
      parameter is supposed to identify an external symbol.  The
      expression passed does not do so.  For example
     
              template&lt; int &amp;I &gt; class A { ... };
              int a[10];
              A&lt; a[2] &gt; x;     // a[2] does not represent a symbol
     
      See also message 1081.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1083" id="1083">1083</a></td>
<td><pre>  Ambiguous conversion between 2nd and 3rd operands of conditional
      operator -- If the 2nd operand can be converted to match the type
      of the 3rd, and the 3rd operand can be converted to match the
      type of the 2nd, then the conditional expression is considered
      ill-formed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1084" id="1084">1084</a></td>
<td><pre>  Ambiguous use of template-id for instantiation of 'Type' -- When
      the language calls for a class template to be instantiated and
      the primary template is "overloaded" via one or more partial
      specializations, there is an attempt to see if the template
      arguments match any of those partial specializations.  (Note,
      explicit specializations would have been considered before
      determining that the class definition needs to be generated by
      way of instantiation.)  If multiple partial specializations match
      then:

        - If one of the matching partial specializations is more
          specialized than all others then it is used for the
          instantiation.

        - Otherwise, the program is ill-formed, so Lint issues
          message 1084.

      In the message, the matching partial specializations are provided
      as the list of candidates.  Example:
     
          template<class t1,="" class="" t2,="" int="" i=""> class A {};             //#1
          template<class t1,="" class="" t2,="" int="" i=""> class A<t1*, t2,="" i=""> {}; //#2
          template<class t1,="" class="" t2,="" int="" i=""> class A<t1, t2*,="" i=""> {}; //#3
          A<int*, int*,="" 2=""> a; // ambiguous: matches #2 and #3
              // (and neither template is more specialized than the other)
     

</int*,></t1,></class></t1*,></class></class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1085" id="1085">1085</a></td>
<td><pre>  Invalid definition of 'String' -- An attempt was made to define a
      member of a template before the template was defined. Example:
     
              template<class t,="" class="" u=""> struct A
                      { 
                      void 
                      }; 
              template<class u,="" class="" t=""> void A<t,u>::f(){} // Error 1085
     
      In this case, the template argument list is out of order; T and U
      have been interchanged.

</t,u></class></class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1086" id="1086">1086</a></td>
<td><pre>  Compound literals may only be used in C99 programs -- Compound
      literals are defined in C99 ([4] ISO/IEC 9899:1999).  However,
      some compilers allow the use of compound literals in C++.  If you
      plan to port your code to another C++ compiler, then it may be
      worthwhile to heed this message; otherwise it may be safely
      suppressed with -e1086.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1087" id="1087">1087</a></td>
<td><pre>  Previous declaration of 'Name' (Location) is incompatible with
      'Name' (Location) which was introduced by the current
      using-declaration -- A using declaration such as:

            using NS::name;

      seems to be in error.  It introduces a name that clashes with the
      name introduced earlier by another using-declaration.  E.g.:
     
              namespace N { int i;}
              namespace Q { void i();}
              using N::i;
              using Q::i; // Error 1087 issued here.
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1088" id="1088">1088</a></td>
<td><pre>  A using-declaration must name a qualified-id -- This error is
      issued when a using-declaration references a name without the ::
      scope resolution operator; e.g.:
     
              class A { protected: int n; };
              class B : public A {
              public:
                  using n; // Error 1088: should be 'using A::n;'
              };
     
      See Section <ref,14. added="" bibliography,14.="">, [34], 7.3.3
      namespace.udecl.

</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1089" id="1089">1089</a></td>
<td><pre>  A using-declaration must not name a namespace -- This error is
      issued when the rightmost part of the qualified-id in a
      using-declaration is the name of a namespace.  E.g.:
     
              namespace N { namespace Q{ void g(); } }
              void f() {
                  using ::N::Q; // Error 1089
                  Q::g();
              }
     
      Instead, use a namespace-alias-definition:
     
              namespace N { namespace Q{ void g(); } }
              void f() {
                  namespace Q = ::N::Q; // OK
                  Q::g(); // OK, calls ::N::Q::g().
              }
     
      See Section <ref,14. added="" bibliography,14.="">, [35], Issue 460.

</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1090" id="1090">1090</a></td>
<td><pre>  A using-declaration must not name a template-id -- This error is
      issued when the rightmost part of the qualified-id in a
      using-declaration is a template-id.  E.g.:
     
              template<class t=""> class A {
              protected:
                  template<class u=""> class B{};
              };

              struct D : public A<int> {
              public:
                  using A<int>::B<char*>; // Error 1090
                  };

              D::B<char*> bc;
     
      Instead, refer to the template name without template arguments:
     
              template<class t=""> class A {
              protected:
                  template<class u=""> class B{};
              };

              struct D : public A<int> {
              public:
                  using A<int>::B; // OK
                  };

              D::B<char*> bc; // OK
     
      See Section <ref,14. added="" bibliography,14.="">, [34], 7.3.3
      namespace.udecl.

</ref,14.></char*></int></int></class></class></char*></char*></int></int></class></class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1091" id="1091">1091</a></td>
<td><pre>  'Name' is not a base class of 'Name' -- This error is issued when
      the nested-name-specifier of the qualified-id in a
      using-declaration does not name a base class of the class
      containing the using-declaration; e.g.:
     
              struct N {
                  void f();
              }

              class A { protected: void f(); };
              class B : A {
              public:
                  using N::f; // Error 1091
              };
     
      See Section <ref,14. added="" bibliography,14.="">, [35], Issue 400.

</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1092" id="1092">1092</a></td>
<td><pre>  A using-declaration that names a class member must be a
      member-declaration -- This error is issued when the
      nested-name-specifier of the qualified-id in a using-declaration
      names a class but the using-declaration does not appear where
      class members are declared.  E.g.:
     
              struct A { void f(); };

              struct B : A{
                  void g() {
                      using A::f; // Error 1092
                  }
              };
     
      See Section <ref,14. added="" bibliography,14.="">, [34], 7.3.3
      namespace.udecl.

</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1093" id="1093">1093</a></td>
<td><pre>  A pure specifier was given for function 'Symbol' which was not
      declared virtual -- A pure specifier ("= 0") should not be placed
      on a function unless the function had been declared "virtual".

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1094" id="1094">1094</a></td>
<td><pre>  Could not find ')' or ',' to terminate default function argument
      at Location -- A default function argument was found which did
      not seem to include any terminating tokens (the ',' separating
      arguments or ')' ending the function's argument list).
      Consequently, Lint continued scanning to the end of the file.
      Location indicates where the default argument began.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1095" id="1095">1095</a></td>
<td><pre>  Effective type 'Type' of non-type template parameter #Integer
      (corresponding to argument expression 'String') depends on an
      unspecialized parameter of this partial specialization -- The ISO
      C++ Standard says that "the type of a template parameter
      corresponding to a specialized non-type argument shall not be
      dependent on a parameter of the specialization." See Section
      <ref,14. added="" bibliography,14.="">, [34], 14.5.4 temp.class.spec.
      Example:
     
          // primary template:
          template<class t,="" t="" n,="" class="" u=""> struct B;

          // PS #1:
          template<class u=""> struct B<int,257,u>; // Ok

          // PS #2:
          template<class u=""> struct B<bool,257,u>; // Ok, same as:
          template<class u=""> struct B<bool,true,u>; // Ok (redeclaration of #2)

          // PS #3:
          template<class u=""> struct B<t,257,u>; // Error 1095 here
     
      In PS #3, the value 257 is the 'specialized non-type argument'
      and its corresponding parameter is 'N' whose type is T which was
      not made concrete.  But in PS #1 and PS #2, T was given the
      concrete types 'int' and 'bool', respectively.

</t,257,u></class></bool,true,u></class></bool,257,u></class></int,257,u></class></class></ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1096" id="1096">1096</a></td>
<td><pre>  A target ctor must be the only mem-initializer in the
      mem-initializer-list of a delegating ctor -- C++0x requires that
      if a constructor delegates to another constructor, then the
      mem-initializer (the region between the colon and the function
      body) must contain only one item, and that item must be a call to
      another constructor (which is called the "target constructor").
      Example:
     
      struct A
          {
          int n;
          A(int);
          A( const A&amp; p) : A(p.n) {} // Ok
          A() :
              n(42),  A(32)  // Error 1096
              {}
          };
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1097" id="1097">1097</a></td>
<td><pre>  Delegating ctor delegates directly to itself, causing infinite
      recursion -- Example:
     
      struct A
          {
          int n;
          A(int x) : A(x){} // Error 1097
          };
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1098" id="1098">1098</a></td>
<td><pre>  Function template specialization 'Symbol' does not match any
      function template -- This message is issued for a declaration
      where the user apparently intended to name a specialization of a
      function template (e.g., in an explicit specialization, an
      explicit instantiation or a friend declaration of
      specialization), but no previously-declared function template is
      matched.  Example:
     
          template<class t=""> void f( const T&amp; ); // #1

          struct A{};
          template&lt;&gt; void f( const A&amp; ); // Ok
          // (A is the deduced argument to T.)

          struct B{};
          template&lt;&gt; void f( const B ); // Error 1097.
          // (A template argument cannot be deduced for T.)
     

</class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1099" id="1099">1099</a></td>
<td><pre>  Ambiguous function template specialization 'Symbol' -- This
      message is issued for a declaration where the user apparently
      intended to name a specialization of a function template (e.g.,
      in an explicit specialization, an explicit instantiation or a
      friend declaration of specialization), but the specialization
      matches multiple function templates, and none of the matched
      templates is more specialized than all of the other matching
      templates.  The candidates (i.e., the matching templates) are
      provided in the message.  Example:
     
          template<class t=""> struct A {};

          template<class t,="" class="" u=""> void f( T*, U    ); // #1
          template<class t,="" class="" u=""> void f( T,  A<u> ); // #2

          struct B{};
          template&lt;&gt; void f( B, A<b> ); // Ok
          // #1 does not match but #2 does.

          template&lt;&gt; void f( char*, A<int> ); // Error 1099
          // Both #1 and #2 match and neither is more specialized than the
          // other.
     
      This situation can be avoided in at least a couple of ways.  One
      way is to explicitly specify one or more template arguments.
      Example:
     
          // continuing from above...
          template&lt;&gt; void f<char*>( char*, A<int> ); // Ok
          // #1 does not match but #2 does.
     
      Another way is to use SFINAE tactics in the declaration of one or
      more function templates, e.g. with boost::enable_if.

</int></char*></int></b></u></class></class></class></pre><u><b><a href="#top">Top</a></b></u></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1100" id="1100">1100</a></td>
<td><pre>  Declaration of 'Symbol' does not declare an explicit
      specialization, explicit instantiation or friend -- In a
      declaration that explicitly specifies template arguments with
      angle brackets immediately after the name of a function template,
      the declaration must declare either an explicit specialization,
      explicit instantiation or friend.  (Note, an explicit
      specialization always begins with 'template&lt;&gt;' and an explicit
      instantiation always begins with 'template'---without angle
      brackets after the keyword 'template'.)
     
          template<class t=""> struct A {};

          template<class t=""> inline void f( A<t> ); // #1
          void f( A<int> ); // #2 // Ok, declares an ordinary function

          void f<char>( A<char> ); // Error 1100
     

</char></char></int></t></class></class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1101" id="1101">1101</a></td>
<td><pre>  Type of variable 'Symbol' cannot be deduced from its initializer
      -- Example:
     
          int f(void);
          int f(char*);
          auto n = f; // Error
     
      In terms of deduction, this is equivalent to:
     
          int f(void);
          int f(char*);
          template<class t=""> void g( const T&amp; );
          void h( void )
              {
              g( f ); // Error
              }
     
      Here,  'f' refers to multiple overloaded functions, so it is an
      ambiguous reference and T cannot be deduced.  (Code like this
      could still be well-formed however, e.g. if g is overloaded with
      a non-template function whose parameter type is 'ptr-to-function
      returning int taking (char*)'.)

</class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1102" id="1102">1102</a></td>
<td><pre>  auto type deduced inconsistently: 'Type' for 'Symbol' but 'Type'
      for 'Symbol' -- When multiple variables are defined in the same
      declaration, and when that declaration uses the keyword auto as
      the type-specifier (a feature of C++0x), the type for which auto
      is a placeholder must be the same for each variable.  Example:
     
          float g(void);
          char* s();
          auto a = 42; // Ok, auto is 'int'
          auto b = g(); // Ok, auto is 'float'
          auto c = 'q',
               *d = s(); // Ok, auto is 'char' (for both c and d)
          auto x = 42, y = g(); // Error 1102 here
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1103" id="1103">1103</a></td>
<td><pre>  Type 'Type' is not allowed as an enum-base -- When an enumeration
      type is declared with an explicit underlying type, that type must
      be integral.  Example:
     
          enum A : bool; // ok
          enum B : short; // ok
          enum C : unsigned long long; // ok
          enum D : float; // Error 1103
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1104" id="1104">1104</a></td>
<td><pre>  A reference to enumeration 'Symbol' should not use 'String' --
      Although an enumeration may be declared or defined using a scope
      indicator or an underlying type indicator, these should not be
      applied when simply referencing the enumeration.  E.g.
     
          enum class A { red, green };
          enum class A x;         // Error: don't need 'class'
          enum A : unsigned { red, green };
          enum A : unsigned y;    // Error: don't need ': unsigned'
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1105" id="1105">1105</a></td>
<td><pre>  Use of ref qualification of 'Symbol' inconsistent with overloaded
      function 'Symbol' (Location) -- If an explicit ref qualifier ('&amp;'
      or '&amp;&amp;') of a nonstatic member function is employed, an explicit
      ref qualifier needs to be used with every member of the overload
      set.  Thus:
     
          class A
              {
              void f(int) &amp;;  // ok (so far)
              void f(int);    // 1105
              void f(double); // 1105
              void g(int);    // ok (fresh function)
              void g(double); // still ok
              };
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1106" id="1106">1106</a></td>
<td><pre>  Initializing value 'String' of enumerator 'Name' cannot be
      represented by the enumeration's underlying type 'Type' -- An
      enumerator is being initialized with a value that is
      inappropriate to the declared type of the initializer.  Example:
     
          enum E : unsigned char { e = 256 };
     
      The value 256 cannot be represented by an unsigned char.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1107" id="1107">1107</a></td>
<td><pre>  Mixing two different kinds of string literals -- Two string
      literals are being concatenated which have different types.
      Examples:
     
          char *s = u"abc" U"def";
          char *q = L"ghi" u"jkl";
     
      This message is issued for mixing strings of char16_t, char32_t,
      and/or wchar_t (as shown).  Literal string concatenation of any
      of these with an ordinary character literal is permitted and will
      receive Informational 707.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1108" id="1108">1108</a></td>
<td><pre>  Use of deleted function 'Symbol' defined at 'Location' -- This
      message is issued when a deleted function is used.  Example:
     
          void f( int ) = delete;
          void f( double );
          void g( double d, int n ) {
              f( d ); // Ok
              f( n ); // Error
          }
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1110" id="1110">1110</a></td>
<td><pre>  Cycle detected: explicit application of 'Name'::operator-&gt; causes
      infinite implicit applications of the same operator -- When an
      overloaded operator-&gt; is used as in
     
          a-&gt;b
     
      it is effectively expanded to:
     
          a.operator-&gt;()-&gt;b
     
      And this expansion repeats until an operator-&gt; is found that does
      not yield a class type.  But in the process of evaluating this
      expansion, it might be found that one  of the operators returns a
      class type for which an overloaded operator-&gt; was already
      expanded; in that case, Error 1110 is triggered.  Example:
     
          struct B;
          struct A { struct B&amp; operator-&gt;(); };
          struct B { struct A&amp; operator-&gt;(); };
          int  f( A &amp; p ) { p-&gt;g(); } // Error
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1111" id="1111">1111</a></td>
<td><pre>  ISO C++ requires an explicit specialization/instantiation to
      appear at namespace scope -- This message is issued at the
      beginning of each explicit specialization/instantiation that does
      not appear at namespace scope.  Example:
     
          struct A {
              template <typename u=""> struct B {};

              // template &lt;&gt;  // Would be ill-formed by ISO C++.
              //     struct B<int> {};
          };
          template&lt;&gt; struct A::B<int> {}; // Ok.
     
      There is an additional limitation with member class templates of
      class templates.  As with members of a non-template class, one
      cannot write a specialization at class scope.   Example:
     
          template<typename t=""> struct G {
              template <typename u=""> struct H {};
              // template &lt;&gt;  // Would be ill-formed by ISO C++.
              //     struct H<int> {};
          };
     
      But the language specification does not even allow this to be
      expressed in a namespace-scope definition; there is no way to
      write an explicit specialization that is a member of a class
      template.  Example:
     
          template<typename t=""> struct J {
              template <typename u=""> struct K {};
          };
          // template<typename t="">
          //     template &lt;&gt;  // Would be ill-formed by ISO C++;
          //         struct J<t>::K<int> {};
     
      This is because the rules for explicit specializations say that
      'template&lt;&gt;' is not allowed to appear after a non-empty
      template-parameter-list within the same declaration.  However,
      one may write an explicit specialization that is a member of an
      implicitly-instantiated specialization of a class template.
      Example:
     
          template<typename t=""> struct L {
              template <typename u=""> struct M {};
          };
          template &lt;&gt; template &lt;&gt; struct L<char>::M<int> {}; // Ok
     
      Here, the body of the class L<char> is automatically generated by
      implicit instantiation (otherwise the reference to 'L<char>::M'
      would be ill-formed), while the body of L<char>::M<int> is
      provided in the explicit specialization.

      In March of 2009, the ISO C++ committee reviewed a report
      submitted against this example:
     
         struct A {
            template<class t=""> struct B;
            template <class t=""> struct B<t*> { }; // well-formed
            template &lt;&gt; struct B<int*> { }; // ill-formed
          };
     
      While it might seem odd that one is able to write the partial
      specialization but not the full specialization, the committee
      (which at the time was in a "feature-freeze" mode and trying to
      finalize a draft for the next International Standard) decided
      that this capability would need to be regarded as an "extension",
      meaning that it could be considered as a new feature in a future
      standard but not as a bug-fix for C++0x.

      Note that the Microsoft compiler implements this extension.  For
      that reason, the Lint option
     
          -elib(1111)
     
      appears in recent versions of our configuration files for
      Microsoft compilers.

</int*></t*></class></class></int></char></char></char></int></char></typename></typename></int></t></typename></typename></typename></int></typename></typename></int></int></typename></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1116" id="1116">1116</a></td>
<td><pre>  Virtual function 'Symbol' overrides function marked with final --
      A derived class attempted to override a virtual function that is
      marked with the final virt-specifier in a base class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1117" id="1117">1117</a></td>
<td><pre>  Non-virtual function 'Symbol' marked with 'String' -- A
      virt-specifier (final or override) was supplied to a non-virtual
      function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1118" id="1118">1118</a></td>
<td><pre>  Virtual function 'Symbol' already marked with 'String' -- A
      virt-specifier (final or override) was encountered multiple times
      for the specified virtual function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1119" id="1119">1119</a></td>
<td><pre>  Virtual function 'Symbol' marked with override does not override
      -- A virtual function was marked with the override keyword but
      does not override a base class function.


             ------ 19.8 Additional Internal Errors ------
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="12" id="12">12</a></td>
<td><pre>  Internal Error -- Some inconsistency or contradiction was
      discovered in the PC-lint/FlexeLint system. This may or may not
      be the result of a user error. This inconsistency should be
      brought to the attention of Gimpel Software.


                ------ 19.9 C++ Warning Messages ------
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1401" id="1401">1401</a></td>
<td><pre>  member 'Symbol' (Location) not initialized by constructor -- The
      indicated member symbol was not initialized by a constructor.
      Was this an oversight?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1402" id="1402">1402</a></td>
<td><pre>  member 'Symbol' (Location) not initialized -- The indicated
      member symbol was not initialized prior to use.  Either this is
      in a constructor where it is presumed that no members are
      pre-initialized or this is after a statement which will remove
      its initialization such as a delete or a free.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1403" id="1403">1403</a></td>
<td><pre>  member 'Symbol' (Location) not initialized -- The indicated
      member symbol was not initialized prior to a point where its
      address is being passed to a constant pointer.  This looks
      suspicious.  Either this is in a constructor where it is presumed
      that no members are pre-initialized or this is after a statement
      which will remove its initialization such as a delete or a free.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1404" id="1404">1404</a></td>
<td><pre>  deleting an object of type 'Symbol' before type is defined -- The
      following situation was detected:

           class X;   ...   X *p;  ...  delete p;

      That is, a placeholder declaration for a class is given and an
      object of that type is deleted before any definition is seen.
      This may or may not be followed by the actual class definition:

           class X { ... };

      A delete before the class is defined is dangerous because, among
      other things, any operator delete that may be defined within the
      class could be ignored.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1405" id="1405">1405</a></td>
<td><pre>  Header typeinfo must be included before typeid is used --
      According to Section 5.2.8 (para 6) of the C++ standard [10], "If
      the header <typeinfo> (18.5.1) is not included prior to a use of
      typeid, the program is ill-formed." A typeid was found in the
      program but the required include was not.

</typeinfo></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1411" id="1411">1411</a></td>
<td><pre>  Member with different signature hides virtual member 'Symbol'
      (Location) -- A member function has the same name as a virtual
      member of a derived class but it has a different signature
      (different parameter list).  This is legal but suspicious,
      because it looks as though the function would override the
      virtual function but doesn't.  You should either adjust the
      parameters of the member so that the signatures conform or choose
      a different name.  See also message 1511.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1412" id="1412">1412</a></td>
<td><pre>  Reference member 'Symbol' is not initialized -- A class member
      typed reference to class (or struct or union) is mentioned in a
      constructor initializer list.  But the class (or struct or union)
      referenced has no constructor and so is never initialized.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1413" id="1413">1413</a></td>
<td><pre>  function 'Symbol' is returning a temporary via a reference -- It
      appears that a function (identified as Symbol in the message)
      declared to return a reference is returning a temporary.
      According to the C++ standard (Section 12.2), in addressing the
      issue of binding temporary values to references, says "A
      temporary bound to the returned value in a function return
      statement ... persists until the function exits".  Thus the
      information being returned is not guaranteed to last longer than
      the function being called.

      It would probably be better to return by value rather than
      reference.  Alternatively, you may return a static variable by
      reference.  This will have validity at least until the next call
      upon the same function.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1414" id="1414">1414</a></td>
<td><pre>  Assigning address of auto variable 'Symbol' to member of this --
      The address of an auto variable was taken and assigned to a this
      member in a member function.  For example:
     
              struct A
                  {
                  char *x;
                  void f()
                      {
                      char y[10];
                      x = y;          // warning 1414
                      }
                  };
     
      Here the address of y is being passed to member x but this is
      dangerous (if not ridiculous) since when the function returns,
      the storage allocated for y is deallocated and the pointer could
      very easily harm something.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1415" id="1415">1415</a></td>
<td><pre>  Pointer to non-POD class 'Name' passed to function 'Symbol'
      (Context) -- A non-POD class is one which goes beyond containing
      just Plain Old Data (POD).  In particular it may have private or
      protected data or it may have constructors or destructors or copy
      assignment.  All of these things disqualify it from being a POD.
      A POD is fully defined in the C++ standard (Clause 9).

      Some functions such as memcpy, memcmp, memmove, etc. are expected
      to be given only pointers to POD objects.  The reason is that
      only POD objects have the property that they can be copied to an
      array of bytes and back again with a guarantee that they will
      retain their original value.  (See Section 3.9 of the C++
      standard).  See also Semantic pod(i) in Section <ref,4. semantics,4.="">

</ref,4.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1416" id="1416">1416</a></td>
<td><pre>  An uninitialized reference 'Symbol' is being used to initialize
      reference 'Symbol' -- This message is usually issued when a
      reference to a member of a class is used to initialize a
      reference to another member of the same class before the first
      member was initialized.  For example:
     
              class C
                  {
                  int &amp;n, &amp;m;
                  C( int &amp;k ) : n(m), m(k) { /* ... */ }
                  };
     
      Here m is initialized properly to be identical to k.  However,
      the initialization of n, taking place, as it does, before m is so
      initialized, is erroneous.  It is undefined what location n will
      reference.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1417" id="1417">1417</a></td>
<td><pre>  reference member 'Symbol' not initialized by constructor
      initializer list -- This message is issued when a reference data
      member of a class does not appear in a mem-initializer.  For
      example, the following code will result in a Warning 1417 for
      symbol m since a mem-initializer is the only way that m can be
      reference initialized.
     
              class C
                  {
                  int &amp;n, &amp;m;
                  C( int &amp;k ) : n(k) { /* ... */ }
                  };
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1419" id="1419">1419</a></td>
<td><pre>  Destructors should never throw -- A destructor was declared
      without a throw() specification.  At least one author has warned
      against throwing exceptions from destructors and the practice can
      result in undefined behavior.  A safer approach is to provide an
      explciit throw() for each destructor.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1501" id="1501">1501</a></td>
<td><pre>  data member 'Symbol' has zero size -- A data member had zero
      size.  It could be an array of zero length or a class with no
      data members.  This is considered an error in C (Error 43) but in
      C++ we give this warning.  Check your code to make sure this is
      not an error.  Some libraries employ clever templating which will
      elicit this message.  In such a case it is necessary for you to
      inhibit the message outright (using -e1501) or through a
      judicious use of -esym(1501,...).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1502" id="1502">1502</a></td>
<td><pre>  defined object 'Symbol' has no nonstatic data members -- A
      variable (Symbol) is being instantiated that belongs to a class
      that contains no data members (either directly or indirectly
      through inheritance).  [11, 9]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1503" id="1503">1503</a></td>
<td><pre>  a tagged union is not anonymous -- A tagged union without a
      declarator appeared within a struct/union declaration.  An
      anonymous union requires no tag.  [11, 9.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1504" id="1504">1504</a></td>
<td><pre>  useless struct declaration -- An untagged struct declaration
      appeared within a struct/union and has no declarator.  It is not
      treated like an anonymous union.  Was this intended?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1505" id="1505">1505</a></td>
<td><pre>  no access specifier provided, 'String' assumed -- A base class
      specifier provides no access specifier (public, private or
      protected).  An explicit access specifier is always recommended
      since the default behavior is often not what is expected.  For
      example:

           class A : B { int a; };

      would make B a private base class by default.

           class A : private B { int a; };

      is preferred if that's what you want.  [11, 11.1]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1506" id="1506">1506</a></td>
<td><pre>  Call to virtual function 'Symbol' within a constructor or
      destructor -- A call to a virtual function was found in a
      constructor or a destructor of a class.  If this class is a base
      class of some other class (why else make a virtual call?), then
      the function called is not the overriding function of the derived
      class but rather the function associated with the base class.  If
      you use an explicit scope operator this message will not be
      produced.  [20, 9]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1507" id="1507">1507</a></td>
<td><pre>  attempting to 'delete' an array -- The type of an object to be
      delete'd is usually a pointer.  This is because operator new
      always returns a pointer and delete may only delete that which
      has been allocated via new.  Perhaps this is a programmer error
      attempting to delete an auto array?  [19]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1509" id="1509">1509</a></td>
<td><pre>  base class destructor for class 'Name' is not virtual -- The
      indicated class is a base class for some derived class.  It has a
      destructor which is not virtual.  Was this a mistake?  It is
      conventional to virtualize destructors of base classes so that it
      is safe to delete a base class pointer.  [19]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1510" id="1510">1510</a></td>
<td><pre>  base class 'Name' has no destructor -- The indicated class is a
      base class for some derived class that has a destructor.  The
      base class does not have a destructor.  Is this a mistake?  The
      difficulty that you may encounter is this; if you represent (and
      manipulate) a heterogeneous collection of possibly derived
      objects via a pointer to the base class then you will need a
      virtual base class destructor to invoke the derived class
      destructor.  [13, 4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1511" id="1511">1511</a></td>
<td><pre>  Member hides non-virtual member 'Symbol' (Location) -- The named
      member of a derived class hides a similarly named member of a
      base class.  Moreover, the base class member is not virtual.  Is
      this a mistake?  Was the base member supposed to have been
      declared virtual?  By unnecessarily using the same name,
      confusion could be created.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1512" id="1512">1512</a></td>
<td><pre>  destructor for base class 'Symbol' (Location) is not virtual --
      In a final pass through all the classes, we have found a class
      (named in the message) that is the base class of a derivation and
      has a destructor but the destructor is not virtual.  It is
      conventional for inherited classes to have virtual destructors so
      that it is safe to 'delete' a pointer to a base class.  [19]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1513" id="1513">1513</a></td>
<td><pre>  storage class ignored -- A storage class (one of auto, extern, or
      register) was found within a class definition.  The only storage
      classes that are significant when declaring members are static
      and typedef.  [11, 9.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1514" id="1514">1514</a></td>
<td><pre>  Creating temporary to copy 'Type' to 'Type' (context: Context) --
      A temporary was created in order to initialize (or pass a value
      to or return a value to) a reference.  This is suspect because
      any modification to the value will be a modification of this
      temporary.  This message is not issued when initializing a const
      reference.  [11, 12.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1515" id="1515">1515</a></td>
<td><pre>  Default constructor not available for member 'Symbol' -- A member
      of a class was found that had a type for which a constructor was
      defined but for which a default constructor (one with no
      arguments) was not defined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1516" id="1516">1516</a></td>
<td><pre>  Data member hides inherited member 'Symbol' (Location) -- A data
      member of a class happens to have the same name as a member of a
      base class.  Was this deliberate?  Identical names can cause
      confusion.  To inhibit this message for a particular symbol or
      for an identifiable set of symbols use -esym( ).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1520" id="1520">1520</a></td>
<td><pre>  Multiple assignment operators for class 'Symbol' -- More than one
      assignment operator has been declared for a given class.  For
      example, for class X there may have been declared:

            void operator=(X);
            void operator=(X) const;

      Which is to be used for assignment?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1521" id="1521">1521</a></td>
<td><pre>  Multiple copy constructors for class 'Symbol' -- For a given
      class, more than one function was declared that could serve as a
      copy constructor.  Typically this means that you declared both X(
      X&amp; ) and X( const X&amp; ) for the same class.  This is probably a
      mistake.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1522" id="1522">1522</a></td>
<td><pre>  Symbol 'Symbol' is an array of empty objects -- An array (Symbol)
      is being allocated.  Each member of the array appears to be
      empty.  Although this is legal, it could be the result of human
      error.  If this is deliberate policy, inhibit the message, either
      globally, or for this Symbol.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1524" id="1524">1524</a></td>
<td><pre>  new in constructor for class 'Name' which has no explicit
      destructor -- A call to new has been found in a constructor for a
      class for which no explicit destructor has been declared.  A
      destructor was expected because how else can the storage be
      freed?  [10, 12.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1526" id="1526">1526</a></td>
<td><pre>  Member function 'Symbol' (Location) not defined -- A member
      function (named in the message) of a non-library class was not
      defined.  This message is suppressed for unit checkout (-u
      option).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1527" id="1527">1527</a></td>
<td><pre>  static member 'Symbol' (Location) not defined -- A static data
      member (named in the message) of a non-library class was not
      defined.  In addition to its declaration within the class, it
      must be defined in some module.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1528" id="1528">1528</a></td>
<td><pre>  call to String does not match function template String -- The
      first String of the message designates an actual function call
      that appeared to be the invocation of the template function
      identified by the second String.  No match could be made between
      the arguments of the call and the template parameters.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1529" id="1529">1529</a></td>
<td><pre>  Symbol 'Symbol' not first checking for assignment to this -- The
      assignment operator does not appear to be checking for assignment
      of the value of a variable to itself (assignment to this).
      Specifically PC-lint/FlexeLint is looking for one of:

                if( &amp;arg == this )
                if( &amp;arg != this )
                if( this == &amp;arg )
                if( this != &amp;arg )

      as the first statement of the function.

      It is important to check for a self assignment so as to know
      whether the old value should be subject to a delete operation.
      This is often overlooked by a class designer since it is
      counter-intuitive to assign to oneself.  But through the magic of
      aliasing (pointers, references, function arguments) it is
      possible for an unsuspecting programmer to stumble into a
      disguised self-assignment [12, Item 17].

      If you are currently using the following test

                if( arg == *this)

      we recommend you replace this with the more efficient:

                if( &amp;arg == this || arg == *this)

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1531" id="1531">1531</a></td>
<td><pre>  Symbol 'Symbol' (Location) should have compared argument against
      sizeof(class) -- This warning is given for either operator new or
      operator delete when defined as member functions of a class that
      is the base class of a derivation.  In this case you can't be
      certain of the size of allocation and therefore your allocation
      functions should test the size parameter for equality to the
      sizeof the class.  See Elective Note 1921 for more details.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1532" id="1532">1532</a></td>
<td><pre>  Symbol 'Symbol' not checking argument for NULL -- This message is
      given for a function operator delete which is a member function
      of a class that does not have a destructor.  It should check for
      NULL because delete p where p has the NULL value will be passed
      in to it.  See also 1922.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1533" id="1533">1533</a></td>
<td><pre>  Repeated friend declaration for symbol 'Symbol' -- A friend
      declaration for a particular symbol (class or function) was
      repeated in the same class.  Usually this is a harmless
      redundancy.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1534" id="1534">1534</a></td>
<td><pre>  static variable 'Symbol' found within inline function in header
      -- A static variable (Symbol) was found within an inline function
      within a header file.  This can be a source of error since the
      static variable will not retain the same value across multiple
      modules.  Rather each module will retain its own version of the
      variable.  If multiple modules need to use the function then have
      the function refer to an external variable rather than a static
      variable.  Conversely if only one module needs to use the
      function then place the definition of the function within the
      module that requires it.  [23, Item 26].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1535" id="1535">1535</a></td>
<td><pre>  Exposing low access data through member 'Symbol' -- A member
      function is returning an address being held by the indicated
      member symbol (presumably a pointer).  The member's access (such
      as private or protected) is lower than the access of the function
      returning the address.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1536" id="1536">1536</a></td>
<td><pre>  Exposing low access member 'Symbol' -- A member function is
      returning the non-const address of a member either directly or
      via a reference.  Moreover, the member's access (such as private
      or protected) is lower than the access of the function returning
      the address.  For example:
     
                class X
                    {
                  private:
                    int a;
                  public:
                    int *f( ) { return &amp;a; }
                    };

      This looks like a breach of the access system [12, Item 30].  You
      may lower the access rights of the function, raise the
      accessibility of the member or make the return value a const
      pointer or reference.  In the above example you could change the
      function to:
     
                const int *f( ) { return &amp;a; }

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1537" id="1537">1537</a></td>
<td><pre>  const function returns pointer data member 'Symbol' -- A const
      function is behaving suspiciously.  It is returning a pointer
      data member (or equivalently a pointer to data that is pointed to
      by a data member).  For example,
     
                class X
                    {
                    int *p;
                    int *f( ) const { return p; }
                    };

      Since f is supposedly const and since p is presumptively pointing
      to data that is logically part of class X we certainly have the
      potential for a security breach.  Either return a pointer to
      const or remove the const modifier to the function.  [12, Item 29
      ].

      Note, if a const function returns the address of a data member
      then a 605 (capability increase) is issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1538" id="1538">1538</a></td>
<td><pre>  base class 'Name' absent from initializer list for copy
      constructor -- The indicated base class did not appear in the
      initializer list for a copy constructor.  Was this an oversight?
      If the initializer list does not contain an initializer for a
      base class, the default constructor is used for the base class.
      This is not normally appropriate for a copy constructor.  The
      following is more typical:
     
                class B { ... };
                class D : public B
                    {
                    D( const D &amp;arg ) : B( arg ) { ... }
                    ...
                    };

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1539" id="1539">1539</a></td>
<td><pre>  member 'Symbol' (Location) not assigned by assignment operator --
      The indicated Symbol was not assigned by an assignment operator.
      Was this an oversight?  It is not strictly necessary to
      initialize all members in an assignment operator because the
      'this' class is presumably already initialized.  But it is easy
      to overlook the assignment of individual members.  It is also
      easy to overlook your responsibility to assign base class
      members.  This is not done for you automatically. [12, Item 16]

      The message is not given for const members or reference members.
      If you have a member that is deliberately not initialized you may
      suppress the message for that member only using -esym.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1540" id="1540">1540</a></td>
<td><pre>  pointer member 'Symbol' (Location) neither freed nor zero'ed by
      destructor -- The indicated member is a non-static pointer member
      of a class that was apparently not freed by the class'
      destructor.  Was this an oversight?  By freeing, we mean either a
      call to the free( ) function or use of the delete operator.  If
      the pointer is only intended to point to static information
      during its lifetime then, of course, it never should be freed.
      In that case you should signal closure by assigning it the NULL
      pointer (0).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1541" id="1541">1541</a></td>
<td><pre>  member 'Symbol' (Location) possibly not initialized by
      constructor -- The indicated member symbol may not have been
      initialized by a constructor.  Was this an oversight?  Some of
      the paths that the constructor takes do initialize the member.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1542" id="1542">1542</a></td>
<td><pre>  member 'Symbol' (Location) possibly not initialized -- The
      indicated member symbol may not have been initialized prior to
      use.  Either this is in a constructor where it is presumed that
      no members are pre-initialized or this is after a statement which
      will remove its initialization such as a delete or a free.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1543" id="1543">1543</a></td>
<td><pre>  member 'Symbol' (Location) possibly not initialized -- The
      indicated member symbol may not have been initialized prior to a
      point where its address is being passed to a constant pointer.
      This looks suspicious.  Either this is in a constructor where it
      is presumed that no members are pre-initialized or this is after
      a statement which will remove its initialization such as a delete
      or a free.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1544" id="1544">1544</a></td>
<td><pre>  value of variable 'Symbol' (Location) indeterminate (order of
      initialization) -- A variable (identified by Symbol) was used in
      the run-time initialization of a static variable.  However this
      variable itself was initialized at run-time.  Since the order of
      initialization cannot be predicted this is the source of possible
      error.

      Whereas addresses are completely known at initialization time
      values may not be.  Whether the value or merely the address of a
      variable is used in the initialization of a second variable is
      not an easy thing to determine when an argument is passed by
      reference or via pointer.  For example,
     
            class X
                {
                X( const X &amp; );
                };

            extern X x1;
            X x2 = x1;
            X x1 = x2;

      It is theoretically possible, but unlikely, that the constructor
      X( ) is interested only in the address of its argument and not
      its current value.  If so, it only means you will be getting a
      spurious report which you can suppress based on variable name.
      However, if the const is missing when passing a reference
      parameter (or a pointer parameter) then we cannot easily assume
      that values are being used.  In this case no report will be
      issued.  The moral is that if you want to get the checking
      implied by this message you should make your constructor
      reference arguments const.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1545" id="1545">1545</a></td>
<td><pre>  value of variable 'Symbol' used previously to initialize variable
      'Symbol' (Location) -- A variable identified by Symbol was used
      previously to initialize some other variable.  This variable is
      now itself being initialized with run-time code.  The order of
      these initializations cannot be predicted.  See also message
      1544.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1546" id="1546">1546</a></td>
<td><pre>  direct throw of exception 'Name' within destructor 'Symbol' --
      The body of a destructor (signature provided within the message)
      contains a throw not within a try block.  This is dangerous
      because destructors are themselves triggered by exceptions in
      sometimes unpredictable ways.  The result can be a perpetual
      loop.  [23, Item 11]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1547" id="1547">1547</a></td>
<td><pre>  Assignment of array to pointer to base class (Context) -- An
      assignment from an array of a derived class to a pointer to a
      base class was detected.  For example:
     
                class B { };
                class D : public B {};
                D a[10];
                B *p = a;      // Warning 1547
                B *q = &amp;a[0];  // OK

      In this example p is being assigned the address of the first
      element of an array.  This is fraught with danger since access to
      any element other than the zeroeth must be considered an error
      (we presume that B and D actually have or have the potential to
      have different sizes).  [23, Item 3].

      We do not warn about the assignment to q because it appears that
      the programmer realizes the situation and wishes to confine q to
      the base object of the zeroeth element of a only.  As a further
      precaution against inappropriate array access, out of bounds
      warnings are issued for subsequent references to p[1] and q[1].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1548" id="1548">1548</a></td>
<td><pre>  Exception specification for 'Symbol' conflicts with Location --
      The exception specification of a function begins with the keyword
      'throw' and follows the prototype.  Two declarations were found
      for the same function with inconsistent exception specifications.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1549" id="1549">1549</a></td>
<td><pre>  Exception thrown for function 'Symbol' not declared to throw --
      An exception was thrown (i.e., a throw was detected) within a
      function and not within a try block;  moreover the function was
      declared to throw but the exception thrown was not on the list.
      If you provide an exception specification, include all the
      exception types you potentially will throw.  [23, Item 14]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1550" id="1550">1550</a></td>
<td><pre>  exception 'Name' thrown by function 'Symbol' is not on throw-list
      of function 'Symbol' -- A function was called (first Symbol)
      which was declared as potentially throwing an exception.  The
      call was not made from within a try block and the function making
      the call had an exception specification.  Either add the
      exception to the list, or place the call inside a try block and
      catch the throw.  [23, Item 14]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1551" id="1551">1551</a></td>
<td><pre>  function may throw exception 'Name' in destructor 'Symbol' -- A
      call to a function (name given by the first Symbol) was made from
      within a destructor.  The function was declared as potentially
      throwing an exception.  Such exceptions need to be caught within
      a try block because destructors should never throw exceptions.
      [23, Item 11].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1552" id="1552">1552</a></td>
<td><pre>  Converting pointer to array-of-derived to pointer to base -- This
      warning is similar to Warning 1547 and is sometimes given in
      conjunction with it.  It uses value tracking to determine that an
      array (that could be dynamically allocated) is being assigned to
      a base class pointer.

      For example,
     
                Derived *d = new Derived[10];
                Base *b;
                b = d;      // Warning 1552
                b = &amp;d[0];  // OK

      [23, Item 3]  Also, see the article by Mark Nelson (Bug++ of the
      Month, Windows developer's Journal, May 1997, pp. 43-44).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1553" id="1553">1553</a></td>
<td><pre>  struct 'Symbol' declared as extern "C" contains C++ substructure
      'Symbol' (Location) -- A C++ substructure was found in a
      structure or class declared as extern "C".  Was this intended?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1554" id="1554">1554</a></td>
<td><pre>  Direct pointer copy of member 'Symbol' within copy constructor:
      'Symbol' -- In a copy constructor a pointer was merely copied
      rather than recreated with new storage.  This can create a
      situation where two objects have the same data and this, in turn,
      causes problems when these objects are deleted or modified.  For
      example, the following class will draw this warning:
     
            class X
                {
                char *p;
                X( const X &amp; x )
                    { p = x.p; }
                ...
                };

      Here, member p is expected to be recreated using new or some
      variant.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1555" id="1555">1555</a></td>
<td><pre>  Direct pointer copy of member 'Symbol' within copy assignment
      operator: 'Symbol' -- In a copy assignment operator a pointer was
      merely copied rather than recreated with new storage.  This can
      create a situation where two objects have the same data and this,
      in turn, causes problems when these objects are deleted or
      modified.  For example, the following class will draw this
      warning:
     
            class X
                {
                char *p;
                X&amp; operator=( const X &amp; x )
                    { p = x.p; }
                ...
                };

      Here, member p is expected to be recreated using new or some
      variant.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1556" id="1556">1556</a></td>
<td><pre>  'new Type(integer)' is suspicious -- A new expression had the
      form new T(Integer) where type T has no constructor.  For
      example:

            new int(10)

      will draw this warning.  The expression allocates an area of
      storage large enough to hold one integer.  It then initializes
      that integer to the value 10.  Could this have been a botched
      attempt to allocate an array of 10 integers?  Even if it was a
      deliberate attempt to allocate and initialize a single integer, a
      casual inspection of the code could easily lead a reader astray.

      The warning is only given when the type T has no constructor.  If
      T has a constructor then either a syntactic error will result
      because no constructor matches the argument or a match will be
      found.  In the latter case no warning will or should be issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1557" id="1557">1557</a></td>
<td><pre>  const member 'Symbol' is not initialized -- A class member typed
      const class (or struct or union) is mentioned in a constructor
      initializer list.  But the class (or struct or union) referenced
      has no constructor and hence the member is not initialized.  See
      also messages 1558 and 1769.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1558" id="1558">1558</a></td>
<td><pre>  virtual coupled with inline is an unusual combination -- The
      function declared both 'virtual' and 'inline' has been detected.
      An example of such a situation is as follows:
     
              class C
                  {
                  virtual inline void f();   // Warning 1558
                  };
     
      Virtual functions by their nature require an address and so
      inlining such a function seems contradictory.  We recommend that
      the 'inline' function specifier be removed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1559" id="1559">1559</a></td>
<td><pre>  Uncaught exception 'Name' may be thrown in destructor 'Symbol' --
      The named exception occurred within a try block and was either
      not caught by any handler or was caught but then thrown from the
      handler.  Destructors should normally not throw exceptions [23,
      Item 11].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1560" id="1560">1560</a></td>
<td><pre>  Uncaught exception 'Name' not on throw-list of function 'Symbol'
      -- A direct or indirect throw of the named exception occurred
      within a try block and was either not caught by any handler or
      was rethrown by the handler.  Moreover, the function has an
      exception specification and the uncaught exception is not on the
      list.  Note that a function that fails to declare a list of
      thrown exceptions is assumed to potentially throw any exception.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1561" id="1561">1561</a></td>
<td><pre>  Reference initialization causes loss of const/volatile integrity
      (Context) -- A reference initialization is resulting in a
      capability gain that can cause a loss of const or volatile
      integrity.

      Typically the message is given on initializing a non-const
      reference with a const.  For example:
     
          void f( int &amp;x );
          const int n = 0;
          ...
          f(n);
     
      Here, function f() could assign a value to its argument and
      thereby modify n which is declared to be const.

      The message can also be issued when a pointer is initialized.
      Consider the following example.
     
          void h( const int *&amp;q );
          int *p;
          ...
          h(p);
     
      It might seem that passing a regular (i.e., non-const) pointer to
      a const int * could cause no harm.  That would be correct if it
      were not for the reference.  If function h() were to assign a
      pointer to const to its parameter q then upon return from the
      call, p could be used to modify const data.

      There are many subtle cases that can boggle the mind.  See the
      commentary to Message 605.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1562" id="1562">1562</a></td>
<td><pre>  Exception specification for 'Symbol' is not a subset of 'Symbol'
      (Location) -- The first symbol is that of an overriding virtual
      function for the second symbol.  The exception specification for
      the first was found not to be a subset of the second.  For
      example, it may be reasonable to have:
     
              struct B   { virtual void f() throw(B); };
              struct D:B { virtual void f() throw(D); };
     
      Here, although the exception specification is not identical, the
      exception D is considered a subset of the base class B.

      It would not be reasonable for D::f() to throw an exception
      outside the range of those thrown by B::f() because in general
      the compiler will only see calls to B::f() and it should be
      possible for the compiler to deduce what exceptions could be
      thrown by examining the static call.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1563" id="1563">1563</a></td>
<td><pre>  Suspicious third argument to ?: operator -- The third argument to
      ?: contained an unparenthesized assignment operator such as
     
              p ? a : b = 1
     
      If this is what was intended you should parenthesize the third
      argument as in:
     
              p ? a : (b = 1)
     
      Not only is the original form difficult to read but C, as opposed
      to C++, would parse this as:
     
              (p ? a : b) = 1
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1564" id="1564">1564</a></td>
<td><pre>  Assigning a non-zero-one constant to a bool -- The following
      looks suspicious.
     
              bool a = 34;
     
      Although there is an implicit conversion from integral to bool
      and assigning an integer varaible to a bool to obtain its Boolean
      meaning is legitimate, assigning an integer such as this looks
      suspicious.  As the message suggests, the warning is not given if
      the value assigned is either 0 or 1.  An Elective Note would be
      raised in that instance.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1565" id="1565">1565</a></td>
<td><pre>  member 'Symbol' (Location) not assigned by initializer function
      -- A function dubbed 'initializer' by a -sem option is not
      initializing (i.e., assigning to) every data member of a class.
      Reference members and const members theoretically can only be
      initialized via the constructor so that these members are not
      candidates for this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1566" id="1566">1566</a></td>
<td><pre>  member 'Symbol' (Location) might have been initialized by a
      separate function but no '-sem(Name,initializer)' was seen -- A
      class data member (whose name and location are indicated in the
      message) was not directly initialized by a constructor.  It may
      have been initialized by a separately called member function.  If
      this is the case you may follow the advice given in the message
      and use a semantic option to inform PC-lint/FlexeLint that the
      separately called function is in fact an 'initializer'.  For
      example:
     
              class A {
                      int a;
                  public:
                      void f();
                      A() { f(); }
                      };
     
      Here f() is presumably serving as an initializer for the
      constructor A::A().  To inform PC-lint/FlexeLint of this
      situation, use the option:
     
              -sem( A::f, initializer )
     
      This will suppress Warning 1566 for any constructor of class A
      that calls A::f.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1567" id="1567">1567</a></td>
<td><pre>  Initialization of variable 'Symbol' (Location) is indeterminate
      as it uses variable 'Symbol' through calls: 'String' -- A
      variable was dynamically initialized using an expression that
      contained a call to a function and that function referenced a
      variable that was also dynamically initialized and was in some
      other module.  For example:
     
              a.cpp:                  b.cpp:

              int g(void);            int f(void);
              int y = g();            int x = f();
              int f() { return y; }
     
      The initialization of both x and y are dynamic.  Although the
      order of dynamic initialization within a module is pre-ordained
      the order in which modules are initialized is not.  Therefore it
      is perfectly possible for b.cpp to be initialized before a.cpp.
      Thus when the call is made upon function f() to initialize x,
      variable y may not yet have been initialized.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1568" id="1568">1568</a></td>
<td><pre>  Variable 'Symbol' (Location) accesses variable 'Symbol' before
      the latter is initialized through calls: 'String' -- A variable
      was dynamically initialized using an expression that contained a
      call to a function and that function referenced a variable that
      was also dynamically initialized but later in the module.  For
      example:
     
              int g(void);
              int f(void);
              int x = f();
              int y = g();
              int f() { return y; }
     
      The initialization of both x and y are dynamic.  The order of
      dynamic initialization within a module is in the order in which
      the initialization is specified.  Thus when the call is made upon
      function f() to initialize x, variable y will not yet have been
      initialized.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1569" id="1569">1569</a></td>
<td><pre>  Initializing a member reference with a temporary. -- A member
      reference was initialized with a temporary.  For example:
     
          struct A { int &amp;n;  A() : n(3) {} };
     
      The constructor A() contains an initializer list within which it
      initializes n.  But n will be bound to a temporary created by the
      compiler to hold the value 3.  The lifetime of this temporary is
      limited; it "persists until the constructor exits" [10 section
      class.temporary]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1570" id="1570">1570</a></td>
<td><pre>  Initializing a reference class member with an auto variable
      'Symbol' -- In a constructor initializer, a reference class
      member is being initialized to bind to an auto variable.
      Consider:
     
          class X { int &amp;n; X(int k) :n(k) {} };
     
      In this example member n is being bound to variable k which,
      although a parameter, is nonetheless placed into auto storage.
      But the lifetime of k is only the duration of the call to the
      constructor, whereas the lifetime of n is the lifetime of the
      class object constructed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1571" id="1571">1571</a></td>
<td><pre>  Returning an auto variable 'Symbol' via a reference type -- A
      function that is declared to return a reference is returning an
      auto variable (that is not itself a reference).  The auto
      variable is not guaranteed to exist beyond the lifetime of the
      function.  This can result in unreliable and unpredictable
      behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1572" id="1572">1572</a></td>
<td><pre>  Initializing a static reference variable with an auto variable
      'Symbol' -- A static variable has a lifetime that will exceed
      that of the auto variable that it has been bound to.  Consider
     
          void f( int n ) { static int&amp; r = n; ... }
     
      The reference r will be permanently bound to an auto variable n.
      The lifetime of n will not extend beyond the life of the
      function.  On the second and subsequent calls to function f the
      static variable r will be bound to a non-existent entity.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1573" id="1573">1573</a></td>
<td><pre>  Generic function template 'Symbol' declared in namespace
      associated with type 'Symbol' (Location) -- When a class (or
      union or enum) is declared within a namespace that namespace is
      said to be associated with the type.  A Generic function template
      is any that has as parameters only intrinsic types or plain
      template arguments possibly adorned with reference or const or
      volatile qualification.  Consider
     
          namespace X
              {
              template&lt; class T &gt;
                  void f( int, const T&amp; );    // Generic
              class A{};                      // Warning 1573
              }
     
      A call to function f that contained an argument of type X::A
      would, by ADL (Argument Dependent Lookup), need to also consider
      function X::f even though this function was not in the scope of
      the call.  In the past this has led to strange an unexpected
      results.

      Some designers adopt the strategy of embedding the class within a
      sub namespace and employing a using-declaration to make it
      available to users of the original namespace.  For example:
     
          namespace X
              {
              template&lt; class T &gt;
                  void f( int, const T&amp; );    // Generic
              namespace X1
                  {
                  class A{};                  // No Warning
                  }
              using X1::A;
              }
     
      Now an argument of type X::A will not automatically trigger a
      consideration of X::f.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1574" id="1574">1574</a></td>
<td><pre>  Returning the address of an auto variable indirectly through
      reference variable 'Symbol' -- Within a function whose return
      type is reference to some type, a return statement is returning a
      reference which has been initialized (possibly indirectly) with
      an auto variable.  For example:
     
          int &amp;f( int k )
              {
              int &amp;r = k;
              return r;
              }
     

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1576" id="1576">1576</a></td>
<td><pre>  Explicit specialialization does not occur in the same file as
      corresponding function template 'Symbol' (Location) -- An
      explicit specialization of a function template was found to be
      declared in a file other than the one in which the corresponding
      function template is declared.  Two identical calls in two
      different modules on the same function template could then have
      two differing interpretations based on the inclusion of header
      files.  The result is undefined behavior.

      As if this wasn't enough, if the explicit specialization could
      match two separate function templates then the result you obtain
      could depend on which function templates are in scope.

      See also the next message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1577" id="1577">1577</a></td>
<td><pre>  Partial or explicit specialialization does not occur in the same
      file as primary template 'Symbol' (Location) -- There is a danger
      in declaring an explicit specialization or a partial
      specialization in a file other than that which holds the primary
      class template.  The reason is that a given implicit
      specialization will differ depending on what headers it sees.  It
      can easily differ from module to module and undefined behavior
      can be the result.

      See also Warning 1576 which diagnoses a similar problem with
      function templates.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1578" id="1578">1578</a></td>
<td><pre>  Pointer member 'Symbol' (Location) neither freed nor zeroed by
      cleanup function -- The indicated member is a non-static data
      member of a class that was apparently not cleared by a function
      that had previously been given the cleanup semantic.  By clearing
      we mean that the pointer was either zeroed or the storage
      associated with the pointer released via the free function or its
      semantic equivalent or some form of delete.  See also Warning
      1540.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1579" id="1579">1579</a></td>
<td><pre>  Pointer member 'Symbol' (Location) might have been freed by a
      separate function but no '-sem(Name,cleanup)' was seen -- A class
      data member (whose name and location are indicated in the
      message) was not directly freed by the class destructor.  There
      was a chance that it was cleared by a separately called member
      function.  If this is the case you may follow the advice given in
      the message and use a semantic option to inform PC-lint/FlexeLint
      that the separately called function is in fact a 'cleanup'
      function.  For example:
     
              class A {
                      int *p;
                  public:
                      void release_ptrs();
                      ~A() { release_ptrs(); }
                      };
     
      Here release_ptrs() is presumably serving as a cleanup function
      for the destructor ~A::A().  To inform PC-lint/FlexeLint of this
      situation, use the option:
     
              -sem( A::release_ptrs, cleanup )
     
      A separate message (Warning 1578) will be issued if the cleanup
      function fails to clear all pointers.  See also Warning 1566.


            ------ 19.10 C++ Informational Messages ------

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1701" id="1701">1701</a></td>
<td><pre>  redundant access-specifier 'String' -- The given access specifier
      (one of 'public', 'private' or 'protected') has been repeated.
      [11, 11.1]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1702" id="1702">1702</a></td>
<td><pre>  operator 'Name' is both an ordinary function 'String' and a
      member function 'String' -- In attempting to resolve the
      definition of an operator it was found that the same operator was
      declared as both a member function and a non-member function.
      Was this intended?  Symmetric binary operators (such as '+', '-',
      '==', '&gt;', etc.) are usually defined external to a class
      definition so that they can support non-objects on the left hand
      side.  [11, 13.4.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1703" id="1703">1703</a></td>
<td><pre>  Function 'String' arbitrarily selected.  Refer to Error 'Integer'
      -- This informational message is given with error numbers 1023,
      1024, 1025 and 1026.  These are issued when an error is
      encountered during the overload resolution process, and is issued
      merely to indicate which function was arbitrarily selected.  [11,
      13.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1704" id="1704">1704</a></td>
<td><pre>  Constructor 'Symbol' has private access specification -- A
      private constructor is legal and has its uses but can also result
      in messages that are difficult to interpret.  If you use private
      constructors as a programming technique then you may suppress
      this message with a -e1704.  But it's probably better to suppress
      this on a constructor by constructor basis using -esym.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1705" id="1705">1705</a></td>
<td><pre>  static class members may be accessed by the scoping operator -- A
      static class member was accessed using a class object and -&gt; or .
      notation.  For example:

            s.member
      or
            p-&gt;member

      But an instance of the object is not necessary.  It could just as
      easily have been referenced as:

            X::member

      where X is the class name.  [10, 9.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1706" id="1706">1706</a></td>
<td><pre>  Declaration with scope operator is unusual within a class --
      Class members within a class are not normally declared with the
      scope operator.  For example:

            class X  {  int X::n; ...

      will elicit this message.  If the (redundant) class specification
      (X::) were replaced by some different class specification and the
      declaration was not friend an error (1040) would be issued.  [11,
      9.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1707" id="1707">1707</a></td>
<td><pre>  static assumed for String -- operator new( ) and operator delete(
      ), when declared as member functions, should be declared as
      static.  They do not operate on an object instantiation (implied
      this pointer).  [11, 12.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1708" id="1708">1708</a></td>
<td><pre>  typedef 'Symbol' not declared as "C" conflicts with Location -- A
      typedef symbol which was previously declared as extern "C" was
      not so declared at the current location.  This is not considered
      as serious a situation as is indicated by message 1065 which is
      given for external function and variable names.  If this is your
      programming style you may suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1709" id="1709">1709</a></td>
<td><pre>  typedef 'Symbol' declared as "C" conflicts with Location -- A
      typedef symbol was previously not declared as extern "C" but is
      so declared at the current location.  This is not considered as
      serious a situation as is indicated by message 1066 which is
      given for external function and variable names.  If this is your
      programming style you may suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1710" id="1710">1710</a></td>
<td><pre>  An implicit 'typename' was assumed -- This message is issued when
      the standard requires the use of 'typename' to disambiguate the
      syntax within a template where it may not be clear that a name is
      the name of a type or some non-type.  (See C++ Standard [10],
      Section 14.6, Para 2).  Consider:
     
          template&lt; class T &gt; class A
              {
              T::N x;    // Info 1710
              };
     
      Many compilers will accept this construct since the only
      interpretation consistent with valid syntax is that T::N
      represents a type.  (But if the 'x' weren't there it would be
      taken as an access declaration and more frequently would be a
      non-type).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1711" id="1711">1711</a></td>
<td><pre>  class 'Symbol' (Location) has a virtual function but is not
      inherited -- The given class has a virtual function but is not
      the base class of any derivation.  Was this a mistake?  There is
      no advantage to making member functions virtual unless their
      class is the base of a derivation tree.  In fact, there is a
      disadvantage because there is a time and space penalty for
      virtual functions.  This message is not given for library classes
      and is suppressed for unit checkout.  [13, 4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1712" id="1712">1712</a></td>
<td><pre>  default constructor not defined for class 'Name' -- A class was
      defined with one or more constructors but none of these could be
      used as a (0 argument) default constructor.  Is this an omission?
      The default constructor is used in declarations and for new when
      no explicit initialization is given.  It is also used when the
      class is a base class and no mem-initializer is given.  It is
      used for arrays as well.  A default constructor should therefore
      be omitted only for good reason.  If you have such a good reason
      for class X you can employ option -esym(1712,X).  [19]


</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1713" id="1713">1713</a></td>
<td><pre>  Parentheses have inconsistent interpretation -- An expression of
      the form:
     
              new T()
     
      is supposed to produce a default initialized allocation of type
      T.  If T is a POD type (Plain Old Data type) it is supposed to be
      initialized to 0.  Since this change was made relatively late in
      the draft leading to the standard, many compilers do not yet
      support this construct.  If your compiler does support the
      construct and you have no intention of porting your application
      to any other compiler, suppress this message.  Alternatively,
      code this as:
     
              new T
     
      and initialize the result explicitly.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1714" id="1714">1714</a></td>
<td><pre>  Member function 'Symbol' (Location) not referenced -- A member
      function was not referenced.  This message is automatically
      suppressed for unit checkout (-u) and for members of a library
      class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1715" id="1715">1715</a></td>
<td><pre>  static member 'Symbol' (Location) not referenced -- A static data
      member of a class was not referenced.  This message is
      automatically suppressed for unit checkout (-u) and for members
      of a library class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1716" id="1716">1716</a></td>
<td><pre>  Virtual member function 'Symbol' (Location) not referenced -- A
      virtual member function was apparently not referenced.  Not only
      was the function itself not referenced but the function or
      functions that it overrides were not referenced either.  The
      message is not given if the member function itself or any member
      function that it overrides is a library member function.  This is
      because the original virtual function may be called implicitly by
      the library.

      This message is suppressed for unit checkout (-u).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1717" id="1717">1717</a></td>
<td><pre>  empty prototype for function declaration, assumed '(void)' -- An
      empty prototype, as in:

            void  f( );

      has a different meaning in C than in C++.  In C it says nothing
      about the arguments of the function; in C++, it says there are no
      arguments.  This message is not given for member function
      declarations or for function definitions.  Rather, weaker
      Elective Notes (1917 and 1918) are given.  This is because the
      chance of ambiguity does not exist in these cases.  [11, 8.2.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1718" id="1718">1718</a></td>
<td><pre>  expression within brackets ignored -- In the expression:

            delete  [ expression ]  p

      the expression is ignored.  The expression is a vestige of an
      earlier time when this information provided a count of the number
      of items in the array being released.  Note that empty square
      brackets are considered necessary for deleting an array.  This is
      a complaint directed toward the expression within the brackets
      not the brackets themselves.  [11, 5.3.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1719" id="1719">1719</a></td>
<td><pre>  assignment operator for class 'Symbol' has non-reference
      parameter -- The typical assignment operator for a class is of
      the form:

            X&amp; operator =(const X &amp;)

      If the argument is not a reference then your program is subject
      to implicit function calls and less efficient operation.  [11,
      13.4.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1720" id="1720">1720</a></td>
<td><pre>  assignment operator for class 'Symbol' has non-const parameter --
      The typical assignment operator for a class is of the form:

            X&amp; operator =(const X &amp;)

      If the argument is not const then your program will not be
      diagnosed as completely as it might otherwise be.  [11, 13.4.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1721" id="1721">1721</a></td>
<td><pre>  operator =( ) for class 'Symbol' is not assignment operator --
      The assignment operator for a class has the form:

            X&amp; operator =(const X &amp;)

      A member function whose name is operator =, but which doesn't
      have that form, is not an assignment operator.  This could be a
      source of subtle confusion for a program reader.  If this is not
      an error you may selectively suppress this message for the given
      class.  [11, 13.4.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1722" id="1722">1722</a></td>
<td><pre>  assignment operator for class 'Symbol' does not return a
      reference to class -- The typical assignment operator for a class
      X is of the form:

            X&amp; operator =(const X &amp;)

      The reason for returning a reference to class is to support
      multiple assignment as in:

            a = b = c

      [11, 13.4.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1724" id="1724">1724</a></td>
<td><pre>  Argument to copy constructor for class 'Symbol' should be a const
      reference -- A copy constructor for class X is typically declared
      as:

            X( const X &amp; );

      If you leave off the 'const' then some diagnostics will not be
      possible.  [19]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1725" id="1725">1725</a></td>
<td><pre>  class member 'Symbol' is a reference -- There are a number of
      subtle difficulties with reference data members.  If a class
      containing a reference is assigned, the default assignment
      operator will presumably copy the raw underlying pointer.  This
      violates the principle that a reference's underlying pointer,
      once established, is never modified.  Some compilers protect
      against this eventuality by refusing to create a default
      assignment operator for classes containing references.  Similar
      remarks can be made about copy constructors.  If you are careful
      about how you design your copy constructors and assignment
      operators, then references within classes can be a useful
      programming technique.  They should not, however, be employed
      casually.  [21, 2.1.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1726" id="1726">1726</a></td>
<td><pre>  taking address of overloaded function name 'Symbol' -- A
      reference is being made to an overloaded function without an
      immediately following '('.  Thus there is no argument list to
      distinguish which function is intended.  Resolution of the
      overloaded name can only be made by analyzing the destination.
      Is this what the programmer intended? [11, 13.3]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1727" id="1727">1727</a></td>
<td><pre>  inline 'Symbol' not previously defined inline at (Location) -- A
      function declared or defined inline was not previously declared
      inline.  Was this intended?  If this is your standard practice
      then suppress this message.  [11, 9.3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1728" id="1728">1728</a></td>
<td><pre>  Symbol 'Symbol' was previously defined inline at (Location) -- A
      function was previously declared or defined inline.  The inline
      modifier is absent from the current declaration or definition.
      Was this intended?  If this is your standard practice then
      suppress this message.  [11, 9.3.2]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1729" id="1729">1729</a></td>
<td><pre>  Initializer inversion detected for member 'Symbol' -- In a
      constructor initializer the order of evaluation is determined by
      the member order not the order in which the initializers are
      given.  At least one of the initializers was given out of order.
      Was there a reason for this?  Did the programmer think that by
      changing the order that he/she would affect the order of
      evaluation?  Place the initializers in the order of their
      occurrence within the class so that there can be no mistaken
      assumptions.  [12, Item 13]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1730" id="1730">1730</a></td>
<td><pre>  class/struct inconsistency for symbol 'Symbol' (conflicts with
      Location) -- An object is declared both with the keyword class
      and with the keyword struct.  Though this is legal it is suspect.
      [11, 7.1.6]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1732" id="1732">1732</a></td>
<td><pre>  new in constructor for class 'Name' which has no assignment
      operator -- Within a constructor for the cited class, there
      appeared a new.  However, no assignment operator was declared for
      this class.  Presumably some class member (or members) points to
      dynamically allocated memory.  Such memory is not treated
      properly by the default assignment operator.  Normally a custom
      assignment operator would be needed.  Thus, if x and y are both
      of type Symbol

            x = y;

      will result in pointer duplication.  A later delete would create
      chaos.  [12, Item 11]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1733" id="1733">1733</a></td>
<td><pre>  new in constructor for class 'Name' which has no copy constructor
      -- Within a constructor for the cited class, there appeared a
      new.  However, no copy constructor was declared for this class.
      Presumably, because of the new, some class member (or members)
      points to dynamically allocated memory.  Such memory is not
      treated properly by the default copy constructor.  Normally a
      custom copy constructor would be needed.  [12, Item 11]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1734" id="1734">1734</a></td>
<td><pre>  Had difficulty compiling template function: 'Symbol' -- At
      template wrap-up time where there is an attempt to 'compile' each
      template function according to arguments provided, the cited
      function could not be processed fully.  The difficulty may be the
      result of syntax errors cited earlier and if these errors are
      repaired then this message should go away.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1735" id="1735">1735</a></td>
<td><pre>  Virtual function 'Symbol' has default parameter -- A virtual
      function was detected with a default parameter.  For example:
     
                class B
                    {
                    virtual void f( int n = 5 );
                    ...
                    };

      The difficulty is that every virtual function f overriding this
      virtual function must contain a default parameter and its default
      parameter must be identical to that shown above.  If this is not
      done, no warnings are issued but behavior may have surprising
      effects.  This is because when f( ) is called through a base
      class pointer (or reference) the function is determined from the
      actual type (the dynamic type) and the default argument is
      determined from the nominal type (the static type).  [12, Item
      38].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1736" id="1736">1736</a></td>
<td><pre>  Redundant access specifier (String) -- An access specifier (one
      of public, private, or protected as shown in String) is
      redundant.  That is, the explicitly given access specifier did
      not have to be given because an earlier access specifier of the
      same type is currently active.  This message is NOT given for an
      access specifier that is the first item to appear in a class
      definition. Thus
     
                class abc { private:  ...

      does not draw this message.  The reason this message is issued is
      because it is very easy to make the following mistake.
     
                class A
                    {
                  public:   // declare private members:
                    ...
                  public:   // declare public members:
                    ...

      In general there are no compiler warnings that would result from
      such an unintentional botch.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1737" id="1737">1737</a></td>
<td><pre>  Symbol 'Symbol' hides global operator new -- The indicated Symbol
      is a class member operator new.  It is not compatible with the
      global operator new and, moreover, no other operator new within
      the class is argument list compatible with the global operator
      new.  For this reason the user of these classes will get a
      surprise if he/she calls for new X where X is the class name.  It
      will be greeted with an error.  The solution is to define a
      single argument operator new as a class member.  [12, Item 9].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1738" id="1738">1738</a></td>
<td><pre>  non-copy constructor 'Symbol' used to initialize copy constructor
      -- In an initializer list for a copy constructor, a base class
      constructor was invoked.  However, this base class constructor
      was not itself a copy constructor.  We expect that copy
      constructors will invoke copy constructors.  Was this an
      oversight or was there some good reason for choosing a different
      kind of constructor?  If this was deliberate, suppress this
      message.  See also message 1538.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1739" id="1739">1739</a></td>
<td><pre>  Binary operator 'Symbol' should be non-member function -- The
      indicated function was declared as a member function.  There were
      a number of indicators to suggest that it should have been a
      non-member function.  The class, X of which it was a member has a
      constructor that could be used to convert numeric values to X.
      The parameter to the operator was X or its equivalent.  For this
      reason the operator would behave unsymmetrically.  A numeric
      value on the right hand side would be promoted but not a value on
      the left hand side.  For example, X op 27 would work but 27 op X
      would not.  [12, Item 19].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1740" id="1740">1740</a></td>
<td><pre>  pointer member 'Symbol' (Location) not directly freed or zero'ed
      by destructor -- A destructor did not free or zero a pointer
      member.  However, it did call out to another (non-const) member
      function which may have done the required work.  This
      Informational message is a companion to Warning 1540 which covers
      the situation where no member function is called from within the
      destructor.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1741" id="1741">1741</a></td>
<td><pre>  member 'Symbol' (Location) conceivably not initialized by
      constructor -- The indicated member symbol may not have been
      initialized by a constructor.  Was this an oversight?  There
      appears to be a path through a loop that does initialize the
      member and the warning is issued because it is not clear that the
      loop is always executed at least once.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1742" id="1742">1742</a></td>
<td><pre>  member 'Symbol' (Location) conceivably not initialized -- The
      indicated member symbol conceivably may not have been initialized
      by a constructor.  Was this an oversight?  Some of the execution
      paths that the constructor takes, do initialize the member.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1743" id="1743">1743</a></td>
<td><pre>  member 'Symbol' (Location) conceivably not initialized -- The
      indicated member symbol conceivably may not have been initialized
      prior to use.  Either this is in a constructor where it is
      presumed that no members are pre-initialized or this is after a
      statement which will remove its initialization such as a delete
      or a free.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1744" id="1744">1744</a></td>
<td><pre>  member 'Symbol' (Location) possibly not initialized by private
      constructor -- The designated member was possibly not initialized
      by a private constructor.  This message is similar to messages
      1401, 1541 and 1741 which are given for ordinary (non private)
      constructors.  It is given a special error number because a
      private constructor may be one that, by design, is never called
      and variables may be deliberately left uninitialized.  In that
      case this message should be suppressed.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1745" id="1745">1745</a></td>
<td><pre>  member 'Symbol' (Location) not assigned by private assignment
      operator -- The indicated Symbol was not assigned by a private
      assignment operator.  This is very much like Warning 1539 except
      that the assignment operator in question is private.  A private
      assignment operator may simply be a device to thwart unintended
      use of the assignment operator.  In this case you may not care
      about unassigned members.  If this is so, suppress this message.

      The message is not given for const members or reference members.
      [12, Item 16]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1746" id="1746">1746</a></td>
<td><pre>  parameter 'Symbol' of function 'Symbol' could be made const
      reference -- The indicated parameter is a candidate to be
      declared as a const reference.  For example:
     
                void f( X x )
                    {
                    // x not modified.
                    }

      Then the function definition can be replaced with:
     
                void f( const X &amp;x )
                    {
                    // x not modified.
                    }

      The result is more efficient since less information needs to be
      placed onto the stack and a constructor need not be called.

      The message is only given with class-like arguments (including
      struct's and union's) and only if the parameter is not
      subsequently modified or potentially modified by the function.
      The parameter is potentially modified if it is passed to a
      function whose corresponding parameter is a reference (not const)
      or if its address is passed to a non-const pointer.  [12, Item
      22].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1747" id="1747">1747</a></td>
<td><pre>  binary operator 'Symbol' returning a reference -- An
      operator-like function was found to be returning a reference.
      For example:
     
                X &amp;operator+ ( X &amp;, X &amp; );

      This is almost always a bad idea.  [12, Item 23].  You normally
      can't return a reference unless you allocate the object, but then
      who is going to delete it.  The usual way this is declared is:
     
                X operator+ ( X &amp;, X &amp; );

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1748" id="1748">1748</a></td>
<td><pre>  non-virtual base class 'Name' included twice in class 'Name' --
      Through indirect means, a given class was included at least twice
      as a base class for another class.  At least one of these is not
      virtual.  Although legal, this may be an oversight.  Such base
      classes are usually marked virtual resulting in one rather than
      two separate instances of the base class.  This is done for two
      reasons.  First, it saves memory; second, references to members
      of such a base class will not be ambiguous.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1749" id="1749">1749</a></td>
<td><pre>  base class 'Symbol' of class 'Symbol' need not be virtual -- The
      designated base class is a direct base class of the second class
      and the derivation was specified as 'virtual'.  But the base
      class was not doubly included (using this link) within any class
      in the entire project.  Since a virtual link is less efficient
      than a normal link this may well be an unenlightened use of
      'virtual'. [23, Item 24].  The message is inhibited if unit
      checkout (-u) is selected.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1750" id="1750">1750</a></td>
<td><pre>  local template 'Symbol' (Location) not referenced -- A 'local'
      template is one that is not defined in a header file.  The
      template was not used in the module in which it was defined.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1752" id="1752">1752</a></td>
<td><pre>  catch parameter Integer is not a reference -- This message is
      issued for every catch parameter that is not a reference and is
      not numeric.  The problem with pointers is a problem of ownership
      and delete responsibilities; the problem with a non-ref object is
      the problem of slicing away derivedness [23, Item 13].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1753" id="1753">1753</a></td>
<td><pre>  Overloading special operator 'Symbol' -- This message is issued
      whenever an attempt is made to declare one of these operators as
      having some user-defined meaning:
     
                operator ||
                operator &amp;&amp;
                operator , 

      The difficulty is that the working semantics of the overloaded
      operator is bound to be sufficiently different from the built-in
      operators, as to result in possible confusion on the part of the
      programmer.  With the built-in versions of these operators,
      evaluation is strictly left-to-right.  With the overloaded
      versions, this is not guaranteed.  More critically, with the
      built-in versions of &amp;&amp; and ||, evaluation of the 2nd argument is
      conditional upon the result of the first.  This will never be
      true of the overloaded version. [23, Item 7].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1754" id="1754">1754</a></td>
<td><pre>  Expected symbol 'Symbol' to be declared for class 'Symbol' -- The
      first Symbol is of the form: operator op= where op is a binary
      operator.  A binary operator op was declared for type X where X
      is identified by the second Symbol.  For example, the appearance
      of:
     
                X operator+( const X &amp;, const X &amp; );

      somewhere in the program would suggest that a += version appear
      as a member function of class X.  This is not only to fulfill
      reasonable expectations on the part of the programmer but also
      because operator+= is likely to be more efficient than operator+
      and because operator+ can be written in terms of operator+=.
      [23, Item 22]

      The message is also given for member binary operators.  In all
      cases the message is not given unless the return value matches
      the first argument (this is the implicit argument in the case of
      a member function).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1755" id="1755">1755</a></td>
<td><pre>  global template 'Symbol' (Location) not referenced -- A 'global'
      template is one defined in a header file.  This message is given
      for templates defined in non-library header files.  The template
      is not used in any of the modules comprising the program.  The
      message is suppressed for unit checkout (-u).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1757" id="1757">1757</a></td>
<td><pre>  Discarded instance of post decrement/increment -- A postfix
      increment or postfix decrement operator was used in a context in
      which the result of the operation was discarded.  For example:
     
                X a;

                ... 
                a++;

      In such contexts it is just as correct to use prefix
      decrement/increment.  For example this could be replaced with:
     
                X a;

                ... 
                ++a;

      The prefix form is (or should be) more efficient than the postfix
      form because, in the case of user-defined types, it should return
      a reference rather than a value (see 1758 and 1759).  This
      presumes that the side effects of the postfix form are equivalent
      to those of the prefix form.  If this is not the case then either
      make them equivalent (the preferred choice) or turn this message
      off.  [23, Item 6].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1758" id="1758">1758</a></td>
<td><pre>  Prefix increment/decrement operator 'Symbol' returns a
      non-reference -- To conform with most programming expectations, a
      prefix increment/decrement operator should return a reference.
      Returning a reference is both more flexible and more efficient
      [23, Item 6].

      The expected form is as shown below:
     
                class X
                    {
                    X &amp; operator++( );     // prefix operator
                    X operator++( int );  // postfix operator
                    ...
                    };

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1759" id="1759">1759</a></td>
<td><pre>  Postfix increment/decrement operator 'Symbol' returns a
      reference. -- To conform with most programming expectations, a
      postfix increment/decrement operator should return a value as
      opposed to a reference.  [23, Item 6].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1760" id="1760">1760</a></td>
<td><pre>  Redundant template 'Symbol' defined identically at Location -- A
      template was defined identically in the same module.  Was this a
      mistake?

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1761" id="1761">1761</a></td>
<td><pre>  Declaration of function 'Symbol' hides overloaded function
      'Symbol' (Location) -- A function declaration hides an overloaded
      function.  This does not contribute to the overloaded-ness of the
      function but completely hides all the overloaded functions in
      some prior scope.  If this is your intent suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1762" id="1762">1762</a></td>
<td><pre>  Member function 'Symbol' could be made const -- The indicated
      (non-static) member function did not modify member data and did
      not call non-const functions.  Moreover, it does not make any
      deep modification to the class member.  A modification is
      considered deep if it modifies information indirectly through a
      class member pointer.  Therefore it could and probably should be
      declared as a const member function.  See also Info 1763 and
      Elective Note 1962.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1763" id="1763">1763</a></td>
<td><pre>  Member function 'Symbol' marked as const indirectly modifies
      class -- The designated symbol is a member function declared as
      const.  Though technically valid, the const may be misleading
      because the member function modifies (or exposes) information
      indirectly referenced by the object.  For example:
     
            class X
                {
                char *pc;
                char &amp; get(int i) const { return pc[i]; }
                };

      results in Info 1763 for function X::get.  This is because the
      function exposes information indirectly held by the class X.

      Experts [24] recommend that a pair of functions be made available
      in this situation:
     
            class X
                {
                char *pc;
                const char &amp; get(int i) const { return pc[i]; }
                char &amp; get(int i) { return pc[i]; }
                };

      In this way, if the object is const then only the const function
      will be called which will return the protected reference.
      Related messages are also 1762 and 1962.  See also [12, Item 29]
      for a further description.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1764" id="1764">1764</a></td>
<td><pre>  Reference parameter 'Symbol' (Location) could be declared const
      reference -- As an example:

            int f( int &amp; k ) { return k; }

      can be redeclared as:

            int f( const int &amp; k ) { return k; }

      Declaring a parameter a reference to const offers advantages that
      a mere reference does not.  In particular, you can pass
      constants, temporaries and const types into such a parameter
      where otherwise you may not.  In addition it can offer better
      documentation.

      Other situations in which a const can be added to a declaration
      are covered in messages 818, 952, 953 and 954.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1768" id="1768">1768</a></td>
<td><pre>  Virtual function 'Symbol' has an access (String) different from
      the access (String) in the base class (String) -- An overriding
      virtual function has an access (public, protected or private) in
      the derived class different from the access of the overridden
      virtual function in the base class.  Was this an oversight?
      Since calls to the overriding virtual function are usually made
      through the base class, making the access different is unusual
      (though legal).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1769" id="1769">1769</a></td>
<td><pre>  Member or base class 'Symbol' has no constructor -- An
      initializer of the form Symbol( ) is ignored.  Symbol is either a
      class member with a class, struct, or union type or is a base
      class.  In either case the class (or struct or union) has no
      constructor and hence what appears to be an initialization is
      not.  See also messages 1557 and 1558.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1770" id="1770">1770</a></td>
<td><pre>  function 'Symbol' defined without function 'String' -- A typical
      Info 1770 message is:
     
        function 'operator new(unsigned)' defined without function
            'operator delete'

      There are three others:
            operator delete without an operator new,
            operator new[] without an operator delete[], and
            operator delete[] without an operator new[].

      In general it is not a good idea to create one of these functions
      without the other in the pairing.  [23, Item 27]

      You can suppress any of these without suppressing them all.
      Simply do a -esym(1770,name) where name is the first function
      named in the message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1771" id="1771">1771</a></td>
<td><pre>  function 'Symbol' replaces global function -- This message is
      given for operator new and operator delete (and for their []
      cousins) when a definition for one of these functions is found.
      Redefining the built-in version of these functions is not
      considered sound programming practice.  [23, Item 27]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1772" id="1772">1772</a></td>
<td><pre>  Assignment operator 'Symbol' is not returning *this -- The
      assignment operator should return *this.  This is to allow for
      multiple assignments as in:

            a = b = c;

      It is also better to return the object that has just been
      modified rather than the argument.  [12, Item 15]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1773" id="1773">1773</a></td>
<td><pre>  Attempt to cast away const (or volatile) -- An attempt was made
      to cast away const.  This can break the integrity of the const
      system.  This message will be suppressed if you use const_cast.
      Thus:
     
            char *f( const char * p )
                {
                if( test( ) )
                    return (char *) p;   // Info 1773
                else
                    return const_cast<char *="">(p);   // OK
                }

      See [12, Item 21].

</char></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1774" id="1774">1774</a></td>
<td><pre>  Could use dynamic_cast to downcast ptr to polymorphic type
      'Symbol' -- A downcast was detected of a pointer to a polymorphic
      type (i.e., one with virtual functions).  A dynamic_cast could be
      used to cast this pointer safely.  For example:
     
            class B { virtual ~B( ); };
            class D : public B {};
            ...
            D *f( B *p )
                {
                return dynamic_cast<d*>(p);
                }

      In the above example, if p is not a pointer to a D then the
      dynamic cast will result in a NULL pointer value.  In this way,
      the validity of the conversion can be directly tested.

      B needs to be a polymorphic type in order to use dynamic_cast.
      If B is not polymorphic, message 1939 is issued.

</d*></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1775" id="1775">1775</a></td>
<td><pre>  catch block does not catch any declared exception -- A catch
      handler does not seem to catch any exceptions.  For example:
     
        try { f( ); }
        catch( B&amp; ) {}
        catch( D&amp; ) {}      // Info 1775
        catch( ... ) {}
        catch( char * ) {}  // Info 1775

      If f( ) is declared to throw type D, and if B is a public base
      class of D, then the first catch handler will process that
      exception and the second handler will never be used.  The fourth
      handler will also not be used since the third handler will catch
      all exceptions not caught by the first two.

      If f( ) is not declared to throw an exception then Info 1775 will
      be issued for all four catch handlers.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1776" id="1776">1776</a></td>
<td><pre>  Converting string literals to Type is not const safe (Context) --
      A string literal, according to Standard C++ is typed an array of
      const char.  This message is issued when such a literal is
      assigned to a non-const pointer.  For example:

     
          char *p = "string";
     

      will trigger this message.  This pointer could then be used to
      modify the string literal and that could produce some very
      strange behavior.

      Such an assignent is legal but "deprecated" by the C++ Standard.
      The reason for not ruling it illegal is that numerous existing
      functions have their arguments typed as char * and this would
      break working code.

      Note that this message is only given for string literals.  If an
      expression is typed as pointer to const char in some way other
      than via string literal, then an assignment of that pointer to a
      non-const pointer will receive a more severe warning.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1777" id="1777">1777</a></td>
<td><pre>  Template recursion limit (Integer) reached, use -tr_limit(n) --
      It is possible to write a recursive template that will contain a
      recursive invocation without an escape clause.  For example:

     
              template <class t=""> class A { A&lt; A &gt; x; };
              A<int> a;
     
      This will result in attempts to instantiate:
     
              A<int>
              A<a<int>&gt;
              A<a<a<int>&gt;&gt;
              ...
     
      Using the -vt option (turning on template verbosity) you will see
      the sequence in action.  Accordingly we have devised a scheme to
      break the recursion when an arbitrary depth of recursion has been
      reached (at this writing 75).  This depth is reported in the
      message.  As the message suggests, this limit can be adjusted so
      that it equals some other value.

      When the limit is reached, a complete type is not used in the
      definition of the last specialization in the sequence but
      processing goes on.  The message can be suppressed in most cases
      with no ill effects.

</a<a<int></a<int></int></int></class></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1778" id="1778">1778</a></td>
<td><pre>  Assignment of string literal to variable 'Symbol' (Location) is
      not const safe -- This message is issued when a string literal is
      assigned to a variable whose type is a non-const pointer.  The
      name of the variable appears in the message as well as the
      location at which the variable was defined (or otherwise
      declared).  For example:
     
              char *p;  p = "abc";
     
      The message is issued automatically (i.e. by default) for C++.
      For C, to obtain the message, you need to enable the
      Strings-are-Const flag (+fsc).  This message is similar to
      message 1776 except that it is issued whenever a string constant
      is being assigned to a named destination.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1780" id="1780">1780</a></td>
<td><pre>  Returning address of reference parameter 'Symbol' -- The address
      of a parameter that has been declared as being a reference to a
      const is being returned from a function.  The danger of this is
      that the reference may designate a temporary variable that will
      not persist long after the call.  For example:
     
              const int *f( const int &amp; n )
                  { return &amp;n; }
              int g();
              const int *p = f( g() );
     
      Here, p points to a temporary value whose duration is not
      guaranteed.  If the reference is not const then you will get
      Elective Note 1940.

      This is an example of the Linton Convention as described by
      Murray [21].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1781" id="1781">1781</a></td>
<td><pre>  Passing address of reference parameter 'Symbol' into caller
      address space -- The address of a parameter that has been
      declared as being a reference to a const is being assigned to a
      place outside the function.  The danger of this is that the
      reference may designate a temporary variable that will not
      persist long after the call.  For example:
     
              void f( const int &amp; n, const int **pp )
                  { *pp = &amp;n; }
              int g();
              const int *p;
              ... f( g(), &amp;p );
     
      Here, p will be made to point to a temporary value whose duration
      is not guaranteed.  If the reference is not const then you will
      get Elective Note 1940.

      This is an example of the Linton Convention as described by
      Murray [21].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1782" id="1782">1782</a></td>
<td><pre>  Assigning address of reference parameter 'Symbol' to a static
      variable -- The address of a parameter that has been declared as
      being a reference to a const is being assigned to a static
      variable.  The danger of this is that the reference may designate
      a temporary variable that will not persist long after the call.
      For example:
     
              const int *p;
              void f( const int &amp; n )
                  { p = &amp;n; }
              int g();
              ... f( g() );
     
      Here, p will be made to point to a temporary value whose duration
      is not guaranteed.  If the reference is not const then you will
      get Elective Note 1940.

      This is an example of the Linton Convention as described by
      Murray [21].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1784" id="1784">1784</a></td>
<td><pre>  Symbol 'Symbol' previously declared as "C", compare with Location
      -- A symbol is being redeclared in the same module.  Whereas
      earlier it had been declared with an extern "C" linkage, in the
      cited declaration no such linkage appears.  E.g.
     
              extern "C" void f(int);
              void f(int);                // Info 1784
     
      In this case the extern "C" prevails and hence this inconsistency
      probably represents a benign redeclaration.  Check to see which
      linkage is most appropriate and amend or remove the declaration
      in error.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1785" id="1785">1785</a></td>
<td><pre>  Implicit conversion from Boolean (Context) (Type to Type) -- A
      Boolean expression was assigned (via assignment, return, argument
      passing or initialization) to an object of some other type.  Was
      this the programmer's intent?  The use of a cast will prevent
      this message from being issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1786" id="1786">1786</a></td>
<td><pre>  Implicit conversion to Boolean (Context) (Type to Type) -- A
      non-Boolean expression was assigned (via assignment, return,
      argument passing or initialization) to an object of type Boolean.
      Was this the programmer's intent?  The use of a cast will prevent
      this message from being issued.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1787" id="1787">1787</a></td>
<td><pre>  Access declarations are deprecated in favor of using declarations
      -- The C++ standard ([10] section 7.3.3) specifically deprecates
      the use of access declarations.  The preferred syntax is the
      using declaration.  For example:
     
              class D : public B
                  {
                  B::a;           // message 1787
                  using B::a;     // preferred form produces no message
                  };
     
</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1788" id="1788">1788</a></td>
<td><pre>  Variable 'Symbol' (Location) (type 'Name') is referenced only by
      its constructor or destructor -- A variable has not been
      referenced other than by the constructor which formed its initial
      value or by its destructor or both.  The location of the symbol
      and also its type is given in the message.  For example:
     
              class A {  A(); };
              void f()
                  {
                  A a;
                  }
     
      will produce a 1788 for variable 'a' and for type 'A'.

      It very well may be that this is exactly what the programmer
      wants to do in which case you may suppress this message for this
      variable using the option -esym(1788,a).  It may also be that the
      normal use of class A is to employ it in this fashion.  That is,
      to obtain the effects of construction and, possibly, destruction
      but have no other reference to the variable.  In this case the
      option of choice would be -esym(1788,A).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1789" id="1789">1789</a></td>
<td><pre>  Template constructor 'Symbol' cannot be a copy constructor --
      This message is issued for classes for which a copy constructor
      was not defined but a template constructor was defined.  The C++
      standard specifically states that a template constructor will not
      be used as a copy constructor.  Hence a default copy constructor
      is created for such a class while the programmer may be deluded
      into thinking that the template will be employed for this
      purpose.  [28, Item 5].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1790" id="1790">1790</a></td>
<td><pre>  Base class 'Symbol' has no non-destructor virtual functions -- A
      public base class contained no virtual functions except possibly
      virtual destructors.  There is a school of thought that public
      inheritance should only be used to interject custom behavior at
      the event of virtual function calls.  To quote from Marshall
      Cline, "Never inherit publicly to reuse code (in the base class);
      inherit publicly in order to be reused (by code that uses base
      objects polymorphically)" [28, Item 22].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1791" id="1791">1791</a></td>
<td><pre>  No token on this line follows the 'return' keyword -- A line is
      found that ends with a return keyword and with no other tokens
      following.  Did the programmer forget to append a semi-colon? The
      problem with this is that the next expression is then consumed as
      part of the return statement.  Your return might be doing more
      that you thought.  For example:
     
              void f( int n, int m )
                  {
                  if( n &lt; 0 ) return // do not print when n is negative
                  print( n );
                  print( m );
                  }
     
      Assuming print() returns void, this is entirely legal but is
      probably not what you intended.  Instead of printing n and m, for
      n not negative you print just m.  For n negative you print n.

      To avoid this problem always follow the return keyword with
      something on the same line.  It could be a semi-colon, an
      expression or, for very large expressions, some portion of an
      expression.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1792" id="1792">1792</a></td>
<td><pre>  Assignment operator for class 'Symbol' does not return a const
      reference to class -- The typical use of an assignment operator
      for class C is to assign new information to variables of class C.
      If this were the entire story there would be no need for the
      assignment operator to return anything.  However, it is
      conventional to support chains of assignment as in:
     
              C x, y, z;
              ...
              x = y = z;
              // parsed as x = (y = z);
     
      For this reason assignment normally returns a reference to the
      object assigned the value.  For example, assignment (y = z) would
      return a reference to y.

      Since it is almost never the case that this variable is to be
      reassigned, i.e. we almost never wish to write:
     
              (x = y) = z;    // unusual
     
      as a general rule it is better to make the assignment operator
      return a const reference.  This will generate a warning when the
      unusual case is attempted.

      But experts differ.  Some maintain that in order to support
      non-const member functions operating directly on the result of an
      assignment as in:
     
              (x = y).mangle();
     
      where, as its name suggests, mangle is non-const it would be
      necessary for the return value of assignment to be non-const.
      Others would argue that this code could easily be replaced by a
      pair of expressions but if you want to support this style of
      programming then you should suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1793" id="1793">1793</a></td>
<td><pre>  While calling 'Symbol': Initializing the implict object parameter
      'Type' (a non-const reference) with a non-lvalue -- A non-static
      and non-const member function was called and an rvalue (a
      temporary object) of class type was used to initialize the
      implicit object parameter.  This is legal (and possibly
      intentional) but suspicious.  Consider the following.
     
              struct A { void f(); };
              ...
              A().f();          // Info 1793
              ...
     
      In the above the 'non-static, non-const member function' is
      A::f().  The 'implicit object parameter' for the call to A::f()
      is A(), a temporary.  Since the A::f() is non-const it presumably
      modifies A().  But since A() is a temporary, any such change is
      lost.  It would at first blush appear to be a mistake.

      The Standard normally disallows binding a non-const reference to
      an rvalue (see Error 1058 in the manual), but as a special case
      allows it for the binding of the implicit object parameter in
      member function calls.  Some popular libraries take advantage of
      this rule in a legitimate way.  For example, the GNU
      implementation of std::vector<bool>::operator[] returns a
      temporary object of type std::_Bit_reference -- a class type with
      a non-const member operator=().  _Bit_reference serves a dual
      purpose.  If a value is assigned to it, it modifies the original
      class through its operator=().  If a value is extracted from it,
      it obtains that value from the original class through its
      operator bool().

      Probably the best policy to take with this message is to examine
      instances of it and if this is a library invocation or a
      specially designed class, then suppress the message with a
      -esym() option.

</bool></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1794" id="1794">1794</a></td>
<td><pre>  Using-declaration introduces 'Name' (Location), which has the
      same parameter list as 'Name' (Location), which was also
      introduced here by previous using-declaration 'Name' (Location)
      -- This kind of scenario is perhaps best explained by way of
      example:
     
              struct A{};
              // Library 1:
              namespace N { int f(const A&amp;); int f(char*); }
              // Library 2:
              namespace Q { int f(const A&amp;); int f(int); }
              // Non-library code:
              using N::f;
              using Q::f; // Info 1794 here
     
      According to the ISO Standard, <ref,14. added="" bibliography,14.="">,
      [34], the names of N::f(A) and Q::f(A) will coexist in the global
      namespace (along with the names of the other overloads of f).
      This alone does not make the program ill-formed.  (For that you
      would have to make some use of the name 'f' that resulted in
      overload resolution where f(A) is selected.) However, a user of N
      and Q may be surprised to find that both library namespaces
      supply a function f that operates on ::A objects, and that both
      have been introduced into the same scope.  So to avoid confusion,
      the user may opt to do away with the using-declarations and just
      refer to the various f()'s with qualified-ids.
</ref,14.></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1795" id="1795">1795</a></td>
<td><pre>  Defined template 'Symbol' was not instantiated. -- The named
      template was defined but not instantiated.  As such, the template
      either represents superfluous code or indicates a logic error.

      The 'template' in the message could also be a temploid.  A
      temploid is defined as either a template or a member of a
      temploid.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1796" id="1796">1796</a></td>
<td><pre>  Explicit specialization of overloaded function template 'Symbol'
      -- A pair of overloaded function templates was followed by an
      explicit specialization.  For example:
     
              template&lt; class T &gt; void f( T );
              template&lt; class T &gt; void f( T* );
              template&lt;&gt; void f( char * p )
                  { printf( "%s\n", p ); }

     
      Confusion can arise in determining which of the two function
      templates the specialization is actually specializing.  This will
      lead to unexpected results when processing overload resolution
      since the specialization does not directly compete with the
      templates.  Both function templates compete with each other and
      it can be difficult to ascertain whether the specialization is
      invoked in any particular call.


                ------ 19.11 C++ Elective Notes ------

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1901" id="1901">1901</a></td>
<td><pre>  Creating a temporary of type 'Symbol' -- PC-lint/FlexeLint judges
      that a temporary needs to be created.  This occurs, typically,
      when a conversion is required to a user object (i.e. class
      object).  Where temporaries are created, can be an issue of some
      concern to programmers seeking a better understanding of how
      their programs are likely to behave.  But compilers differ in
      this regard.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1902" id="1902">1902</a></td>
<td><pre>  useless ';' follows '}' in function definition -- It is possible
      to follow a function body with a useless semi-colon.  This is not
      necessarily 'lint' to be removed but may be a preferred style of
      programming (as semi-colons are placed at the end of other
      declarations).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1904" id="1904">1904</a></td>
<td><pre>  Old-style C comment -- For the real bridge-burner one can hunt
      down and remove all instances of the /* ... */ form of comment.
      [12, Item 4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1905" id="1905">1905</a></td>
<td><pre>  implicit default constructor generated for class 'Name' -- A
      default constructor was not defined for a class but a base class
      or a member has a non-trivial default constructor and so a
      non-trivial default constructor is generated for this class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1907" id="1907">1907</a></td>
<td><pre>  implicit destructor generated for class 'Name' -- The named class
      does not itself have an explicit destructor but either had a base
      class that has a destructor or has a member class that has a
      destructor (or both).  In this case a destructor will be
      generated by the compiler.  [11, 12.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1908" id="1908">1908</a></td>
<td><pre>  'virtual' assumed for destructor'~Name( )' (inherited from base
      class 'Name( ) -- The destructor cited was inherited from a base
      class with a virtual destructor.  This word 'virtual' was omitted
      from the declaration.  It is common practice to omit this keyword
      when implied.  A warning is issued (1512) when a base class's
      destructor is not virtual.  See also 1909.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1909" id="1909">1909</a></td>
<td><pre>  'virtual' assumed, see:  function 'Symbol' (Location) -- The
      named function overrides a base class virtual function and so is
      virtual.  It is common practice to omit the virtual keyword in
      these cases although some feel that this leads to sloppy
      programming.  This message allows programmers to detect and make
      explicit which functions are actually virtual.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1911" id="1911">1911</a></td>
<td><pre>  Implicit call of constructor 'Symbol' (see text) -- The Symbol in
      the message is the name of a constructor called to make an
      implicit conversion.  This message can be helpful in tracking
      down hidden sources of inefficiencies.  [11, 12.1]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1912" id="1912">1912</a></td>
<td><pre>  Implicit call of conversion function from class 'Name' to type
      'Type' -- A conversion function (one of the form Symbol::operator
      Type ( )) was implicitly called.  This message can be helpful in
      tracking down hidden sources of inefficiencies.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1914" id="1914">1914</a></td>
<td><pre>  Default constructor 'Symbol' (Location) not referenced -- A
      default constructor was not referenced.  When a member function
      of a class is not referenced, you will normally receive an
      Informational message (1714) to that effect.  When the member
      function is the default constructor, however, we give this
      Elective Note instead.

      The rationale for this different treatment lay in the fact that
      many authors recommend defining a default constructor as a
      general principle.  Indeed we give an Informational message
      (1712) when a default constructor is not defined for a class.
      Therefore, if you are following a modus operandi of not always
      defining a default constructor you may want to turn off message
      1712 and turn on message 1914 instead.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1915" id="1915">1915</a></td>
<td><pre>  Overriding virtual function 'Symbol' is not marked with override
      -- A virtual function that overrides a base class function was
      not declared with the override virt-specifier.  This message is
      only emitted for C++11 and higher.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1916" id="1916">1916</a></td>
<td><pre>  Ellipsis encountered -- An ellipsis was encountered while
      processing the prototype of some function declaration.  An
      ellipsis is a way of breaking the typing system of C or C++.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1917" id="1917">1917</a></td>
<td><pre>  Empty prototype for String, assumed '(void)' -- This message is
      given when an empty prototype is detected either for a function
      definition or for a namespace declaration (the String specifies
      which).  Whereas we give an Informational Message (1717) when a
      (non-member) declaration contains no prototype, we give a much
      milder Elective Note when a definition does the same.  For
      example:

            int f( );                // Info 1717
            int f( ) { return 1; }   // Elective Note 1917

      The reason for this is that the declaration form has a different
      meaning in C and C++.  In C it is an incomplete declaration
      saying nothing about arguments.  In C++ the declaration says
      there are no arguments.  The definition, however, means the same
      in both languages.  See also message 1918.  [11, 8.2.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1918" id="1918">1918</a></td>
<td><pre>  empty prototype for member declaration, assumed (void) -- A
      function declaration within a class contains an empty prototype.
      This case is similar to Info 1717 which complains about an empty
      prototype outside a class.  It receives a lighter classification
      (Elective Note) because an empty prototype within a class cannot
      be ambiguous because C does not allow functions within classes.
      [11, 8.2.5]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1919" id="1919">1919</a></td>
<td><pre>  Multiple assignment operators for class 'Symbol' -- For a given
      class more than one function was declared whose name was
      'operator ='.  This is not necessarily a bad thing.  For example,
      a String class may very well have an assignment from char * and
      such an assignment may be advisable from an efficiency
      standpoint.  However, it represents a loss of elegance because
      there will almost certainly be a char * constructor and an
      assignment operator which will represent another way of achieving
      the same effect.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1920" id="1920">1920</a></td>
<td><pre>  Casting to a reference -- The ARM[11] (Section 5.4) states that
      reference casts are often 'misguided'.  However, too many
      programs are openly using reference casts to place such casts in
      the Informational category.  [11, 5.4]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1921" id="1921">1921</a></td>
<td><pre>  Symbol 'Symbol' not checking argument against sizeof(class) --
      This note is given for either operator new or operator delete
      when defined as member functions.  As member functions they are
      called when new (or delete) is applied to a class type or any
      derived class type.  The difficulty is with the derived class
      type.  Any specialized allocator is likely to be useless for a
      derived class type and hence experts suggest that a test be made
      of the size_t argument against sizeof(class).  Specifically
      PC-lint/FlexeLint is looking for one of:

                if( arg == sizeof(class) )
                if( arg != sizeof(class) )
                if( sizeof(class) == arg )
                if( sizeof(class) != arg )

      or the equivalent.  If any such function is found that is a
      member of a class that is the base of a derivation, then in
      addition to Note 1921, we issue Warning 1531.  (see Steve
      Simpson, "More on Memory Management", Dr. Dobb's Journal, August
      1994, p. 10).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1922" id="1922">1922</a></td>
<td><pre>  Symbol 'Symbol' not checking argument for NULL -- This message is
      given for a function operator delete which is not checking its
      parameter for being the NULL pointer.  We would normally expect
      to see some such check as:

                if( arg )
                if( arg == 0 )
                if( arg != NULL )

      etc.  Classes which have destructors will normally filter out
      passing the NULL pointer into the operator delete so that this
      message is only in the Elective Note category.  If there is no
      destructor you obtain a warning.  See Warning 1532.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1923" id="1923">1923</a></td>
<td><pre>  macro 'Symbol' could become const variable -- The designated
      macro could probably be replaced by a const variable.  A const
      variable is preferred in some quarters where, for example, a
      local debugger may not understand macros but would understand
      variables. [12, Item 1].

      The message is issued for macros containing at least one constant
      or constant equivalent (an earlier const-able macro or const
      variable) and no other variables or tokens such as ';' of a
      non-expression nature.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1924" id="1924">1924</a></td>
<td><pre>  C-style cast -- A C-style cast was detected.  This can be
      replaced by one of the newer C++ casts having the form:
      Name<type>(Expression) where Name is one of static_cast,
      dynamic_cast, const_cast or reinterpret_cast. [23, Item 2].

</type></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1925" id="1925">1925</a></td>
<td><pre>  Symbol 'Symbol' is a public data member -- The indicated Symbol
      is a public data member of a class.  If the class is introduced
      with the keyword struct the message is not issued.  In some
      quarters the use of public data members is deprecated.  The
      rationale is that if function calls replace data references in
      the public interface, the implementation can change without
      affecting the interface. [12, Item 20]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1926" id="1926">1926</a></td>
<td><pre>  Symbol 'Symbol's default constructor implicitly called -- A
      member of a class (identified by Symbol) did not appear in the
      constructor initialization list.  Since it had a default
      constructor this constructor was implicitly called.  Is this what
      the user intended? Some authorities suggest that all members
      should appear in the constructor initialization list.  [12, Item
      12].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1927" id="1927">1927</a></td>
<td><pre>  Symbol 'Symbol' did not appear in the constructor initializer
      list -- A member of a class (identified by Symbol) did not appear
      in a constructor initialization list.  If the item remains
      uninitialized through the whole of the constructor, a Warning
      1401 is issued.  Some authorities suggest that all members should
      appear in the constructor initialization list.  [12, Item 12].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1928" id="1928">1928</a></td>
<td><pre>  Symbol 'Name' did not appear in the constructor initializer list
      -- A base class (identified by Symbol) did not appear in a
      constructor initialization list.  If a constructor does not
      appear, then the default constructor is called.  This may or may
      not be valid behavior.  If a base class is missing from a copy
      constructor's initializer list, then a more severe Warning (1538)
      is issued.  [12, Item 12].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1929" id="1929">1929</a></td>
<td><pre>  function 'Symbol' returning a reference -- A non-member function
      was found to be returning a reference.  This is not normally
      considered good practice because responsibility for deleting the
      object is not easily assigned.  [12, Item 23].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1930" id="1930">1930</a></td>
<td><pre>  Conversion operator 'Symbol' found -- A conversion operator is a
      member function of the form:
     
                operator Type ( );

      This will be called implicitly by the compiler whenever an object
      (of the class type) is to be converted to type Type.  Some
      programmers consider such implicit calls to be potentially
      harmful leading to programming situations that are difficult to
      diagnose.  See for example [23, Item 5].

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1931" id="1931">1931</a></td>
<td><pre>  Constructor 'Symbol' can be used for implicit conversions -- A
      constructor was found that could be used for implicit
      conversions.  For example:
     
                class X
                    {
                  public:
                    X(int);
                    ...
                    };

      Here, any int (or type convertible to int) could be automatically
      converted to X.  This can sometimes cause confusing behavior [23,
      Item 5].  If this is not what was intended, use the keyword
      'explicit' as in:
     
                explicit X(int);

      This will also serve to suppress this message.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1932" id="1932">1932</a></td>
<td><pre>  Base class 'Symbol' is not abstract. -- An abstract class is a
      class with at least one pure virtual specifier.  At least one
      author has argued [23, Item 33] that all base classes should be
      abstract although this suggestion flies in the face of existing
      practice.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1933" id="1933">1933</a></td>
<td><pre>  Call to unqualified virtual function 'Symbol' from non-static
      member function -- A classical C++ gotcha is the calling of a
      virtual function from within a constructor or a destructor.  When
      we discover a direct call from a constructor or destructor to a
      virtual function we issue Warning 1506.  But what about indirect
      calls.  Suppose a constructor calls a function that in turn,
      perhaps through several levels of call, calls a virtual function.
      This could be difficult to detect.  Dan Saks [24] has suggested a
      compromise Guideline that "imposes few, if any, practical
      restrictions".  The Guideline, implemented by this Elective Note,
      issues a message whenever an unqualified virtual function is
      called by any other (non-static) member function (for the same
      'this' object).  For example:
     
            class X { virtual void f( ); void g( );  };

            void X::g( )
                {
                f( );        // Note 1933
                X::f( );     // ok -- non virtual call.
                }

      Even if total abstinence is unwarranted, turning on message 1933
      occasionally can be helpful in detecting situations when
      constructors or destructors call virtual functions.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1934" id="1934">1934</a></td>
<td><pre>  Shift operator 'Symbol' should be non-member function -- It has
      been suggested [12, Item 19] that you should never make a shift
      operator a member function unless you're defining ostream or
      istream (the message is suppressed in these two cases).  The
      reason is that there is a temptation on the part of the novice
      to, for example, define output to ostream as a class member
      function left shift that takes ostream as an argument.  This is
      exactly backwards.  The shift operator normally employs the
      destination (or source) on the left.

      On the other hand, if the class you are defining is the source or
      destination then defining the shift operators is entirely
      appropriate.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1935" id="1935">1935</a></td>
<td><pre>  Dynamic initialization for class object 'Symbol1' (references
      'Symbol2') -- A static class-like object whose name is Symbol1 is
      dynamically initialized by referencing Symbol2 (the latter is
      normally a constructor for the former).  The reason for noting
      this initialization is that the order of inter-module dynamic
      initializations is not defined.  (Within a module, however, the
      intializations are done in the order of appearance.)  Hence, if
      the constructor is itself dependent on dynamic initialization
      occurring in another module the behavior is undefined.  For
      example:
     
            class X
                {  X( ): ... };

            X x:

      This will elicit Elective Note 1935 that x is being initialized
      dynamically by a call to X::X( ).  Now, if this constructor were
      to be accessing information that depended on the order of
      evaluation (such as accessing the value of x itself) the result
      would be undefined.  We have no evidence of this at this point.
      and for this reason the message is in the Elective Note category.
      However, programmers with a suspected order-of-initialization
      problem will probably want to turn this on.  See also 1936, 1937,
      1544 and 1545.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1936" id="1936">1936</a></td>
<td><pre>  Dynamic initialization for scalar 'Symbol1' (references
      'Symbol2') -- A static scalar whose name is Symbol1 is
      dynamically initialized and references Symbol2 during the
      initialization.  For example, let a module consist only of:
     
            int f( );
            int n = f( );

      Here we report that n is dynamically initialized by f( ).  There
      may be other symbols referenced, Symbol2 is just the first.  The
      reason for noting this initialization is that the order of
      inter-module dynamic initializations is not defined.  (Within a
      module, however, the initializations are done in the order of
      appearance.)  If Symbol2 were a variable, then PC-lint/FlexeLint
      could determine that the variable is dynamically initialized in
      another module and issue a 1544 or 1545 as appropriate.  However,
      the symbol referenced could be a function (as in the example) and
      PC-lint/FlexeLint does not analyze the complete function call
      graph to determine whether there is a dependency on another
      dynamic initialization.  See also 1935 and 1937.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1937" id="1937">1937</a></td>
<td><pre>  Static variable 'Symbol' has a destructor. -- A static scalar
      whose name is Symbol has a destructor.  Destructors of static
      objects are invoked in a predictable order only for objects
      within the same module (the reverse order of construction).  For
      objects in different modules this order is indeterminate.  Hence,
      if the correct operation of a destructor depends on the existence
      of an object in some other module an indeterminacy could result.
      See also 1935, 1936, 1544 and 1545.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1938" id="1938">1938</a></td>
<td><pre>  constructor 'Symbol' accesses global data. -- A constructor is
      accessing global data.  It is generally not a good idea for
      constructors to access global data because order of
      initialization dependencies can be created.  If the global data
      is itself initialized in another module and if the constructor is
      accessed during initialization, a 'race' condition is
      established.  [12, Item 47]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1939" id="1939">1939</a></td>
<td><pre>  Down cast detected -- A down cast is a cast from a pointer (or
      reference) to a base class to a pointer (or reference) to a
      derived class.  A cast down the class hierarchy is fraught with
      danger.  Are you sure that the alleged base class pointer really
      points to an object in the derived class.  Some amount of down
      casting is necessary but a wise programmer will reduce this to a
      minimum.  [12, Item 39]

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1940" id="1940">1940</a></td>
<td><pre>  Address of reference parameter 'Symbol' transferred outside of
      function -- The address of a reference parameter is being
      transferred (either via a return statement, assigned to a static,
      or assigned through a pointer parameter) to a point where it can
      persist beyond the lifetime of the function.  These are all
      violations of the Linton Convention (see Murray [21]).

      The particular instance at hand is with a reference to a
      non-const and as such is not considered as dangerous as with a
      reference to a const. (See 1780, 1781 and 1782 in Section
      <ref,13.8 informational="" messages,13.8=""> for those cases).  For
      example:
     
              int *f( int &amp;n ) { return &amp;n; }
              int g();
              int *p = f( g() );
     
      would create a problem were it not for the fact that this is
      diagnosed as a non-lvalue being assigned to a reference to
      non-const.

</ref,13.8></pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1941" id="1941">1941</a></td>
<td><pre>  Assignment operator for class 'Symbol' does not return a const
      reference to class -- The typical use of an assignment operator
      for class C is to assign new information to variables of class C.
      If this were the entire story there would be no need for the
      assignment operator to return anything.  However, it is
      conventional to support chains of assignment as in:
     
              C x, y, z;
              ...
              x = y = z;
              // parsed as x = (y = z);
     
      For this reason assignment normally returns a reference to the
      object assigned the value.  For example, assignment (y = z) would
      return a reference to y.

      Since it is almost never the case that this variable is to be
      reassigned, i.e. we almost never wish to write:
     
              (x = y) = z;    // unusual
     
      as a general rule it is better to make the assignment operator
      return a const reference.  This will generate a warning when the
      unusual case is attempted.

      But experts differ.  Some maintain that in order to support
      non-const member functions operating directly on the result of an
      assignment as in:
     
              (x = y).mangle();
     
      where, as its name suggests, mangle is non-const it would be
      necessary for the return value of assignment to be non-const.
      Another reason to not insist on the const qualifier is that the
      default assignment operator returns simply a reference to object
      and not a reference to const object.  In an age of generic
      programming, compatibility may more important than the additional
      protection that the const would offer.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1942" id="1942">1942</a></td>
<td><pre>  Unqualified name 'Symbol' subject to misinterpretation owing to
      dependent base class -- An unqualified name used within a class
      template was not found within the class and, moreover, the class
      has at least one dependent base class.  There is a potential
      ambiguity here.  According to the standard, the dependent base
      class should not be searched either at template definition time
      or at template instantiation time.  Nonetheless, some
      implementations do make that search at instantiation time.  Even
      if the compiler is conforming, the implementator or even a reader
      of the code may think the base class is searched leading to
      confusion.

      To eliminate the abiguity, the name should be fully qualified (or
      referenced using this).  For example:
     
          class X;
          template&lt; class T &gt;
              class A : T
                  {
                  X *p;
                  bool f() { return y; }
                  };
     
      Both the reference to X (on line 5) and to y (one line 6) will be
      flagged.  One possible modification is:
     
          class X;
          template&lt; class T &gt;
              class A : T
                  {
                  ::X *p;
                  bool f() { return this-&gt;y; }
                  };
     
      This solidifies and disambiguates the code.  The reference to X
      is guaranteed to be the X on line 1 and can no longer be
      high-jacked by the base class.  Also, since y is not a member of
      A, the class will not instantiate unless y is found to be a
      member of the base class.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1960" id="1960">1960</a></td>
<td><pre>  Violates MISRA C++ Required Rule Name, String -- In addition to a
      C coding standard, MISRA has also compiled a C++ one.  We suggest
      use of the options file au-misra-cpp.lnt to activate these and
      other MISRA C++ messages.

      The list of checks made are as follows:

      (Rule 0-1-8)  Void return type for function without external side-effects.
      (Rule 2-13-2) Octal constant or escape sequence used.
      (Rule 2-13-4) Lower case literal suffix.
      (Rule 3-1-1)  Object/function definitions in headers.
      (Rule 3-1-2)  Function not declared at file scope.
      (Rule 3-2-3)  Object/function previously declared in location.
      (Rule 3-9-3)  Bit representation of a floating point type used.
      (Rule 4-5-1)  Boolean expression used with non-permitted operator.
      (Rule 4-5-3)  Plain char used with prohibited operator.
      (Rule 5-0-3)  Implicit conversion of cvalue.
      (Rule 5-0-4)  Implicit conversion changes signedness.
      (Rule 5-0-5)  Implicit conversion between integer and floating point types.
      (Rule 5-0-6)  Implicit conversion to smaller type.
      (Rule 5-0-7)  Cast of cvalue between integer and floating point types.
      (Rule 5-0-8)  Cast of cvalue to larger type.
      (Rule 5-0-9)  Cast of cvalue changes signedness.
      (Rule 5-0-10) Recasting required for operators '~' and '&lt;&lt;'.
      (Rule 5-0-11) Disallowed use of non-character value.
      (Rule 5-0-12) Disallowed use of non-numeric value.
      (Rule 5-0-15) Pointer arithmetic other than array indexing used.
      (rule 5-0-19) More than two pointer indirection levels used.
      (Rule 5-0-21) Bitwise operator applied to signed underlying type.
      (Rule 5-2-1)  Non-postfix expression used with logical operator.
      (Rule 5-2-5)  Attempt to cast away const/volatile from a pointer or reference.
      (Rule 5-2-12) Array-pointer decay when passing the array to a function.
      (Rule 5-3-1)  Boolean expresion required for operator.
      (Rule 5-3-2)  Prohibited operator applied to unsigned underlying type: .
      (Rule 5-3-3)  Overloading unary &amp;.
      (Rule 5-3-4)  'sizeof' used on expressions with side effect.
      (Rule 5-14-1) Side effects on right hand side of logical operator.
      (Rule 5-18-1) Comma operator used.
      (Rule 6-2-3)  Null statement not in line by itself.
      (Rules 6-3-1 and 6-4-1) Left brace expected for if, else, for, do, switch and while.
      (Rule 6-4-2)  No 'else' at end of 'if ... else if' chain.
      (Rule 6-4-7)  Boolean value in switch expression.
      (Rule 6-6-2)  Gotos jumping to an earlier point in the code.
      (Rule 6-6-3)  continue statement should not be used.
      (Rule 6-6-4)  More than one 'break' terminates loop.
      (Rule 7-3-1)  Global declarations other than main(), namespace declarations, extern "C" declarations and arithmetic typedefs.
      (Rule 7-3-2)  Using the identifier main for functions other than the global one.
      (Rule 7-3-3)  Unnamed namespaces in headers.
      (Rule 7-3-4)  No using-directives allowed.
      (Rule 7-3-6)  using-directives or using declarations (except class and/or block scope using declarations) in header files.
      (Rule 8-0-1)  Multiple declarators in a declaration.
      (Rule 8-4-1)  Function has variable number of arguments.
      (Rule 8-4-2)  Function parameter list differs 
      (Rule 8-4-4)  Function identifier used without '&amp;' or parenthisized parameter list.
      (Rule 8-5-3)  Should initialize either all enum members or only the first.
      (Rule 9-5-1)  Unions shall not be used.
      (Rule 11-0-1) Non-private data member within a no-POD structure.
      (Rule 12-8-2) Public copy constructor in abstract class.
      (Rule 14-8-1) Explicit specialization of overloaded function templates.
      (Rule 15-1-2) Explicit throw of the Null macro.
      (Rule 15-1-3) Empty throw outside of a catch block.
      (Rule 15-3-7) Catch handler after catch(...) in a try-catch sequence.
      (Rule 16-0-1) Only preprocessor statements and comments before '#include'.
      (Rule 16-0-2) '#define/#undef' used within a block.
      (Rule 16-0-3) Use of '#undef' is discouraged.
      (Rule 16-0-4) Use of function-like macros is discouraged.
      (Rule 16-1-1) Non-standard use of 'defined' preprocessor operator.
      (Rule 16-2-4) Header file name with non-standard character: .
      (Rule 16-3-1) Multiple use of '#' and/or '##' operators in macro definition.
      (Rule 17-0-2) Re-use of reserved identifier

      You may disable individual rules to your taste by using the Rule
      number in an esym option; see Message 960.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1961" id="1961">1961</a></td>
<td><pre>  virtual member function 'Symbol' could be made const -- This
      message is similar to message 1762 (member function could be made
      const) except that it is issued for a virtual function.  You may
      not want to make virtual functions const because then any
      overriding function would have to be const as well.  Consider,
      for example:
     
            class A { virtual void f( ) {} /* ... */ };
            class B : public A
                { int a; void f( ) { a = 0; } };

      Here, class B overrides A's function f( ) and, in doing so,
      modifies member a.  If A::f( ) had been declared const, this
      would not have been possible.

      Nonetheless, a particularly rigorous user may want to hunt down
      such virtual functions and make them all const and so this Note
      is provided.

      This message is also similar to Note 1962 which is issued for
      functions that make deep modifications.  Note 1962 takes priority
      over 1961.  That is, a virtual function that makes a deep
      modification (but no shallow modifications) will have Note 1962
      issued but not Note 1961.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1962" id="1962">1962</a></td>
<td><pre>  Non-const member function 'Symbol' contains a deep modification.
      -- The designated member function could be declared const but
      shouldn't be because it contains a deep modification.  For
      example:
     
            class X
                {
                char *p;
                public:
                void f( ) { *p = 0; }
                x( );
                };

      will elicit this message indicating that X::f( ) contains a deep
      modification. A modification is considered shallow if it modifies
      (or exposes for modification) a class member directly.  A
      modification is considered deep if it modifies information
      indirectly through a class member pointer.  This Elective Note is
      available for completeness so that a programmer can find all
      functions that could result in a class being modified.  It does
      not indicate that the programming is deficient.  In particular,
      if the function is marked const an Info 1763 will be issued.  See
      also 1762, 1763.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="1963" id="1963">1963</a></td>
<td><pre>  Violates MISRA C++ Advisory Rule Name, String -- This message is
      issued for some violations of the MISRA C++ advisory guidelines.
      We suggest use of the options file au-misra-cpp.lnt to activate
      these and other MISRA C++ messages.

      The list of checks made are as follows:
      (Rule 2-5-1)  Possible digraph used.
      (Rule 5-0-2)  Dependence placed on C's operator precedence.
      (Rule 5-2-10) Increment or decrement combined with another operator.
      (Rule 14-8-2) Mixing template and non-template functions in a viable sets.
      (Rule 15-0-2) Throwing a pointer expression.
      (Rule 16-2-5) Header file name with non-standard character.
      (Rule 16-3-2) No use of '#' or '##'.

      Messages can be suppressed based on rule number. See Message 960.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9001" id="9001">9001</a></td>
<td><pre>  Octal constant used -- An octal constant appears in the code.
      Octal constants may be inadvertently interpreted by engineers as
      decimal values. This message is not issued for a constant zero
      written as a single digit.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9003" id="9003">9003</a></td>
<td><pre>  could define variable 'Symbol' at block scope -- A variable was
      declared at global scope but only utilized within one function.
      Moving the declaration of this variable to that function reduces
      the chance the variable will be used incorrectly.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9004" id="9004">9004</a></td>
<td><pre>  object/function 'Symbol' previously declared -- The named symbol
      was declared in multiple locations, not counting the point of
      defintion for that symbol. Declaring a symbol in one location and
      in one file helps to ensure consistency between declaration and
      definition as well as avoiding the risk of conflicting defintions
      across modules.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9005" id="9005">9005</a></td>
<td><pre>  attempt to cast away const/volatile from a pointer or reference
      -- A cast attempted to remove the qualifiers from an object to
      which a pointer points or a reference refers. Doing so can result
      in undesired or unexpected modification of the object in question
      and may result in an exception being thrown.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9006" id="9006">9006</a></td>
<td><pre>  'sizeof' used on expression with side effect -- If the operand of
      the sizeof operator is an expression, it is not usually
      evaluated.  Attempting to apply sizeof to such an expression can
      result, therefore, in code one expects to be evaluated actually
      not being evaluated and the side-effects not taking place.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9007" id="9007">9007</a></td>
<td><pre>  side effects on right hand of logical operator, 'String' -- The
      right hand side of the || and &amp;&amp; operators is evaluated only if
      the left hand side evaluates to a certain value.  Consequently,
      code which expects the right hand side to be evaluated regardless
      of the left hand side can produce unanticipated results.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9008" id="9008">9008</a></td>
<td><pre>  comma operator used -- The comma operator is thought by some to
      reduce readability in code.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9009" id="9009">9009</a></td>
<td><pre>  floating point variable used as loop counter -- The use of
      floating point variables as loop counters can produce surprising
      behavior if the accumulation of rounding errors results in a
      different numer of iterations than anticipated.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9011" id="9011">9011</a></td>
<td><pre>  more than one 'break' terminates loop -- More than one break
      statement was seen in a loop. Minimizing the number of exits from
      a loop is thought by some to reduce visual complexity of the
      code.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9012" id="9012">9012</a></td>
<td><pre>  sub-statement should be a compound statement -- Multiple authors
      have advised making sure the body of every iteration-statement
      and selection-statement be a compound-statement. However, no {
      was seen to begin the compound-statement.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9013" id="9013">9013</a></td>
<td><pre>  no 'else' at end of 'if ... else if' chain -- An if ... else if
      chain was seen without a final else statement. Providing such a
      statement helps to act as an analog to the default case of a
      switch-statement.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9014" id="9014">9014</a></td>
<td><pre>  default missing from switch statement -- A switch-statement was
      found without a default case.  Providing such a case provides
      defensive programming.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9015" id="9015">9015</a></td>
<td><pre>  macro argument is used both with and without '#/##' and is
      subject to further replacement -- A macro argument was used both
      as an operand to the stringizing or pasting operators and not
      used as such.  Moreover, this macro argument is subject to
      further replacement.  This could cause confusion.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9016" id="9016">9016</a></td>
<td><pre>  pointer arithmetic other than array indexing used -- Array
      indexing is thought, by some, to be more readily understood and
      less error prone than other forms of pointer arithmetic.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9017" id="9017">9017</a></td>
<td><pre>  pointer arithmetic by increment or decrement used -- While at
      least one standards organization cautions against using any
      pointer arithmetic besides array indexing, the use of increment
      or decrement operators with pointers may represent an intuitive
      application and illustration of the underlying logic.
      Consequently, such constructs are separated from the prior
      message #9016 and placed under this one, allowing more fine
      tuning of Lint diagnostics.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9018" id="9018">9018</a></td>
<td><pre>  declaration of union type or object of union type, 'Type' --
      Depending upon padding, alignment, and endianness of union, as
      well as the size and bit-order of their members, the use of
      unions can result in unspecified, undefined, or implementation
      defined behavior, prompting some to advise against their use.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9019" id="9019">9019</a></td>
<td><pre>  declaration of 'String' before #include -- The symbol mentioned
      in String was seen in a module with a subsequent #include
      directive. It can be argued that collecting all #include
      directives at the beginning of the module helps improve code
      readability and helps reduce the risk of undefined behavior
      resulting from any use of the ISO standard library before the
      relevant #include directive.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9020" id="9020">9020</a></td>
<td><pre>  header file name with non-standard character 'String' -- The use
      of non-standard characters in #include directives results in
      undefined behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9021" id="9021">9021</a></td>
<td><pre>  use of '#undef' is discouraged: 'String' -- The use of the #undef
      directive can lead to confusion about whether or not a particular
      macro exists at a randomly given point of code.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9022" id="9022">9022</a></td>
<td><pre>  unparenthesized macro parameter in definition of macro 'String'
      -- Multiple authors have cautioned against the use of
      unparenthesized macro parameters in cases where the parameter is
      used as an expression. If care is not taken, unparenthesized
      macro parameters can result in operator precedence rules
      producing expressions other than intended.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9023" id="9023">9023</a></td>
<td><pre>  Multiple use of '#/##' operators in definition of macro 'String'
      -- Multiple use of such operators is thought by some to increase
      the risk of undefined behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9024" id="9024">9024</a></td>
<td><pre>  '#/##' operator used in macro 'String' -- The use of such
      operators is thought to reduce code clarity and increase the risk
      of undefined behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9025" id="9025">9025</a></td>
<td><pre>  More than two pointer indirection levels used for type 'Type' --
      Three or more levels of pointer indirection may make it harder to
      understand the code.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9026" id="9026">9026</a></td>
<td><pre>  Function-like macro, 'String', defined -- Multiple authors have
      expressed reasons why a function, when possible, should be used
      in place of a function-like macro.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9027" id="9027">9027</a></td>
<td><pre>  Unpermitted operand to operator 'String' -- Out of concern for
      unspecified, undefined, and/or implementation defined behavior,
      some standards urge restrictions on certain types of operands
      when used with certain operators.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9028" id="9028">9028</a></td>
<td><pre>  Unpermitted arithmetic involving an essentially character type --
      MISRA C 2012 has defined the concept of essentially character
      type and placed restrictions on the use of expressions with such
      a type.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9029" id="9029">9029</a></td>
<td><pre>  Mismatched essential type categories for binary operator -- MISRA
      C 2012 has defined the concept of essential type and placed
      restrictions on the use of expressions with certain types with
      respect to binary operators.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9030" id="9030">9030</a></td>
<td><pre>  Impermissible cast -- MISRA C 2012 has defined the concept of
      essential type and placed restrictions on the use of casts
      between certain types.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9031" id="9031">9031</a></td>
<td><pre>  Composite expression assigned to a wider essential type -- MISRA
      C 2012 has defined the concepts of composite expression and
      essential type and placed restrictions on assignments of the
      former.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9032" id="9032">9032</a></td>
<td><pre>  Composite expression with smaller essential type than other
      operand -- MISRA C 2012 has defined the concepts of composite
      expression and essential type and placed restrictions on operands
      to binary operators when at least one of the operands meets the
      definition of the former concept.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9033" id="9033">9033</a></td>
<td><pre>  Impermissible cast of composite expression -- MISRA C 2012 has
      defined the concepts of composite expression and essential type
      and placed restrictions on casts of the former. This message,
      when given, is also followed by text explaining why the cast is
      considered "impermissible".

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9034" id="9034">9034</a></td>
<td><pre>  Expression assigned to a narrower or different essential type --
      MISRA C 2012 has defined the concept of essential type and placed
      restrictions on assignments in relation to such types.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9035" id="9035">9035</a></td>
<td><pre>  Variable length array declared -- Some have expressed concern
      over the use of variable length arrays, noting how, even in
      common use cases of arrays, use of such arrays can result in
      undefined or unspecified behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9036" id="9036">9036</a></td>
<td><pre>  Conditional expression should have essentially Boolean type --
      MISRA C 2012 has defined the concept of essentially Boolean type
      and requires that the conditional expressions of all if and
      iteration-statements comply with this definition.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9037" id="9037">9037</a></td>
<td><pre>  Conditional of #if does not evaluate to 0 or 1 -- Some urge such
      a practice in the interest of strong typing.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9038" id="9038">9038</a></td>
<td><pre>  Flexible array member declared -- Flexible array members can
      alter the behavior of sizeof in surprising ways. Additionally,
      flexible array members often require dynamic memory allocation
      which may be problematic in safety critical code.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9039" id="9039">9039</a></td>
<td><pre>  Prohibited escape sequence usage -- An octal or hexadecimal
      escape sequence has been detected within a string or character
      literal which is not immediately followed by another escape
      sequence or end of literal.  Such escape sequence usage has been
      deprecated on the grounds of potential confusion when attempting
      to read such code.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9041" id="9041">9041</a></td>
<td><pre>  goto 'Symbol' appears in block 'String' which is not nested in
      block 'String' which contains the label. -- It has been deemed
      safer by some experts that the block (i.e. compound statement)
      containing the goto should be the same as or nested within the
      block containing the label.  Thus
     
          {  label:  {  goto label;  }  }
     
      is permitted but
     
          {  goto label;  {  label:  }  }
     
      is not.  To assist the programmer, the message refers to the
      blocks using an identification code (Example: "1.2.1").  This
      identification scheme is defined as follows.
        (a) The outer block has an identification of 1.
        (b) If a particular block is identified by x then its
            immediate subblocks, if any, are identified as x.1,
            x.2, x.3, etc.

      Thus in the following 'code',
     
          {  {  }  { { label: } { } } }
     
      label: lies in block 1.2.1.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9042" id="9042">9042</a></td>
<td><pre>  departure from MISRA switch syntax -- A switch-statement was
      found which does not comply with the MISRA switch-statement
      syntax.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9043" id="9043">9043</a></td>
<td><pre>  static keyword between brackets of array declaration -- Some
      advocate against using the keyword static in array declarations
      due to a perceived increased risk of undefined behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9044" id="9044">9044</a></td>
<td><pre>  function parameter modified -- It has been advocated that
      function parameters be first copied to local variables where they
      can be modified rather than modifying the parameters directly.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9045" id="9045">9045</a></td>
<td><pre>  non-hidden definition of type 'Type' -- Some advise against
      including structure definitions unless the definition is required
      for the current module.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9046" id="9046">9046</a></td>
<td><pre>  Typographical ambiguity with respect to symbol, 'Symbol',
      Reasons, Location -- Some have warned against the use of
      identifiers which may be considered typographically ambiguous. In
      addition to the name of the previously seen symbol, the reasons
      Lint considers the identifiers to be ambiguous and the location
      of said previous symbol are provided in the message, if
      available.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9047" id="9047">9047</a></td>
<td><pre>  FILE pointer dereferenced -- At least one standards organization
      urges against this practice, directly or indirectly.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9048" id="9048">9048</a></td>
<td><pre>  unsigned integer literal without a 'U' suffix -- An integer
      literal of unsigned type was found without a 'U' suffix.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9049" id="9049">9049</a></td>
<td><pre>  increment/decrement operation combined with other operation with
      side-effects -- An expression was seen involving an increment or
      decrement operator and the expression also contained potential
      side-effects other than those resulting from said operator.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9050" id="9050">9050</a></td>
<td><pre>  dependence placed on C/C++ operator precedence -- Reliance on
      operator precedence was found in a particular expression.  Using
      parentheses, it is felt, helps clarify the order of evaluation.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9051" id="9051">9051</a></td>
<td><pre>  macro 'Symbol' defined with the same name as a C keyword -- A
      macro was defined with the same name as an ISO C keyword. The use
      of such a macro causes undefined behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9052" id="9052">9052</a></td>
<td><pre>  macro 'Symbol' defined with the same name as a C++ keyword -- A
      macro was defined with the same name as an ISO C++ keyword. The
      use of such a macro causes undefined behavior.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9053" id="9053">9053</a></td>
<td><pre>  the shift value is at least the precision of the essential type
      of the left hand side -- MISRA 2012 defines the notion of an
      "essential type". A quantity with a certain essential type, as
      defined by MISRA, was left shifted by a number exceeding the
      number of bits used to represent that essential type.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9054" id="9054">9054</a></td>
<td><pre>  designated initalizer used with array of unspecified dimension --
      It has been advocated, when array initializers contain
      designators, the dimension of the array should be explicitly
      stated in the declaration. The initializer of the array in
      question has been found in violation of this recommendation.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9055" id="9055">9055</a></td>
<td><pre>  Most closely enclosing compound statement of a case/default is
      not the body of a switch -- Switch labels nested inside of
      compound statements within the corresponding switch are legal but
      can reduce comprehension and lead to unstructured code.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9056" id="9056">9056</a></td>
<td><pre>  Inline function 'Symbol' defined with storage-class specifier
      'String' -- This message is issued for all inline functions
      defined with a storage-class specifier.  +estring can be used to
      find all inline functions defined with a specific specifier.  For
      example, +estring(9056, extern) will report all inline functions
      defined with extern.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9057" id="9057">9057</a></td>
<td><pre>  Lowercase L follows 'u' in literal suffix -- A lowercase letter
      "l" is used inside of a literal suffix following an upper or
      lowercase letter u.  With some fonts, the lowercase letter "l"
      can be easily confused with the number one.  This is less likely
      to happen when there is a "u" between the number and the "l" (as
      in 35ul), but some coding standards forbid the use of "l" in any
      literals.  Message 620 reports the more suspicious case where the
      "l" immediately follows a number (as in 35l).

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9058" id="9058">9058</a></td>
<td><pre>  tag 'Symbol' (Location) unused outside of typedefs -- A tag was
      used only in the course of creating a typedef.  Was the tag
      unused by mistake (say a recursive reference inside the body of
      the struct was accidentally omitted)?  Such tags are most often
      redundant and can be eliminated.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9059" id="9059">9059</a></td>
<td><pre>  C comment contains C++ comment -- A C++-style comment was seen
      inside a C-style comment.  This can be confusing.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9060" id="9060">9060</a></td>
<td><pre>  trigraph in comment -- A trigraph was seen inside a comment.
      Since trigraphs are translated before preprocessing, a trigraph
      sequence like ??/ can have surprising results, especially in a
      C++ style comment where the trigraph sequence translates into a
      backslash.

</pre><a href="#top">Top</a></td>
</tr>

<tr style="border: 1">
<td style="width: 10%; color: blue" valign="top"><a name="9066" id="9066">9066</a></td>
<td><pre>  C++ comment contains C comment -- A C-style comment was seen
      inside a C++-style comment.  This can result in confusion.
</pre><a href="#top">Top</a></td>
</tr>

</tbody>
</table><a name="top" id="top">
</a></td>
</tr>
<tr>
<td style="text-align: center; width: 100%;"><a href="http://www.gimpel-online.com/bugsLinkPage.html">Run FlexeLint on Bug of the Month Samples</a><br><a href="http://www.gimpel.com/">Home</a> | <a href="http://www.gimpel-online.com/OnlineTesting.html">Examples</a> | <a href="http://www.gimpel.com/html/contact.htm">Contact</a> | <a href="http://www.gimpel.com/html/order.htm">Order</a><br>
<br>
<span style="">PC-lint and FlexeLint are trademarks of Gimpel Software</span><br>
<span style="">Copyright  2011, Gimpel Software</span><br>
<br>
</td>
</tr>
</tbody>
</table>


<p style="text-align: center;">
<a href="http://validator.w3.org/check?uri=referer">
<img src="../index_files/valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" style="" height="31" width="88">
</a>
<a href="http://www.anybrowser.org/campaign/">
<img src="../index_files/any_html4_browser.png" alt="Viewable With Any Browser" height="31" width="88">
</a>
</p>



</body></html>